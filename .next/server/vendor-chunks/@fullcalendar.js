"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fullcalendar";
exports.ids = ["vendor-chunks/@fullcalendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/@fullcalendar/core/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@fullcalendar/core/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Calendar: () => (/* binding */ Calendar),\n/* harmony export */   JsonRequestError: () => (/* reexport safe */ _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   createPlugin: () => (/* binding */ createPlugin),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatRange: () => (/* binding */ formatRange),\n/* harmony export */   globalLocales: () => (/* binding */ globalLocales),\n/* harmony export */   globalPlugins: () => (/* binding */ globalPlugins),\n/* harmony export */   sliceEvents: () => (/* binding */ sliceEvents),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _internal_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal-common.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! preact/compat */ \"(ssr)/./node_modules/preact/compat/dist/compat.mjs\");\n\n\n\n\nconst globalLocales = [];\nconst MINIMAL_RAW_EN_LOCALE = {\n    code: \"en\",\n    week: {\n        dow: 0,\n        doy: 4\n    },\n    direction: \"ltr\",\n    buttonText: {\n        prev: \"prev\",\n        next: \"next\",\n        prevYear: \"prev year\",\n        nextYear: \"next year\",\n        year: \"year\",\n        today: \"today\",\n        month: \"month\",\n        week: \"week\",\n        day: \"day\",\n        list: \"list\"\n    },\n    weekText: \"W\",\n    weekTextLong: \"Week\",\n    closeHint: \"Close\",\n    timeHint: \"Time\",\n    eventHint: \"Event\",\n    allDayText: \"all-day\",\n    moreLinkText: \"more\",\n    noEventsText: \"No events to display\"\n};\nconst RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {\n    // Includes things we don't want other locales to inherit,\n    // things that derive from other translatable strings.\n    buttonHints: {\n        prev: \"Previous $0\",\n        next: \"Next $0\",\n        today (buttonText, unit) {\n            return unit === \"day\" ? \"Today\" : `This ${buttonText}`;\n        }\n    },\n    viewHint: \"$0 view\",\n    navLinkHint: \"Go to $0\",\n    moreLinkHint (eventCnt) {\n        return `Show ${eventCnt} more event${eventCnt === 1 ? \"\" : \"s\"}`;\n    }\n});\nfunction organizeRawLocales(explicitRawLocales) {\n    let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : \"en\";\n    let allRawLocales = globalLocales.concat(explicitRawLocales);\n    let rawLocaleMap = {\n        en: RAW_EN_LOCALE\n    };\n    for (let rawLocale of allRawLocales){\n        rawLocaleMap[rawLocale.code] = rawLocale;\n    }\n    return {\n        map: rawLocaleMap,\n        defaultCode\n    };\n}\nfunction buildLocale(inputSingular, available) {\n    if (typeof inputSingular === \"object\" && !Array.isArray(inputSingular)) {\n        return parseLocale(inputSingular.code, [\n            inputSingular.code\n        ], inputSingular);\n    }\n    return queryLocale(inputSingular, available);\n}\nfunction queryLocale(codeArg, available) {\n    let codes = [].concat(codeArg || []); // will convert to array\n    let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n    return parseLocale(codeArg, codes, raw);\n}\nfunction queryRawLocale(codes, available) {\n    for(let i = 0; i < codes.length; i += 1){\n        let parts = codes[i].toLocaleLowerCase().split(\"-\");\n        for(let j = parts.length; j > 0; j -= 1){\n            let simpleId = parts.slice(0, j).join(\"-\");\n            if (available[simpleId]) {\n                return available[simpleId];\n            }\n        }\n    }\n    return null;\n}\nfunction parseLocale(codeArg, codes, raw) {\n    let merged = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.m)([\n        MINIMAL_RAW_EN_LOCALE,\n        raw\n    ], [\n        \"buttonText\"\n    ]);\n    delete merged.code; // don't want this part of the options\n    let { week } = merged;\n    delete merged.week;\n    return {\n        codeArg,\n        codes,\n        week,\n        simpleNumberFormat: new Intl.NumberFormat(codeArg),\n        options: merged\n    };\n}\n// TODO: easier way to add new hooks? need to update a million things\nfunction createPlugin(input) {\n    return {\n        id: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)(),\n        name: input.name,\n        premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,\n        deps: input.deps || [],\n        reducers: input.reducers || [],\n        isLoadingFuncs: input.isLoadingFuncs || [],\n        contextInit: [].concat(input.contextInit || []),\n        eventRefiners: input.eventRefiners || {},\n        eventDefMemberAdders: input.eventDefMemberAdders || [],\n        eventSourceRefiners: input.eventSourceRefiners || {},\n        isDraggableTransformers: input.isDraggableTransformers || [],\n        eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n        eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n        dateSelectionTransformers: input.dateSelectionTransformers || [],\n        datePointTransforms: input.datePointTransforms || [],\n        dateSpanTransforms: input.dateSpanTransforms || [],\n        views: input.views || {},\n        viewPropsTransformers: input.viewPropsTransformers || [],\n        isPropsValid: input.isPropsValid || null,\n        externalDefTransforms: input.externalDefTransforms || [],\n        viewContainerAppends: input.viewContainerAppends || [],\n        eventDropTransformers: input.eventDropTransformers || [],\n        componentInteractions: input.componentInteractions || [],\n        calendarInteractions: input.calendarInteractions || [],\n        themeClasses: input.themeClasses || {},\n        eventSourceDefs: input.eventSourceDefs || [],\n        cmdFormatter: input.cmdFormatter,\n        recurringTypes: input.recurringTypes || [],\n        namedTimeZonedImpl: input.namedTimeZonedImpl,\n        initialView: input.initialView || \"\",\n        elementDraggingImpl: input.elementDraggingImpl,\n        optionChangeHandlers: input.optionChangeHandlers || {},\n        scrollGridImpl: input.scrollGridImpl || null,\n        listenerRefiners: input.listenerRefiners || {},\n        optionRefiners: input.optionRefiners || {},\n        propSetHandlers: input.propSetHandlers || {}\n    };\n}\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n    let currentPluginIds = {};\n    let hooks = {\n        premiumReleaseDate: undefined,\n        reducers: [],\n        isLoadingFuncs: [],\n        contextInit: [],\n        eventRefiners: {},\n        eventDefMemberAdders: [],\n        eventSourceRefiners: {},\n        isDraggableTransformers: [],\n        eventDragMutationMassagers: [],\n        eventDefMutationAppliers: [],\n        dateSelectionTransformers: [],\n        datePointTransforms: [],\n        dateSpanTransforms: [],\n        views: {},\n        viewPropsTransformers: [],\n        isPropsValid: null,\n        externalDefTransforms: [],\n        viewContainerAppends: [],\n        eventDropTransformers: [],\n        componentInteractions: [],\n        calendarInteractions: [],\n        themeClasses: {},\n        eventSourceDefs: [],\n        cmdFormatter: null,\n        recurringTypes: [],\n        namedTimeZonedImpl: null,\n        initialView: \"\",\n        elementDraggingImpl: null,\n        optionChangeHandlers: {},\n        scrollGridImpl: null,\n        listenerRefiners: {},\n        optionRefiners: {},\n        propSetHandlers: {}\n    };\n    function addDefs(defs) {\n        for (let def of defs){\n            const pluginName = def.name;\n            const currentId = currentPluginIds[pluginName];\n            if (currentId === undefined) {\n                currentPluginIds[pluginName] = def.id;\n                addDefs(def.deps);\n                hooks = combineHooks(hooks, def);\n            } else if (currentId !== def.id) {\n                // different ID than the one already added\n                console.warn(`Duplicate plugin '${pluginName}'`);\n            }\n        }\n    }\n    if (pluginDefs) {\n        addDefs(pluginDefs);\n    }\n    addDefs(globalDefs);\n    return hooks;\n}\nfunction buildBuildPluginHooks() {\n    let currentOverrideDefs = [];\n    let currentGlobalDefs = [];\n    let currentHooks;\n    return (overrideDefs, globalDefs)=>{\n        if (!currentHooks || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(overrideDefs, currentOverrideDefs) || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(globalDefs, currentGlobalDefs)) {\n            currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n        }\n        currentOverrideDefs = overrideDefs;\n        currentGlobalDefs = globalDefs;\n        return currentHooks;\n    };\n}\nfunction combineHooks(hooks0, hooks1) {\n    return {\n        premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),\n        reducers: hooks0.reducers.concat(hooks1.reducers),\n        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n        contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n        eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n        eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n        views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),\n        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n        themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),\n        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n        initialView: hooks0.initialView || hooks1.initialView,\n        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n        optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n        listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n        optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n        propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n    };\n}\nfunction compareOptionalDates(date0, date1) {\n    if (date0 === undefined) {\n        return date1;\n    }\n    if (date1 === undefined) {\n        return date0;\n    }\n    return new Date(Math.max(date0.valueOf(), date1.valueOf()));\n}\nclass StandardTheme extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.T {\n}\nStandardTheme.prototype.classes = {\n    root: \"fc-theme-standard\",\n    tableCellShaded: \"fc-cell-shaded\",\n    buttonGroup: \"fc-button-group\",\n    button: \"fc-button fc-button-primary\",\n    buttonActive: \"fc-button-active\"\n};\nStandardTheme.prototype.baseIconClass = \"fc-icon\";\nStandardTheme.prototype.iconClasses = {\n    close: \"fc-icon-x\",\n    prev: \"fc-icon-chevron-left\",\n    next: \"fc-icon-chevron-right\",\n    prevYear: \"fc-icon-chevrons-left\",\n    nextYear: \"fc-icon-chevrons-right\"\n};\nStandardTheme.prototype.rtlIconClasses = {\n    prev: \"fc-icon-chevron-right\",\n    next: \"fc-icon-chevron-left\",\n    prevYear: \"fc-icon-chevrons-right\",\n    nextYear: \"fc-icon-chevrons-left\"\n};\nStandardTheme.prototype.iconOverrideOption = \"buttonIcons\"; // TODO: make TS-friendly\nStandardTheme.prototype.iconOverrideCustomButtonOption = \"icon\";\nStandardTheme.prototype.iconOverridePrefix = \"fc-icon-\";\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n    let hash = {};\n    let viewType;\n    for(viewType in defaultConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    for(viewType in overrideConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    return hash;\n}\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    if (hash[viewType]) {\n        return hash[viewType];\n    }\n    let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    if (viewDef) {\n        hash[viewType] = viewDef;\n    }\n    return viewDef;\n}\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    let defaultConfig = defaultConfigs[viewType];\n    let overrideConfig = overrideConfigs[viewType];\n    let queryProp = (name)=>defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n    let theComponent = queryProp(\"component\");\n    let superType = queryProp(\"superType\");\n    let superDef = null;\n    if (superType) {\n        if (superType === viewType) {\n            throw new Error(\"Can't have a custom view type that references itself\");\n        }\n        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n    }\n    if (!theComponent && superDef) {\n        theComponent = superDef.component;\n    }\n    if (!theComponent) {\n        return null; // don't throw a warning, might be settings for a single-unit view\n    }\n    return {\n        type: viewType,\n        component: theComponent,\n        defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n        overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n    };\n}\nfunction parseViewConfigs(inputs) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(inputs, parseViewConfig);\n}\nfunction parseViewConfig(input) {\n    let rawOptions = typeof input === \"function\" ? {\n        component: input\n    } : input;\n    let { component } = rawOptions;\n    if (rawOptions.content) {\n        // TODO: remove content/classNames/didMount/etc from options?\n        component = createViewHookComponent(rawOptions);\n    } else if (component && !(component.prototype instanceof _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B)) {\n        // WHY?: people were using `component` property for `content`\n        // TODO: converge on one setting name\n        component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), {\n            content: component\n        }));\n    }\n    return {\n        superType: rawOptions.type,\n        component: component,\n        rawOptions\n    };\n}\nfunction createViewHookComponent(options) {\n    return (viewProps)=>(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Consumer, null, (context)=>(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.C, {\n                elTag: \"div\",\n                elClasses: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.b)(context.viewSpec),\n                renderProps: Object.assign(Object.assign({}, viewProps), {\n                    nextDayThreshold: context.options.nextDayThreshold\n                }),\n                generatorName: undefined,\n                customGenerator: options.content,\n                classNameGenerator: options.classNames,\n                didMount: options.didMount,\n                willUnmount: options.willUnmount\n            }));\n}\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let defaultConfigs = parseViewConfigs(defaultInputs);\n    let overrideConfigs = parseViewConfigs(optionOverrides.views);\n    let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(viewDefs, (viewDef)=>buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));\n}\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n    let duration = null;\n    let durationUnit = \"\";\n    let singleUnit = \"\";\n    let singleUnitOverrides = {};\n    if (durationInput) {\n        duration = createDurationCached(durationInput);\n        if (duration) {\n            let denom = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.c)(duration);\n            durationUnit = denom.unit;\n            if (denom.value === 1) {\n                singleUnit = durationUnit;\n                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n            }\n        }\n    }\n    let queryButtonText = (optionsSubset)=>{\n        let buttonTextMap = optionsSubset.buttonText || {};\n        let buttonTextKey = viewDef.defaults.buttonTextKey;\n        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n            return buttonTextMap[buttonTextKey];\n        }\n        if (buttonTextMap[viewDef.type] != null) {\n            return buttonTextMap[viewDef.type];\n        }\n        if (buttonTextMap[singleUnit] != null) {\n            return buttonTextMap[singleUnit];\n        }\n        return null;\n    };\n    let queryButtonTitle = (optionsSubset)=>{\n        let buttonHints = optionsSubset.buttonHints || {};\n        let buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n        if (buttonKey != null && buttonHints[buttonKey] != null) {\n            return buttonHints[buttonKey];\n        }\n        if (buttonHints[viewDef.type] != null) {\n            return buttonHints[viewDef.type];\n        }\n        if (buttonHints[singleUnit] != null) {\n            return buttonHints[singleUnit];\n        }\n        return null;\n    };\n    return {\n        type: viewDef.type,\n        component: viewDef.component,\n        duration,\n        durationUnit,\n        singleUnit,\n        optionDefaults: viewDef.defaults,\n        optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),\n        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n        viewDef.overrides.buttonText,\n        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e) || viewDef.type,\n        // not DRY\n        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n        buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e)\n    };\n}\n// hack to get memoization working\nlet durationInputMap = {};\nfunction createDurationCached(durationInput) {\n    let json = JSON.stringify(durationInput);\n    let res = durationInputMap[json];\n    if (res === undefined) {\n        res = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d)(durationInput);\n        durationInputMap[json] = res;\n    }\n    return res;\n}\nfunction reduceViewType(viewType, action) {\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            viewType = action.viewType;\n    }\n    return viewType;\n}\nfunction reduceCurrentDate(currentDate, action) {\n    switch(action.type){\n        case \"CHANGE_DATE\":\n            return action.dateMarker;\n        default:\n            return currentDate;\n    }\n}\n// should be initialized once and stay constant\n// this will change too\nfunction getInitialDate(options, dateEnv, nowManager) {\n    let initialDateInput = options.initialDate;\n    // compute the initial ambig-timezone date\n    if (initialDateInput != null) {\n        return dateEnv.createMarker(initialDateInput);\n    }\n    return nowManager.getDateMarker();\n}\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n    switch(action.type){\n        case \"SET_OPTION\":\n            return Object.assign(Object.assign({}, dynamicOptionOverrides), {\n                [action.optionName]: action.rawOptionValue\n            });\n        default:\n            return dynamicOptionOverrides;\n    }\n}\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n    let dp;\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            return dateProfileGenerator.build(action.dateMarker || currentDate);\n        case \"CHANGE_DATE\":\n            return dateProfileGenerator.build(action.dateMarker);\n        case \"PREV\":\n            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n        case \"NEXT\":\n            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n    }\n    return currentDateProfile;\n}\nfunction initEventSources(calendarOptions, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null;\n    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    switch(action.type){\n        case \"ADD_EVENT_SOURCES\":\n            return addSources(eventSources, action.sources, activeRange, context);\n        case \"REMOVE_EVENT_SOURCE\":\n            return removeSource(eventSources, action.sourceId);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return fetchDirtySources(eventSources, activeRange, context);\n            }\n            return eventSources;\n        case \"FETCH_EVENT_SOURCES\":\n            return fetchSourcesByIds(eventSources, action.sourceIds ? (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n        case \"RECEIVE_EVENTS\":\n        case \"RECEIVE_EVENT_ERROR\":\n            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return {};\n        default:\n            return eventSources;\n    }\n}\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\nfunction computeEventSourcesLoading(eventSources) {\n    for(let sourceId in eventSources){\n        if (eventSources[sourceId].isFetching) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n    let hash = {};\n    for (let source of sources){\n        hash[source.sourceId] = source;\n    }\n    if (fetchRange) {\n        hash = fetchDirtySources(hash, fetchRange, context);\n    }\n    return Object.assign(Object.assign({}, eventSourceHash), hash);\n}\nfunction removeSource(eventSourceHash, sourceId) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSourceHash, (eventSource)=>eventSource.sourceId !== sourceId);\n}\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n    return fetchSourcesByIds(sourceHash, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(sourceHash, (eventSource)=>isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);\n}\nfunction isSourceDirty(eventSource, fetchRange, context) {\n    if (!doesSourceNeedRange(eventSource, context)) {\n        return !eventSource.latestFetchId;\n    }\n    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n    let nextSources = {};\n    for(let sourceId in prevSources){\n        let source = prevSources[sourceId];\n        if (sourceIdHash[sourceId]) {\n            nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n        } else {\n            nextSources[sourceId] = source;\n        }\n    }\n    return nextSources;\n}\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n    let { options, calendarApi } = context;\n    let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n    let fetchId = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)();\n    sourceDef.fetch({\n        eventSource,\n        range: fetchRange,\n        isRefetch,\n        context\n    }, (res)=>{\n        let { rawEvents } = res;\n        if (options.eventSourceSuccess) {\n            rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        if (eventSource.success) {\n            rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENTS\",\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            rawEvents\n        });\n    }, (error)=>{\n        let errorHandled = false;\n        if (options.eventSourceFailure) {\n            options.eventSourceFailure.call(calendarApi, error);\n            errorHandled = true;\n        }\n        if (eventSource.failure) {\n            eventSource.failure(error);\n            errorHandled = true;\n        }\n        if (!errorHandled) {\n            console.warn(error.message, error);\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENT_ERROR\",\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            error\n        });\n    });\n    return Object.assign(Object.assign({}, eventSource), {\n        isFetching: true,\n        latestFetchId: fetchId\n    });\n}\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n    let eventSource = sourceHash[sourceId];\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId) {\n        return Object.assign(Object.assign({}, sourceHash), {\n            [sourceId]: Object.assign(Object.assign({}, eventSource), {\n                isFetching: false,\n                fetchRange\n            })\n        });\n    }\n    return sourceHash;\n}\nfunction excludeStaticSources(eventSources, context) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSources, (eventSource)=>doesSourceNeedRange(eventSource, context));\n}\nfunction parseInitialSources(rawOptions, context) {\n    let refiners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.j)(context);\n    let rawSources = [].concat(rawOptions.eventSources || []);\n    let sources = []; // parsed\n    if (rawOptions.initialEvents) {\n        rawSources.unshift(rawOptions.initialEvents);\n    }\n    if (rawOptions.events) {\n        rawSources.unshift(rawOptions.events);\n    }\n    for (let rawSource of rawSources){\n        let source = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.p)(rawSource, context, refiners);\n        if (source) {\n            sources.push(source);\n        }\n    }\n    return sources;\n}\nfunction doesSourceNeedRange(eventSource, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    return !defs[eventSource.sourceDefId].ignoreRange;\n}\nfunction reduceDateSelection(currentSelection, action) {\n    switch(action.type){\n        case \"UNSELECT_DATES\":\n            return null;\n        case \"SELECT_DATES\":\n            return action.selection;\n        default:\n            return currentSelection;\n    }\n}\nfunction reduceSelectedEvent(currentInstanceId, action) {\n    switch(action.type){\n        case \"UNSELECT_EVENT\":\n            return \"\";\n        case \"SELECT_EVENT\":\n            return action.eventInstanceId;\n        default:\n            return currentInstanceId;\n    }\n}\nfunction reduceEventDrag(currentDrag, action) {\n    let newDrag;\n    switch(action.type){\n        case \"UNSET_EVENT_DRAG\":\n            return null;\n        case \"SET_EVENT_DRAG\":\n            newDrag = action.state;\n            return {\n                affectedEvents: newDrag.affectedEvents,\n                mutatedEvents: newDrag.mutatedEvents,\n                isEvent: newDrag.isEvent\n            };\n        default:\n            return currentDrag;\n    }\n}\nfunction reduceEventResize(currentResize, action) {\n    let newResize;\n    switch(action.type){\n        case \"UNSET_EVENT_RESIZE\":\n            return null;\n        case \"SET_EVENT_RESIZE\":\n            newResize = action.state;\n            return {\n                affectedEvents: newResize.affectedEvents,\n                mutatedEvents: newResize.mutatedEvents,\n                isEvent: newResize.isEvent\n            };\n        default:\n            return currentResize;\n    }\n}\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    return {\n        header,\n        footer\n    };\n}\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let sectionWidgets = {};\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    for(let sectionName in sectionStrHash){\n        let sectionStr = sectionStrHash[sectionName];\n        let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n        sectionWidgets[sectionName] = sectionRes.widgets;\n        viewsWithButtons.push(...sectionRes.viewsWithButtons);\n        hasTitle = hasTitle || sectionRes.hasTitle;\n    }\n    return {\n        sectionWidgets,\n        viewsWithButtons,\n        hasTitle\n    };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let isRtl = calendarOptions.direction === \"rtl\";\n    let calendarCustomButtons = calendarOptions.customButtons || {};\n    let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n    let calendarButtonText = calendarOptions.buttonText || {};\n    let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n    let calendarButtonHints = calendarOptions.buttonHints || {};\n    let sectionSubstrs = sectionStr ? sectionStr.split(\" \") : [];\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    let widgets = sectionSubstrs.map((buttonGroupStr)=>buttonGroupStr.split(\",\").map((buttonName)=>{\n            if (buttonName === \"title\") {\n                hasTitle = true;\n                return {\n                    buttonName\n                };\n            }\n            let customButtonProps;\n            let viewSpec;\n            let buttonClick;\n            let buttonIcon; // only one of these will be set\n            let buttonText; // \"\n            let buttonHint;\n            // ^ for the title=\"\" attribute, for accessibility\n            if (customButtonProps = calendarCustomButtons[buttonName]) {\n                buttonClick = (ev)=>{\n                    if (customButtonProps.click) {\n                        customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                    }\n                };\n                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                buttonHint = customButtonProps.hint || customButtonProps.text;\n            } else if (viewSpec = viewSpecs[buttonName]) {\n                viewsWithButtons.push(buttonName);\n                buttonClick = ()=>{\n                    calendarApi.changeView(buttonName);\n                };\n                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                    textFallback,\n                    buttonName\n                ], textFallback);\n            } else if (calendarApi[buttonName]) {\n                buttonClick = ()=>{\n                    calendarApi[buttonName]();\n                };\n                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                if (buttonName === \"prevYear\" || buttonName === \"nextYear\") {\n                    let prevOrNext = buttonName === \"prevYear\" ? \"prev\" : \"next\";\n                    buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                        calendarButtonText.year || \"year\",\n                        \"year\"\n                    ], calendarButtonText[buttonName]);\n                } else {\n                    buttonHint = (navUnit)=>(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                            calendarButtonText[navUnit] || navUnit,\n                            navUnit\n                        ], calendarButtonText[buttonName]);\n                }\n            }\n            return {\n                buttonName,\n                buttonClick,\n                buttonIcon,\n                buttonText,\n                buttonHint\n            };\n        }));\n    return {\n        widgets,\n        viewsWithButtons,\n        hasTitle\n    };\n}\n// always represents the current view. otherwise, it'd need to change value every time date changes\nclass ViewImpl {\n    constructor(type, getCurrentData, dateEnv){\n        this.type = type;\n        this.getCurrentData = getCurrentData;\n        this.dateEnv = dateEnv;\n    }\n    get calendar() {\n        return this.getCurrentData().calendarApi;\n    }\n    get title() {\n        return this.getCurrentData().viewTitle;\n    }\n    get activeStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    }\n    get activeEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    }\n    get currentStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    }\n    get currentEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    }\n    getOption(name) {\n        return this.getCurrentData().options[name]; // are the view-specific options\n    }\n}\nlet eventSourceDef$2 = {\n    ignoreRange: true,\n    parseMeta (refined) {\n        if (Array.isArray(refined.events)) {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch (arg, successCallback) {\n        successCallback({\n            rawEvents: arg.eventSource.meta\n        });\n    }\n};\nconst arrayEventSourcePlugin = createPlugin({\n    name: \"array-event-source\",\n    eventSourceDefs: [\n        eventSourceDef$2\n    ]\n});\nlet eventSourceDef$1 = {\n    parseMeta (refined) {\n        if (typeof refined.events === \"function\") {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch (arg, successCallback, errorCallback) {\n        const { dateEnv } = arg.context;\n        const func = arg.eventSource.meta;\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.u)(func.bind(null, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(arg.range, dateEnv)), (rawEvents)=>successCallback({\n                rawEvents\n            }), errorCallback);\n    }\n};\nconst funcEventSourcePlugin = createPlugin({\n    name: \"func-event-source\",\n    eventSourceDefs: [\n        eventSourceDef$1\n    ]\n});\nconst JSON_FEED_EVENT_SOURCE_REFINERS = {\n    method: String,\n    extraParams: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String\n};\nlet eventSourceDef = {\n    parseMeta (refined) {\n        if (refined.url && (refined.format === \"json\" || !refined.format)) {\n            return {\n                url: refined.url,\n                format: \"json\",\n                method: (refined.method || \"GET\").toUpperCase(),\n                extraParams: refined.extraParams,\n                startParam: refined.startParam,\n                endParam: refined.endParam,\n                timeZoneParam: refined.timeZoneParam\n            };\n        }\n        return null;\n    },\n    fetch (arg, successCallback, errorCallback) {\n        const { meta } = arg.eventSource;\n        const requestParams = buildRequestParams(meta, arg.range, arg.context);\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.r)(meta.method, meta.url, requestParams).then(([rawEvents, response])=>{\n            successCallback({\n                rawEvents,\n                response\n            });\n        }, errorCallback);\n    }\n};\nconst jsonFeedEventSourcePlugin = createPlugin({\n    name: \"json-event-source\",\n    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n    eventSourceDefs: [\n        eventSourceDef\n    ]\n});\nfunction buildRequestParams(meta, range, context) {\n    let { dateEnv, options } = context;\n    let startParam;\n    let endParam;\n    let timeZoneParam;\n    let customRequestParams;\n    let params = {};\n    startParam = meta.startParam;\n    if (startParam == null) {\n        startParam = options.startParam;\n    }\n    endParam = meta.endParam;\n    if (endParam == null) {\n        endParam = options.endParam;\n    }\n    timeZoneParam = meta.timeZoneParam;\n    if (timeZoneParam == null) {\n        timeZoneParam = options.timeZoneParam;\n    }\n    // retrieve any outbound GET/POST data from the options\n    if (typeof meta.extraParams === \"function\") {\n        // supplied as a function that returns a key/value object\n        customRequestParams = meta.extraParams();\n    } else {\n        // probably supplied as a straight key/value object\n        customRequestParams = meta.extraParams || {};\n    }\n    Object.assign(params, customRequestParams);\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n    if (dateEnv.timeZone !== \"local\") {\n        params[timeZoneParam] = dateEnv.timeZone;\n    }\n    return params;\n}\nconst SIMPLE_RECURRING_REFINERS = {\n    daysOfWeek: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    endTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    duration: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    startRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    endRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n\n};\nlet recurring = {\n    parse (refined, dateEnv) {\n        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n            let recurringData = {\n                daysOfWeek: refined.daysOfWeek || null,\n                startTime: refined.startTime || null,\n                endTime: refined.endTime || null,\n                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null,\n                dateEnv\n            };\n            let duration;\n            if (refined.duration) {\n                duration = refined.duration;\n            }\n            if (!duration && refined.startTime && refined.endTime) {\n                duration = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.s)(refined.endTime, refined.startTime);\n            }\n            return {\n                allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                duration,\n                typeData: recurringData\n            };\n        }\n        return null;\n    },\n    expand (typeData, framingRange, dateEnv) {\n        let clippedFramingRange = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.o)(framingRange, {\n            start: typeData.startRecur,\n            end: typeData.endRecur\n        });\n        if (clippedFramingRange) {\n            return expandRanges(typeData.daysOfWeek, typeData.startTime, typeData.dateEnv, dateEnv, clippedFramingRange);\n        }\n        return [];\n    }\n};\nconst simpleRecurringEventsPlugin = createPlugin({\n    name: \"simple-recurring-event\",\n    recurringTypes: [\n        recurring\n    ],\n    eventRefiners: SIMPLE_RECURRING_REFINERS\n});\nfunction expandRanges(daysOfWeek, startTime, eventDateEnv, calendarDateEnv, framingRange) {\n    let dowHash = daysOfWeek ? (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(daysOfWeek) : null;\n    let dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.q)(framingRange.start);\n    let endMarker = framingRange.end;\n    let instanceStarts = [];\n    while(dayMarker < endMarker){\n        let instanceStart;\n        // if everyday, or this particular day-of-week\n        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n            if (startTime) {\n                instanceStart = calendarDateEnv.add(dayMarker, startTime);\n            } else {\n                instanceStart = dayMarker;\n            }\n            instanceStarts.push(calendarDateEnv.createMarker(eventDateEnv.toDate(instanceStart)));\n        }\n        dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.t)(dayMarker, 1);\n    }\n    return instanceStarts;\n}\nconst changeHandlerPlugin = createPlugin({\n    name: \"change-handler\",\n    optionChangeHandlers: {\n        events (events, context) {\n            handleEventSources([\n                events\n            ], context);\n        },\n        eventSources: handleEventSources\n    }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/ function handleEventSources(inputs, context) {\n    let unfoundSources = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.v)(context.getCurrentData().eventSources);\n    if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {\n        context.dispatch({\n            type: \"RESET_RAW_EVENTS\",\n            sourceId: unfoundSources[0].sourceId,\n            rawEvents: inputs[0]\n        });\n        return;\n    }\n    let newInputs = [];\n    for (let input of inputs){\n        let inputFound = false;\n        for(let i = 0; i < unfoundSources.length; i += 1){\n            if (unfoundSources[i]._raw === input) {\n                unfoundSources.splice(i, 1); // delete\n                inputFound = true;\n                break;\n            }\n        }\n        if (!inputFound) {\n            newInputs.push(input);\n        }\n    }\n    for (let unfoundSource of unfoundSources){\n        context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: unfoundSource.sourceId\n        });\n    }\n    for (let newInput of newInputs){\n        context.calendarApi.addEventSource(newInput);\n    }\n}\nfunction handleDateProfile(dateProfile, context) {\n    context.emitter.trigger(\"datesSet\", Object.assign(Object.assign({}, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(dateProfile.activeRange, context.dateEnv)), {\n        view: context.viewApi\n    }));\n}\nfunction handleEventStore(eventStore, context) {\n    let { emitter } = context;\n    if (emitter.hasHandlers(\"eventsSet\")) {\n        emitter.trigger(\"eventsSet\", (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.w)(eventStore, context));\n    }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/ const globalPlugins = [\n    arrayEventSourcePlugin,\n    funcEventSourcePlugin,\n    jsonFeedEventSourcePlugin,\n    simpleRecurringEventsPlugin,\n    changeHandlerPlugin,\n    createPlugin({\n        name: \"misc\",\n        isLoadingFuncs: [\n            (state)=>computeEventSourcesLoading(state.eventSources)\n        ],\n        propSetHandlers: {\n            dateProfile: handleDateProfile,\n            eventStore: handleEventStore\n        }\n    })\n];\nclass TaskRunner {\n    constructor(runTaskOption, drainedOption){\n        this.runTaskOption = runTaskOption;\n        this.drainedOption = drainedOption;\n        this.queue = [];\n        this.delayedRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.drain.bind(this));\n    }\n    request(task, delay) {\n        this.queue.push(task);\n        this.delayedRunner.request(delay);\n    }\n    pause(scope) {\n        this.delayedRunner.pause(scope);\n    }\n    resume(scope, force) {\n        this.delayedRunner.resume(scope, force);\n    }\n    drain() {\n        let { queue } = this;\n        while(queue.length){\n            let completedTasks = [];\n            let task;\n            while(task = queue.shift()){\n                this.runTask(task);\n                completedTasks.push(task);\n            }\n            this.drained(completedTasks);\n        } // keep going, in case new tasks were added in the drained handler\n    }\n    runTask(task) {\n        if (this.runTaskOption) {\n            this.runTaskOption(task);\n        }\n    }\n    drained(completedTasks) {\n        if (this.drainedOption) {\n            this.drainedOption(completedTasks);\n        }\n    }\n}\n// Computes what the title at the top of the calendarApi should be for this view\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n    let range;\n    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n        range = dateProfile.currentRange;\n    } else {\n        range = dateProfile.activeRange;\n    }\n    return dateEnv.formatRange(range.start, range.end, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n        isEndExclusive: dateProfile.isRangeAllDay,\n        defaultSeparator: viewOptions.titleRangeSeparator\n    });\n}\n// Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\nfunction buildTitleFormat(dateProfile) {\n    let { currentRangeUnit } = dateProfile;\n    if (currentRangeUnit === \"year\") {\n        return {\n            year: \"numeric\"\n        };\n    }\n    if (currentRangeUnit === \"month\") {\n        return {\n            year: \"numeric\",\n            month: \"long\"\n        }; // like \"September 2014\"\n    }\n    let days = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.y)(dateProfile.currentRange.start, dateProfile.currentRange.end);\n    if (days !== null && days > 1) {\n        // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n        return {\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\"\n        };\n    }\n    // one day. longer, like \"September 9 2014\"\n    return {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    };\n}\n/*\nTODO: test switching timezones when NO timezone plugin\n*/ class CalendarNowManager {\n    constructor(){\n        this.resetListeners = new Set();\n    }\n    handleInput(dateEnv, nowInput) {\n        const oldDateEnv = this.dateEnv;\n        if (dateEnv !== oldDateEnv) {\n            if (typeof nowInput === \"function\") {\n                this.nowFn = nowInput;\n            } else if (!oldDateEnv) {\n                this.nowAnchorDate = dateEnv.toDate(nowInput ? dateEnv.createMarker(nowInput) : dateEnv.createNowMarker());\n                this.nowAnchorQueried = Date.now();\n            }\n            this.dateEnv = dateEnv;\n            // not first time? fire reset handlers\n            if (oldDateEnv) {\n                for (const resetListener of this.resetListeners.values()){\n                    resetListener();\n                }\n            }\n        }\n    }\n    getDateMarker() {\n        return this.nowAnchorDate ? this.dateEnv.timestampToMarker(this.nowAnchorDate.valueOf() + (Date.now() - this.nowAnchorQueried)) : this.dateEnv.createMarker(this.nowFn());\n    }\n    addResetListener(handler) {\n        this.resetListeners.add(handler);\n    }\n    removeResetListener(handler) {\n        this.resetListeners.delete(handler);\n    }\n}\n// in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\nclass CalendarDataManager {\n    constructor(props){\n        this.computeCurrentViewData = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(this._computeCurrentViewData);\n        this.organizeRawLocales = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(organizeRawLocales);\n        this.buildLocale = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildLocale);\n        this.buildPluginHooks = buildBuildPluginHooks();\n        this.buildDateEnv = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDateEnv$1);\n        this.buildTheme = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTheme);\n        this.parseToolbars = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(parseToolbars);\n        this.buildViewSpecs = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewSpecs);\n        this.buildDateProfileGenerator = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildDateProfileGenerator);\n        this.buildViewApi = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewApi);\n        this.buildViewUiProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildViewUiProps);\n        this.buildEventUiBySource = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBySource, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.E);\n        this.buildEventUiBases = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBases);\n        this.parseContextBusinessHours = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(parseContextBusinessHours);\n        this.buildTitle = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTitle);\n        this.nowManager = new CalendarNowManager();\n        this.emitter = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.F();\n        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n        this.currentCalendarOptionsInput = {};\n        this.currentCalendarOptionsRefined = {};\n        this.currentViewOptionsInput = {};\n        this.currentViewOptionsRefined = {};\n        this.currentCalendarOptionsRefiners = {};\n        this.optionsForRefining = [];\n        this.optionsForHandling = [];\n        this.getCurrentData = ()=>this.data;\n        this.dispatch = (action)=>{\n            this.actionRunner.request(action); // protects against recursive calls to _handleAction\n        };\n        this.props = props;\n        this.actionRunner.pause();\n        this.nowManager = new CalendarNowManager();\n        let dynamicOptionOverrides = {};\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        this.emitter.setThisContext(props.calendarApi);\n        this.emitter.setOptions(currentViewData.options);\n        let calendarContext = {\n            nowManager: this.nowManager,\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        };\n        let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv, this.nowManager);\n        let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.G)(dateProfile.activeRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        // needs to be after setThisContext\n        for (let callback of optionsData.pluginHooks.contextInit){\n            callback(calendarContext);\n        }\n        // NOT DRY\n        let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n        let initialState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            eventSources,\n            eventUiBases: {},\n            eventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(),\n            renderableEventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(),\n            dateSelection: null,\n            eventSelection: \"\",\n            eventDrag: null,\n            eventResize: null,\n            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);\n        for (let reducer of optionsData.pluginHooks.reducers){\n            Object.assign(initialState, reducer(null, null, contextAndState));\n        }\n        if (computeIsLoading(initialState, calendarContext)) {\n            this.emitter.trigger(\"loading\", true); // NOT DRY\n        }\n        this.state = initialState;\n        this.updateData();\n        this.actionRunner.resume();\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        let { props } = this;\n        if (changedOptionNames === undefined) {\n            props.optionOverrides = optionOverrides;\n        } else {\n            props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);\n            this.optionsForRefining.push(...changedOptionNames);\n        }\n        if (changedOptionNames === undefined || changedOptionNames.length) {\n            this.actionRunner.request({\n                type: \"NOTHING\"\n            });\n        }\n    }\n    _handleAction(action) {\n        let { props, state, emitter } = this;\n        let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = reduceViewType(state.currentViewType, action);\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        emitter.setThisContext(props.calendarApi);\n        emitter.setOptions(currentViewData.options);\n        let calendarContext = {\n            nowManager: this.nowManager,\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter,\n            getCurrentData: this.getCurrentData\n        };\n        let { currentDate, dateProfile } = state;\n        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n            dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        }\n        currentDate = reduceCurrentDate(currentDate, action);\n        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n        if (action.type === \"PREV\" || // TODO: move this logic into DateProfileGenerator\n        action.type === \"NEXT\" || // \"\n        !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.G)(dateProfile.currentRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n        let eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.I)(state.eventStore, action, eventSources, dateProfile, calendarContext);\n        let isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n        let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n        let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext); // will memoize obj\n        let eventUiBySource = this.buildEventUiBySource(eventSources);\n        let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n        let newState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            eventSources,\n            eventStore,\n            renderableEventStore,\n            selectionConfig,\n            eventUiBases,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            dateSelection: reduceDateSelection(state.dateSelection, action),\n            eventSelection: reduceSelectedEvent(state.eventSelection, action),\n            eventDrag: reduceEventDrag(state.eventDrag, action),\n            eventResize: reduceEventResize(state.eventResize, action)\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);\n        for (let reducer of optionsData.pluginHooks.reducers){\n            Object.assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n        }\n        let wasLoading = computeIsLoading(state, calendarContext);\n        let isLoading = computeIsLoading(newState, calendarContext);\n        // TODO: use propSetHandlers in plugin system\n        if (!wasLoading && isLoading) {\n            emitter.trigger(\"loading\", true);\n        } else if (wasLoading && !isLoading) {\n            emitter.trigger(\"loading\", false);\n        }\n        this.state = newState;\n        if (props.onAction) {\n            props.onAction(action);\n        }\n    }\n    updateData() {\n        let { props, state } = this;\n        let oldData = this.data;\n        let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n        let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n        let data = this.data = Object.assign(Object.assign(Object.assign({\n            nowManager: this.nowManager,\n            viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        }, optionsData), currentViewData), state);\n        let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n        let oldCalendarOptions = oldData && oldData.calendarOptions;\n        let newCalendarOptions = optionsData.calendarOptions;\n        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                // hack\n                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                state.eventStore = data.eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.J)(data.eventStore, oldData.dateEnv, data.dateEnv);\n                state.renderableEventStore = data.renderableEventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.J)(data.renderableEventStore, oldData.dateEnv, data.dateEnv);\n            }\n            for(let optionName in changeHandlers){\n                if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                    changeHandlers[optionName](newCalendarOptions[optionName], data);\n                }\n            }\n        }\n        this.optionsForHandling = [];\n        if (props.onData) {\n            props.onData(data);\n        }\n    }\n    computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {\n        // TODO: blacklist options that are handled by optionChangeHandlers\n        if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {\n            return this.stableCalendarOptionsData;\n        }\n        let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n        let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);\n        let theme = this.buildTheme(refinedOptions, pluginHooks);\n        let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);\n        return this.stableCalendarOptionsData = {\n            calendarOptions: refinedOptions,\n            pluginHooks,\n            dateEnv,\n            viewSpecs,\n            theme,\n            toolbarConfig,\n            localeDefaults,\n            availableRawLocales: availableLocaleData.map\n        };\n    }\n    // always called from behind a memoizer\n    processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {\n        let { locales, locale } = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.K)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let availableLocaleData = this.organizeRawLocales(locales);\n        let availableRawLocales = availableLocaleData.map;\n        let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n        let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n        let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let extra = {};\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.K)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            localeDefaults,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let refined = {};\n        let currentRaw = this.currentCalendarOptionsInput;\n        let currentRefined = this.currentCalendarOptionsRefined;\n        let anyChanges = false;\n        for(let optionName in raw){\n            if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O[optionName] && optionName in currentRaw && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O[optionName](currentRaw[optionName], raw[optionName]))) {\n                refined[optionName] = currentRefined[optionName];\n            } else if (refiners[optionName]) {\n                refined[optionName] = refiners[optionName](raw[optionName]);\n                anyChanges = true;\n            } else {\n                extra[optionName] = currentRaw[optionName];\n            }\n        }\n        if (anyChanges) {\n            this.currentCalendarOptionsInput = raw;\n            this.currentCalendarOptionsRefined = refined;\n            this.stableOptionOverrides = optionOverrides;\n            this.stableDynamicOptionOverrides = dynamicOptionOverrides;\n        }\n        this.optionsForHandling.push(...this.optionsForRefining);\n        this.optionsForRefining = [];\n        return {\n            rawOptions: this.currentCalendarOptionsInput,\n            refinedOptions: this.currentCalendarOptionsRefined,\n            pluginHooks,\n            availableLocaleData,\n            localeDefaults,\n            extra\n        };\n    }\n    _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n        let viewSpec = optionsData.viewSpecs[viewType];\n        if (!viewSpec) {\n            throw new Error(`viewType \"${viewType}\" is not available. Please make sure you've loaded all neccessary plugins`);\n        }\n        let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        this.nowManager.handleInput(optionsData.dateEnv, refinedOptions.now);\n        let dateProfileGenerator = this.buildDateProfileGenerator({\n            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n            nowManager: this.nowManager,\n            duration: viewSpec.duration,\n            durationUnit: viewSpec.durationUnit,\n            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n            dateEnv: optionsData.dateEnv,\n            calendarApi: this.props.calendarApi,\n            slotMinTime: refinedOptions.slotMinTime,\n            slotMaxTime: refinedOptions.slotMaxTime,\n            showNonCurrentDates: refinedOptions.showNonCurrentDates,\n            dayCount: refinedOptions.dayCount,\n            dateAlignment: refinedOptions.dateAlignment,\n            dateIncrement: refinedOptions.dateIncrement,\n            hiddenDays: refinedOptions.hiddenDays,\n            weekends: refinedOptions.weekends,\n            validRangeInput: refinedOptions.validRange,\n            visibleRangeInput: refinedOptions.visibleRange,\n            fixedWeekCount: refinedOptions.fixedWeekCount\n        });\n        let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n        return {\n            viewSpec,\n            options: refinedOptions,\n            dateProfileGenerator,\n            viewApi\n        };\n    }\n    processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.K)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            viewSpec.optionDefaults,\n            localeDefaults,\n            optionOverrides,\n            viewSpec.optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.P), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let refined = {};\n        let currentRaw = this.currentViewOptionsInput;\n        let currentRefined = this.currentViewOptionsRefined;\n        let anyChanges = false;\n        let extra = {};\n        for(let optionName in raw){\n            if (raw[optionName] === currentRaw[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O[optionName] && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O[optionName](raw[optionName], currentRaw[optionName])) {\n                refined[optionName] = currentRefined[optionName];\n            } else {\n                if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O[optionName] && _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                    if (optionName in this.currentCalendarOptionsRefined) {\n                        refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                    }\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                } else {\n                    extra[optionName] = raw[optionName];\n                }\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            this.currentViewOptionsInput = raw;\n            this.currentViewOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentViewOptionsInput,\n            refinedOptions: this.currentViewOptionsRefined,\n            extra\n        };\n    }\n}\nfunction buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n    let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q({\n        calendarSystem: \"gregory\",\n        timeZone,\n        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n        locale,\n        weekNumberCalculation,\n        firstDay,\n        weekText,\n        cmdFormatter: pluginHooks.cmdFormatter,\n        defaultSeparator\n    });\n}\nfunction buildTheme(options, pluginHooks) {\n    let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n    return new ThemeClass(options);\n}\nfunction buildDateProfileGenerator(props) {\n    let DateProfileGeneratorClass = props.dateProfileGeneratorClass || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.R;\n    return new DateProfileGeneratorClass(props);\n}\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n    return new ViewImpl(type, getCurrentData, dateEnv);\n}\nfunction buildEventUiBySource(eventSources) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(eventSources, (eventSource)=>eventSource.ui);\n}\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n    let eventUiBases = {\n        \"\": eventUiSingleBase\n    };\n    for(let defId in eventDefs){\n        let def = eventDefs[defId];\n        if (def.sourceId && eventUiBySource[def.sourceId]) {\n            eventUiBases[defId] = eventUiBySource[def.sourceId];\n        }\n    }\n    return eventUiBases;\n}\nfunction buildViewUiProps(calendarContext) {\n    let { options } = calendarContext;\n    return {\n        eventUiSingleBase: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S)({\n            display: options.eventDisplay,\n            editable: options.editable,\n            startEditable: options.eventStartEditable,\n            durationEditable: options.eventDurationEditable,\n            constraint: options.eventConstraint,\n            overlap: typeof options.eventOverlap === \"boolean\" ? options.eventOverlap : undefined,\n            allow: options.eventAllow,\n            backgroundColor: options.eventBackgroundColor,\n            borderColor: options.eventBorderColor,\n            textColor: options.eventTextColor,\n            color: options.eventColor\n        }, calendarContext),\n        selectionConfig: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S)({\n            constraint: options.selectConstraint,\n            overlap: typeof options.selectOverlap === \"boolean\" ? options.selectOverlap : undefined,\n            allow: options.selectAllow\n        }, calendarContext)\n    };\n}\nfunction computeIsLoading(state, context) {\n    for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs){\n        if (isLoadingFunc(state)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseContextBusinessHours(calendarContext) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.U)(calendarContext.options.businessHours, calendarContext);\n}\nfunction warnUnknownOptions(options, viewName) {\n    for(let optionName in options){\n        console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : \"\"));\n    }\n}\nclass ToolbarSection extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let children = this.props.widgetGroups.map((widgetGroup)=>this.renderWidgetGroup(widgetGroup));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-toolbar-chunk\"\n        }, ...children);\n    }\n    renderWidgetGroup(widgetGroup) {\n        let { props } = this;\n        let { theme } = this.context;\n        let children = [];\n        let isOnlyButtons = true;\n        for (let widget of widgetGroup){\n            let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;\n            if (buttonName === \"title\") {\n                isOnlyButtons = false;\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"h2\", {\n                    className: \"fc-toolbar-title\",\n                    id: props.titleId\n                }, props.title));\n            } else {\n                let isPressed = buttonName === props.activeButton;\n                let isDisabled = !props.isTodayEnabled && buttonName === \"today\" || !props.isPrevEnabled && buttonName === \"prev\" || !props.isNextEnabled && buttonName === \"next\";\n                let buttonClasses = [\n                    `fc-${buttonName}-button`,\n                    theme.getClass(\"button\")\n                ];\n                if (isPressed) {\n                    buttonClasses.push(theme.getClass(\"buttonActive\"));\n                }\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"button\", {\n                    type: \"button\",\n                    title: typeof buttonHint === \"function\" ? buttonHint(props.navUnit) : buttonHint,\n                    disabled: isDisabled,\n                    \"aria-pressed\": isPressed,\n                    className: buttonClasses.join(\" \"),\n                    onClick: buttonClick\n                }, buttonText || (buttonIcon ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n                    className: buttonIcon,\n                    role: \"img\"\n                }) : \"\")));\n            }\n        }\n        if (children.length > 1) {\n            let groupClassName = isOnlyButtons && theme.getClass(\"buttonGroup\") || \"\";\n            return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: groupClassName\n            }, ...children);\n        }\n        return children[0];\n    }\n}\nclass Toolbar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { model, extraClassName } = this.props;\n        let forceLtr = false;\n        let startContent;\n        let endContent;\n        let sectionWidgets = model.sectionWidgets;\n        let centerContent = sectionWidgets.center;\n        if (sectionWidgets.left) {\n            forceLtr = true;\n            startContent = sectionWidgets.left;\n        } else {\n            startContent = sectionWidgets.start;\n        }\n        if (sectionWidgets.right) {\n            forceLtr = true;\n            endContent = sectionWidgets.right;\n        } else {\n            endContent = sectionWidgets.end;\n        }\n        let classNames = [\n            extraClassName || \"\",\n            \"fc-toolbar\",\n            forceLtr ? \"fc-toolbar-ltr\" : \"\"\n        ];\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: classNames.join(\" \")\n        }, this.renderSection(\"start\", startContent || []), this.renderSection(\"center\", centerContent || []), this.renderSection(\"end\", endContent || []));\n    }\n    renderSection(key, widgetGroups) {\n        let { props } = this;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ToolbarSection, {\n            key: key,\n            widgetGroups: widgetGroups,\n            title: props.title,\n            navUnit: props.navUnit,\n            activeButton: props.activeButton,\n            isTodayEnabled: props.isTodayEnabled,\n            isPrevEnabled: props.isPrevEnabled,\n            isNextEnabled: props.isNextEnabled,\n            titleId: props.titleId\n        });\n    }\n}\nclass ViewHarness extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            availableWidth: null\n        };\n        this.handleEl = (el)=>{\n            this.el = el;\n            (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.W)(this.props.elRef, el);\n            this.updateAvailableWidth();\n        };\n        this.handleResize = ()=>{\n            this.updateAvailableWidth();\n        };\n    }\n    render() {\n        let { props, state } = this;\n        let { aspectRatio } = props;\n        let classNames = [\n            \"fc-view-harness\",\n            aspectRatio || props.liquid || props.height ? \"fc-view-harness-active\" // harness controls the height\n             : \"fc-view-harness-passive\"\n        ];\n        let height = \"\";\n        let paddingBottom = \"\";\n        if (aspectRatio) {\n            if (state.availableWidth !== null) {\n                height = state.availableWidth / aspectRatio;\n            } else {\n                // while waiting to know availableWidth, we can't set height to *zero*\n                // because will cause lots of unnecessary scrollbars within scrollgrid.\n                // BETTER: don't start rendering ANYTHING yet until we know container width\n                // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                paddingBottom = `${1 / aspectRatio * 100}%`;\n            }\n        } else {\n            height = props.height || \"\";\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            \"aria-labelledby\": props.labeledById,\n            ref: this.handleEl,\n            className: classNames.join(\" \"),\n            style: {\n                height,\n                paddingBottom\n            }\n        }, props.children);\n    }\n    componentDidMount() {\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    updateAvailableWidth() {\n        if (this.el && // needed. but why?\n        this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n        ) {\n            this.setState({\n                availableWidth: this.el.offsetWidth\n            });\n        }\n    }\n}\n/*\nDetects when the user clicks on an event within a DateComponent\n*/ class EventClicking extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.X {\n    constructor(settings){\n        super(settings);\n        this.handleSegClick = (ev, segEl)=>{\n            let { component } = this;\n            let { context } = component;\n            let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Y)(segEl);\n            if (seg && // might be the <div> surrounding the more link\n            component.isValidSegDownEl(ev.target)) {\n                // our way to simulate a link click for elements that can't be <a> tags\n                // grab before trigger fired in case trigger trashes DOM thru rerendering\n                let hasUrlContainer = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ev.target, \".fc-event-forced-url\");\n                let url = hasUrlContainer ? hasUrlContainer.querySelector(\"a[href]\").href : \"\";\n                context.emitter.trigger(\"eventClick\", {\n                    el: segEl,\n                    event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__._(component.context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n                if (url && !ev.defaultPrevented) {\n                    window.location.href = url;\n                }\n            }\n        };\n        this.destroy = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.$)(settings.el, \"click\", \".fc-event\", this.handleSegClick);\n    }\n}\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/ class EventHovering extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.X {\n    constructor(settings){\n        super(settings);\n        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n        this.handleEventElRemove = (el)=>{\n            if (el === this.currentSegEl) {\n                this.handleSegLeave(null, this.currentSegEl);\n            }\n        };\n        this.handleSegEnter = (ev, segEl)=>{\n            if ((0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Y)(segEl)) {\n                this.currentSegEl = segEl;\n                this.triggerEvent(\"eventMouseEnter\", ev, segEl);\n            }\n        };\n        this.handleSegLeave = (ev, segEl)=>{\n            if (this.currentSegEl) {\n                this.currentSegEl = null;\n                this.triggerEvent(\"eventMouseLeave\", ev, segEl);\n            }\n        };\n        this.removeHoverListeners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a0)(settings.el, \".fc-event\", this.handleSegEnter, this.handleSegLeave);\n    }\n    destroy() {\n        this.removeHoverListeners();\n    }\n    triggerEvent(publicEvName, ev, segEl) {\n        let { component } = this;\n        let { context } = component;\n        let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Y)(segEl);\n        if (!ev || component.isValidSegDownEl(ev.target)) {\n            context.emitter.trigger(publicEvName, {\n                el: segEl,\n                event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__._(context, seg.eventRange.def, seg.eventRange.instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        }\n    }\n}\nclass CalendarContent extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a1 {\n    constructor(){\n        super(...arguments);\n        this.buildViewContext = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a2);\n        this.buildViewPropTransformers = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewPropTransformers);\n        this.buildToolbarProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildToolbarProps);\n        this.headerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.footerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.interactionsStore = {};\n        // eslint-disable-next-line\n        this.state = {\n            viewLabelId: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a3)()\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        this.registerInteractiveComponent = (component, settingsInput)=>{\n            let settings = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a4)(component, settingsInput);\n            let DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering\n            ];\n            let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);\n            let interactions = interactionClasses.map((TheInteractionClass)=>new TheInteractionClass(settings));\n            this.interactionsStore[component.uid] = interactions;\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a5[component.uid] = settings;\n        };\n        this.unregisterInteractiveComponent = (component)=>{\n            let listeners = this.interactionsStore[component.uid];\n            if (listeners) {\n                for (let listener of listeners){\n                    listener.destroy();\n                }\n                delete this.interactionsStore[component.uid];\n            }\n            delete _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a5[component.uid];\n        };\n        // Resizing\n        // -----------------------------------------------------------------------------------------------------------------\n        this.resizeRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(()=>{\n            this.props.emitter.trigger(\"_resize\", true); // should window resizes be considered \"forced\" ?\n            this.props.emitter.trigger(\"windowResize\", {\n                view: this.props.viewApi\n            });\n        });\n        this.handleWindowResize = (ev)=>{\n            let { options } = this.props;\n            if (options.handleWindowResize && ev.target === window // avoid jqui events\n            ) {\n                this.resizeRunner.request(options.windowResizeDelay);\n            }\n        };\n    }\n    /*\n    renders INSIDE of an outer div\n    */ render() {\n        let { props } = this;\n        let { toolbarConfig, options } = props;\n        let viewVGrow = false;\n        let viewHeight = \"\";\n        let viewAspectRatio;\n        if (props.isHeightAuto || props.forPrint) {\n            viewHeight = \"\";\n        } else if (options.height != null) {\n            viewVGrow = true;\n        } else if (options.contentHeight != null) {\n            viewHeight = options.contentHeight;\n        } else {\n            viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n        }\n        let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.nowManager, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n        let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : undefined;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Provider, {\n            value: viewContext\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a6, {\n            unit: \"day\"\n        }, (nowDate)=>{\n            let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, nowDate, props.viewTitle);\n            return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(preact__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, toolbarConfig.header && (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({\n                ref: this.headerRef,\n                extraClassName: \"fc-header-toolbar\",\n                model: toolbarConfig.header,\n                titleId: viewLabelId\n            }, toolbarProps)), (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewHarness, {\n                liquid: viewVGrow,\n                height: viewHeight,\n                aspectRatio: viewAspectRatio,\n                labeledById: viewLabelId\n            }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({\n                ref: this.footerRef,\n                extraClassName: \"fc-footer-toolbar\",\n                model: toolbarConfig.footer,\n                titleId: \"\"\n            }, toolbarProps)));\n        }));\n    }\n    componentDidMount() {\n        let { props } = this;\n        this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass)=>new CalendarInteractionClass(props));\n        window.addEventListener(\"resize\", this.handleWindowResize);\n        let { propSetHandlers } = props.pluginHooks;\n        for(let propName in propSetHandlers){\n            propSetHandlers[propName](props[propName], props);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        let { props } = this;\n        let { propSetHandlers } = props.pluginHooks;\n        for(let propName in propSetHandlers){\n            if (props[propName] !== prevProps[propName]) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n    }\n    componentWillUnmount() {\n        window.removeEventListener(\"resize\", this.handleWindowResize);\n        this.resizeRunner.clear();\n        for (let interaction of this.calendarInteractions){\n            interaction.destroy();\n        }\n        this.props.emitter.trigger(\"_unmount\");\n    }\n    buildAppendContent() {\n        let { props } = this;\n        let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent)=>buildAppendContent(props));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(preact__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...children);\n    }\n    renderView(props) {\n        let { pluginHooks } = props;\n        let { viewSpec } = props;\n        let viewProps = {\n            dateProfile: props.dateProfile,\n            businessHours: props.businessHours,\n            eventStore: props.renderableEventStore,\n            eventUiBases: props.eventUiBases,\n            dateSelection: props.dateSelection,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            isHeightAuto: props.isHeightAuto,\n            forPrint: props.forPrint\n        };\n        let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n        for (let transformer of transformers){\n            Object.assign(viewProps, transformer.transform(viewProps, props));\n        }\n        let ViewComponent = viewSpec.component;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewComponent, Object.assign({}, viewProps));\n    }\n}\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n    let todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n    let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n    let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n    return {\n        title,\n        activeButton: viewSpec.type,\n        navUnit: viewSpec.singleUnit,\n        isTodayEnabled: todayInfo.isValid && !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.G)(dateProfile.currentRange, now),\n        isPrevEnabled: prevInfo.isValid,\n        isNextEnabled: nextInfo.isValid\n    };\n}\n// Plugin\n// -----------------------------------------------------------------------------------------------------------------\nfunction buildViewPropTransformers(theClasses) {\n    return theClasses.map((TheClass)=>new TheClass());\n}\nclass Calendar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a7 {\n    constructor(el, optionOverrides = {}){\n        super();\n        this.isRendering = false;\n        this.isRendered = false;\n        this.currentClassNames = [];\n        this.customContentRenderId = 0;\n        this.handleAction = (action)=>{\n            // actions we know we want to render immediately\n            switch(action.type){\n                case \"SET_EVENT_DRAG\":\n                case \"SET_EVENT_RESIZE\":\n                    this.renderRunner.tryDrain();\n            }\n        };\n        this.handleData = (data)=>{\n            this.currentData = data;\n            this.renderRunner.request(data.calendarOptions.rerenderDelay);\n        };\n        this.handleRenderRequest = ()=>{\n            if (this.isRendering) {\n                this.isRendered = true;\n                let { currentData } = this;\n                (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a8)(()=>{\n                    (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a9, {\n                        options: currentData.calendarOptions,\n                        theme: currentData.theme,\n                        emitter: currentData.emitter\n                    }, (classNames, height, isHeightAuto, forPrint)=>{\n                        this.setClassNames(classNames);\n                        this.setHeight(height);\n                        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.aa.Provider, {\n                            value: this.customContentRenderId\n                        }, (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(CalendarContent, Object.assign({\n                            isHeightAuto: isHeightAuto,\n                            forPrint: forPrint\n                        }, currentData)));\n                    }), this.el);\n                });\n            } else if (this.isRendered) {\n                this.isRendered = false;\n                (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(null, this.el);\n                this.setClassNames([]);\n                this.setHeight(\"\");\n            }\n        };\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ab)(el);\n        this.el = el;\n        this.renderRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.handleRenderRequest);\n        new CalendarDataManager({\n            optionOverrides,\n            calendarApi: this,\n            onAction: this.handleAction,\n            onData: this.handleData\n        });\n    }\n    render() {\n        let wasRendering = this.isRendering;\n        if (!wasRendering) {\n            this.isRendering = true;\n        } else {\n            this.customContentRenderId += 1;\n        }\n        this.renderRunner.request();\n        if (wasRendering) {\n            this.updateSize();\n        }\n    }\n    destroy() {\n        if (this.isRendering) {\n            this.isRendering = false;\n            this.renderRunner.request();\n        }\n    }\n    updateSize() {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a8)(()=>{\n            super.updateSize();\n        });\n    }\n    batchRendering(func) {\n        this.renderRunner.pause(\"batchRendering\");\n        func();\n        this.renderRunner.resume(\"batchRendering\");\n    }\n    pauseRendering() {\n        this.renderRunner.pause(\"pauseRendering\");\n    }\n    resumeRendering() {\n        this.renderRunner.resume(\"pauseRendering\", true);\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);\n    }\n    setClassNames(classNames) {\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(classNames, this.currentClassNames)) {\n            let { classList } = this.el;\n            for (let className of this.currentClassNames){\n                classList.remove(className);\n            }\n            for (let className of classNames){\n                classList.add(className);\n            }\n            this.currentClassNames = classNames;\n        }\n    }\n    setHeight(height) {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ac)(this.el, \"height\", height);\n    }\n}\nfunction formatDate(dateInput, options = {}) {\n    let dateEnv = buildDateEnv(options);\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let dateMeta = dateEnv.createMarkerMeta(dateInput);\n    if (!dateMeta) {\n        return \"\";\n    }\n    return dateEnv.format(dateMeta.marker, formatter, {\n        forcedTzo: dateMeta.forcedTzo\n    });\n}\nfunction formatRange(startInput, endInput, options) {\n    let dateEnv = buildDateEnv(typeof options === \"object\" && options ? options : {}); // pass in if non-null object\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let startMeta = dateEnv.createMarkerMeta(startInput);\n    let endMeta = dateEnv.createMarkerMeta(endInput);\n    if (!startMeta || !endMeta) {\n        return \"\";\n    }\n    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n        forcedStartTzo: startMeta.forcedTzo,\n        forcedEndTzo: endMeta.forcedTzo,\n        isEndExclusive: options.isEndExclusive,\n        defaultSeparator: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.defaultRangeSeparator\n    });\n}\n// TODO: more DRY and optimized\nfunction buildDateEnv(settings) {\n    let locale = buildLocale(settings.locale || \"en\", organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q(Object.assign(Object.assign({\n        timeZone: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.timeZone,\n        calendarSystem: \"gregory\"\n    }, settings), {\n        locale\n    }));\n}\n// HELPERS\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/ function sliceEvents(props, allDay) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ad)(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\nconst version = \"6.1.17\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFvL0M7QUFDdDdDO0FBQ007QUFDN0M7QUFFdkIsTUFBTThJLGdCQUFnQixFQUFFO0FBRXhCLE1BQU1DLHdCQUF3QjtJQUMxQkMsTUFBTTtJQUNOQyxNQUFNO1FBQ0ZDLEtBQUs7UUFDTEMsS0FBSztJQUNUO0lBQ0FDLFdBQVc7SUFDWEMsWUFBWTtRQUNSQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BYLE1BQU07UUFDTlksS0FBSztRQUNMQyxNQUFNO0lBQ1Y7SUFDQUMsVUFBVTtJQUNWQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxjQUFjO0FBQ2xCO0FBQ0EsTUFBTUMsZ0JBQWdCQyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcxQix3QkFBd0I7SUFDMUUsMERBQTBEO0lBQzFELHNEQUFzRDtJQUN0RDJCLGFBQWE7UUFDVHBCLE1BQU07UUFDTkMsTUFBTTtRQUNOSSxPQUFNTixVQUFVLEVBQUVzQixJQUFJO1lBQ2xCLE9BQU8sU0FBVSxRQUNYLFVBQ0EsQ0FBQyxLQUFLLEVBQUV0QixXQUFXLENBQUM7UUFDOUI7SUFDSjtJQUFHdUIsVUFBVTtJQUFXQyxhQUFhO0lBQVlDLGNBQWFDLFFBQVE7UUFDbEUsT0FBTyxDQUFDLEtBQUssRUFBRUEsU0FBUyxXQUFXLEVBQUVBLGFBQWEsSUFBSSxLQUFLLElBQUksQ0FBQztJQUNwRTtBQUFFO0FBQ04sU0FBU0MsbUJBQW1CQyxrQkFBa0I7SUFDMUMsSUFBSUMsY0FBY0QsbUJBQW1CRSxNQUFNLEdBQUcsSUFBSUYsa0JBQWtCLENBQUMsRUFBRSxDQUFDakMsSUFBSSxHQUFHO0lBQy9F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O1FBQ3hCLE9BQU87SUFDWDtJQUNBLE9BQU9sakIsUUFBUXNQLFdBQVcsQ0FBQzJULFVBQVVKLE1BQU0sRUFBRUssUUFBUUwsTUFBTSxFQUFFSCxXQUFXO1FBQ3BFUyxnQkFBZ0JGLFVBQVVILFNBQVM7UUFDbkNNLGNBQWNGLFFBQVFKLFNBQVM7UUFDL0JyVCxnQkFBZ0J4WixRQUFRd1osY0FBYztRQUN0Q0Usa0JBQWtCbGxCLGtEQUFvQkEsQ0FBQytxQixxQkFBcUI7SUFDaEU7QUFDSjtBQUNBLCtCQUErQjtBQUMvQixTQUFTcEUsYUFBYXNMLFFBQVE7SUFDMUIsSUFBSXJILFNBQVN6Z0IsWUFBWThuQixTQUFTckgsTUFBTSxJQUFJLE1BQU1uaEIsbUJBQW1CLEVBQUUsRUFBRVMsR0FBRyxHQUFHLHVDQUF1QztJQUN0SCxPQUFPLElBQUloRyxrREFBT0EsQ0FBQytFLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDO1FBQUV3WCxVQUFVMWdCLGtEQUFvQkEsQ0FBQzBnQixRQUFRO1FBQUU4TCxnQkFBZ0I7SUFBVSxHQUFHeUYsV0FBVztRQUFFckg7SUFBTztBQUMvSTtBQUVBLFVBQVU7QUFDVjs7O0FBR0EsR0FDQSxTQUFTZ08sWUFBWXBTLEtBQUssRUFBRXFTLE1BQU07SUFDOUIsT0FBTzd4Qix1REFBZUEsQ0FBQ3dmLE1BQU1uRCxVQUFVLEVBQUVtRCxNQUFNa0MsWUFBWSxFQUFFbEMsTUFBTTlQLFdBQVcsQ0FBQ0MsV0FBVyxFQUFFa2lCLFNBQVNyUyxNQUFNOVQsZ0JBQWdCLEdBQUcsTUFBTW9tQixFQUFFO0FBQzFJO0FBRUEsTUFBTUMsVUFBVTtBQUUrRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYW5lci8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanM/YTY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtIGFzIG1lcmdlUHJvcHMsIGcgYXMgZ3VpZCwgaSBhcyBpc0FycmF5c0VxdWFsLCBUIGFzIFRoZW1lLCBhIGFzIG1hcEhhc2gsIEIgYXMgQmFzZUNvbXBvbmVudCwgViBhcyBWaWV3Q29udGV4dFR5cGUsIEMgYXMgQ29udGVudENvbnRhaW5lciwgYiBhcyBidWlsZFZpZXdDbGFzc05hbWVzLCBjIGFzIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciwgZCBhcyBjcmVhdGVEdXJhdGlvbiwgZSBhcyBCQVNFX09QVElPTl9ERUZBVUxUUywgZiBhcyBhcnJheVRvSGFzaCwgaCBhcyBmaWx0ZXJIYXNoLCBqIGFzIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycywgcCBhcyBwYXJzZUV2ZW50U291cmNlLCBrIGFzIGZvcm1hdFdpdGhPcmRpbmFscywgdSBhcyB1bnByb21pc2lmeSwgbCBhcyBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lLCBuIGFzIGlkZW50aXR5LCByIGFzIHJlcXVlc3RKc29uLCBzIGFzIHN1YnRyYWN0RHVyYXRpb25zLCBvIGFzIGludGVyc2VjdFJhbmdlcywgcSBhcyBzdGFydE9mRGF5LCB0IGFzIGFkZERheXMsIHYgYXMgaGFzaFZhbHVlc1RvQXJyYXksIHcgYXMgYnVpbGRFdmVudEFwaXMsIEQgYXMgRGVsYXllZFJ1bm5lciwgeCBhcyBjcmVhdGVGb3JtYXR0ZXIsIHkgYXMgZGlmZldob2xlRGF5cywgeiBhcyBtZW1vaXplLCBBIGFzIG1lbW9pemVPYmpBcmcsIEUgYXMgaXNQcm9wc0VxdWFsLCBGIGFzIEVtaXR0ZXIsIEcgYXMgcmFuZ2VDb250YWluc01hcmtlciwgSCBhcyBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIEkgYXMgcmVkdWNlRXZlbnRTdG9yZSwgSiBhcyByZXpvbmVFdmVudFN0b3JlRGF0ZXMsIEsgYXMgbWVyZ2VSYXdPcHRpb25zLCBMIGFzIEJBU0VfT1BUSU9OX1JFRklORVJTLCBNIGFzIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTLCBOIGFzIENBTEVOREFSX09QVElPTl9SRUZJTkVSUywgTyBhcyBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUywgUCBhcyBWSUVXX09QVElPTl9SRUZJTkVSUywgUSBhcyBEYXRlRW52LCBSIGFzIERhdGVQcm9maWxlR2VuZXJhdG9yLCBTIGFzIGNyZWF0ZUV2ZW50VWksIFUgYXMgcGFyc2VCdXNpbmVzc0hvdXJzLCBXIGFzIHNldFJlZiwgWCBhcyBJbnRlcmFjdGlvbiwgWSBhcyBnZXRFbFNlZywgWiBhcyBlbGVtZW50Q2xvc2VzdCwgXyBhcyBFdmVudEltcGwsICQgYXMgbGlzdGVuQnlTZWxlY3RvciwgYTAgYXMgbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IsIGExIGFzIFB1cmVDb21wb25lbnQsIGEyIGFzIGJ1aWxkVmlld0NvbnRleHQsIGEzIGFzIGdldFVuaXF1ZURvbUlkLCBhNCBhcyBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MsIGE1IGFzIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSwgYTYgYXMgTm93VGltZXIsIGE3IGFzIENhbGVuZGFySW1wbCwgYTggYXMgZmx1c2hTeW5jLCBhOSBhcyBDYWxlbmRhclJvb3QsIGFhIGFzIFJlbmRlcklkLCBhYiBhcyBlbnN1cmVFbEhhc1N0eWxlcywgYWMgYXMgYXBwbHlTdHlsZVByb3AsIGFkIGFzIHNsaWNlRXZlbnRTdG9yZSB9IGZyb20gJy4vaW50ZXJuYWwtY29tbW9uLmpzJztcbmV4cG9ydCB7IGFlIGFzIEpzb25SZXF1ZXN0RXJyb3IgfSBmcm9tICcuL2ludGVybmFsLWNvbW1vbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIEZyYWdtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICdwcmVhY3QvY29tcGF0JztcblxuY29uc3QgZ2xvYmFsTG9jYWxlcyA9IFtdO1xuXG5jb25zdCBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XG4gICAgY29kZTogJ2VuJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMCxcbiAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgIH0sXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdwcmV2JyxcbiAgICAgICAgbmV4dDogJ25leHQnLFxuICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgbGlzdDogJ2xpc3QnLFxuICAgIH0sXG4gICAgd2Vla1RleHQ6ICdXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcbiAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXG4gICAgdGltZUhpbnQ6ICdUaW1lJyxcbiAgICBldmVudEhpbnQ6ICdFdmVudCcsXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn07XG5jb25zdCBSQVdfRU5fTE9DQUxFID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxuICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcbiAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxuICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXG4gICAgICAgIHRvZGF5KGJ1dHRvblRleHQsIHVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgPyAnVG9kYXknXG4gICAgICAgICAgICAgICAgOiBgVGhpcyAke2J1dHRvblRleHR9YDtcbiAgICAgICAgfSxcbiAgICB9LCB2aWV3SGludDogJyQwIHZpZXcnLCBuYXZMaW5rSGludDogJ0dvIHRvICQwJywgbW9yZUxpbmtIaW50KGV2ZW50Q250KSB7XG4gICAgICAgIHJldHVybiBgU2hvdyAke2V2ZW50Q250fSBtb3JlIGV2ZW50JHtldmVudENudCA9PT0gMSA/ICcnIDogJ3MnfWA7XG4gICAgfSB9KTtcbmZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcbiAgICBsZXQgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcbiAgICBsZXQgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XG4gICAgbGV0IHJhd0xvY2FsZU1hcCA9IHtcbiAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXG4gICAgfTtcbiAgICBmb3IgKGxldCByYXdMb2NhbGUgb2YgYWxsUmF3TG9jYWxlcykge1xuICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcbiAgICAgICAgZGVmYXVsdENvZGUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGlucHV0U2luZ3VsYXIuY29kZSwgW2lucHV0U2luZ3VsYXIuY29kZV0sIGlucHV0U2luZ3VsYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmcsIGF2YWlsYWJsZSkge1xuICAgIGxldCBjb2RlcyA9IFtdLmNvbmNhdChjb2RlQXJnIHx8IFtdKTsgLy8gd2lsbCBjb252ZXJ0IHRvIGFycmF5XG4gICAgbGV0IHJhdyA9IHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHx8IFJBV19FTl9MT0NBTEU7XG4gICAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpO1xufVxuZnVuY3Rpb24gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gY29kZXNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuICAgICAgICBmb3IgKGxldCBqID0gcGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2ltcGxlSWQgPSBwYXJ0cy5zbGljZSgwLCBqKS5qb2luKCctJyk7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlW3NpbXBsZUlkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdykge1xuICAgIGxldCBtZXJnZWQgPSBtZXJnZVByb3BzKFtNSU5JTUFMX1JBV19FTl9MT0NBTEUsIHJhd10sIFsnYnV0dG9uVGV4dCddKTtcbiAgICBkZWxldGUgbWVyZ2VkLmNvZGU7IC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXG4gICAgbGV0IHsgd2VlayB9ID0gbWVyZ2VkO1xuICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlQXJnLFxuICAgICAgICBjb2RlcyxcbiAgICAgICAgd2VlayxcbiAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXG4gICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgICB9O1xufVxuXG4vLyBUT0RPOiBlYXNpZXIgd2F5IHRvIGFkZCBuZXcgaG9va3M/IG5lZWQgdG8gdXBkYXRlIGEgbWlsbGlvbiB0aGluZ3NcbmZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBndWlkKCksXG4gICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlID8gbmV3IERhdGUoaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVwczogaW5wdXQuZGVwcyB8fCBbXSxcbiAgICAgICAgcmVkdWNlcnM6IGlucHV0LnJlZHVjZXJzIHx8IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaW5wdXQuaXNMb2FkaW5nRnVuY3MgfHwgW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgICAgICBldmVudFJlZmluZXJzOiBpbnB1dC5ldmVudFJlZmluZXJzIHx8IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaW5wdXQuZXZlbnREZWZNZW1iZXJBZGRlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBpbnB1dC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaW5wdXQuZXZlbnREcm9wVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGlucHV0LmNvbXBvbmVudEludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IGlucHV0LnRoZW1lQ2xhc3NlcyB8fCB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBpbnB1dC5ldmVudFNvdXJjZURlZnMgfHwgW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaW5wdXQucmVjdXJyaW5nVHlwZXMgfHwgW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaW5wdXQubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGlucHV0LmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBpbnB1dC5vcHRpb25DaGFuZ2VIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IGlucHV0Lmxpc3RlbmVyUmVmaW5lcnMgfHwge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBpbnB1dC5wcm9wU2V0SGFuZGxlcnMgfHwge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGx1Z2luSG9va3MocGx1Z2luRGVmcywgZ2xvYmFsRGVmcykge1xuICAgIGxldCBjdXJyZW50UGx1Z2luSWRzID0ge307XG4gICAgbGV0IGhvb2tzID0ge1xuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVkdWNlcnM6IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczoge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczoge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdzOiB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBudWxsLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW10sXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBudWxsLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogbnVsbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBudWxsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge30sXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBudWxsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHt9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkRGVmcyhkZWZzKSB7XG4gICAgICAgIGZvciAobGV0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5OYW1lID0gZGVmLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SWQgPSBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBsdWdpbklkc1twbHVnaW5OYW1lXSA9IGRlZi5pZDtcbiAgICAgICAgICAgICAgICBhZGREZWZzKGRlZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGNvbWJpbmVIb29rcyhob29rcywgZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJZCAhPT0gZGVmLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IElEIHRoYW4gdGhlIG9uZSBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgcGx1Z2luICcke3BsdWdpbk5hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgICAgIGFkZERlZnMocGx1Z2luRGVmcyk7XG4gICAgfVxuICAgIGFkZERlZnMoZ2xvYmFsRGVmcyk7XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkge1xuICAgIGxldCBjdXJyZW50T3ZlcnJpZGVEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRIb29rcztcbiAgICByZXR1cm4gKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnM7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxEZWZzID0gZ2xvYmFsRGVmcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRIb29rcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMCwgaG9va3MxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBjb21wYXJlT3B0aW9uYWxEYXRlcyhob29rczAucHJlbWl1bVJlbGVhc2VEYXRlLCBob29rczEucHJlbWl1bVJlbGVhc2VEYXRlKSxcbiAgICAgICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICAgICAgY29udGV4dEluaXQ6IGhvb2tzMC5jb250ZXh0SW5pdC5jb25jYXQoaG9va3MxLmNvbnRleHRJbml0KSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRSZWZpbmVycyksIGhvb2tzMS5ldmVudFJlZmluZXJzKSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGhvb2tzMC5ldmVudERlZk1lbWJlckFkZGVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRTb3VyY2VSZWZpbmVycyksIGhvb2tzMS5ldmVudFNvdXJjZVJlZmluZXJzKSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGhvb2tzMC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGhvb2tzMC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycy5jb25jYXQoaG9va3MxLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBob29rczAuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaG9va3MwLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaG9va3MwLmRhdGVQb2ludFRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlUG9pbnRUcmFuc2Zvcm1zKSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBob29rczAuZGF0ZVNwYW5UcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVNwYW5UcmFuc2Zvcm1zKSxcbiAgICAgICAgdmlld3M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnZpZXdzKSwgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBob29rczEuaXNQcm9wc1ZhbGlkIHx8IGhvb2tzMC5pc1Byb3BzVmFsaWQsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgICAgIHRoZW1lQ2xhc3NlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudGhlbWVDbGFzc2VzKSwgaG9va3MxLnRoZW1lQ2xhc3NlcyksXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGhvb2tzMC5pbml0aWFsVmlldyB8fCBob29rczEuaW5pdGlhbFZpZXcsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLCBob29rczEub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaG9va3MxLnNjcm9sbEdyaWRJbXBsIHx8IGhvb2tzMC5zY3JvbGxHcmlkSW1wbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAubGlzdGVuZXJSZWZpbmVycyksIGhvb2tzMS5saXN0ZW5lclJlZmluZXJzKSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLm9wdGlvblJlZmluZXJzKSwgaG9va3MxLm9wdGlvblJlZmluZXJzKSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5wcm9wU2V0SGFuZGxlcnMpLCBob29rczEucHJvcFNldEhhbmRsZXJzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZU9wdGlvbmFsRGF0ZXMoZGF0ZTAsIGRhdGUxKSB7XG4gICAgaWYgKGRhdGUwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxO1xuICAgIH1cbiAgICBpZiAoZGF0ZTEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGF0ZTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLm1heChkYXRlMC52YWx1ZU9mKCksIGRhdGUxLnZhbHVlT2YoKSkpO1xufVxuXG5jbGFzcyBTdGFuZGFyZFRoZW1lIGV4dGVuZHMgVGhlbWUge1xufVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgICByb290OiAnZmMtdGhlbWUtc3RhbmRhcmQnLFxuICAgIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnOyAvLyBUT0RPOiBtYWtlIFRTLWZyaWVuZGx5XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG5mdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgbGV0IHZpZXdUeXBlO1xuICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xuICAgIH1cbiAgICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgaWYgKHZpZXdEZWYpIHtcbiAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0RlZjtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIGxldCBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgbGV0IHF1ZXJ5UHJvcCA9IChuYW1lKSA9PiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTtcbiAgICBsZXQgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcbiAgICBsZXQgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcbiAgICBsZXQgc3VwZXJEZWYgPSBudWxsO1xuICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgICAgICBvdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pKSwgKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XG59XG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWcoaW5wdXQpIHtcbiAgICBsZXQgcmF3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgY29tcG9uZW50OiBpbnB1dCB9IDpcbiAgICAgICAgaW5wdXQ7XG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSByYXdPcHRpb25zO1xuICAgIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNvbnRlbnQvY2xhc3NOYW1lcy9kaWRNb3VudC9ldGMgZnJvbSBvcHRpb25zP1xuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tcG9uZW50ICYmICEoY29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIEJhc2VDb21wb25lbnQpKSB7XG4gICAgICAgIC8vIFdIWT86IHBlb3BsZSB3ZXJlIHVzaW5nIGBjb21wb25lbnRgIHByb3BlcnR5IGZvciBgY29udGVudGBcbiAgICAgICAgLy8gVE9ETzogY29udmVyZ2Ugb24gb25lIHNldHRpbmcgbmFtZVxuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd09wdGlvbnMpLCB7IGNvbnRlbnQ6IGNvbXBvbmVudCB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN1cGVyVHlwZTogcmF3T3B0aW9ucy50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgcmF3T3B0aW9ucywgLy8gaW5jbHVkZXMgdHlwZSBhbmQgY29tcG9uZW50IHRvbyA6KFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuICh2aWV3UHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogYnVpbGRWaWV3Q2xhc3NOYW1lcyhjb250ZXh0LnZpZXdTcGVjKSwgcmVuZGVyUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSwgeyBuZXh0RGF5VGhyZXNob2xkOiBjb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCB9KSwgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuY29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53aWxsVW5tb3VudCB9KSkpKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlY3MoZGVmYXVsdElucHV0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cyk7XG4gICAgbGV0IG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKTtcbiAgICBsZXQgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgcmV0dXJuIG1hcEhhc2godmlld0RlZnMsICh2aWV3RGVmKSA9PiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykpO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICBsZXQgZHVyYXRpb25JbnB1dCA9IHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcbiAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICBvcHRpb25PdmVycmlkZXMuZHVyYXRpb247XG4gICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICBsZXQgZHVyYXRpb25Vbml0ID0gJyc7XG4gICAgbGV0IHNpbmdsZVVuaXQgPSAnJztcbiAgICBsZXQgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IHt9O1xuICAgIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cbiAgICAgICAgICAgIGxldCBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbik7XG4gICAgICAgICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0O1xuICAgICAgICAgICAgaWYgKGRlbm9tLnZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdCA9IGR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5yYXdPcHRpb25zIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHF1ZXJ5QnV0dG9uVGV4dCA9IChvcHRpb25zU3Vic2V0KSA9PiB7XG4gICAgICAgIGxldCBidXR0b25UZXh0TWFwID0gb3B0aW9uc1N1YnNldC5idXR0b25UZXh0IHx8IHt9O1xuICAgICAgICBsZXQgYnV0dG9uVGV4dEtleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTtcbiAgICAgICAgaWYgKGJ1dHRvblRleHRLZXkgIT0gbnVsbCAmJiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGxldCBxdWVyeUJ1dHRvblRpdGxlID0gKG9wdGlvbnNTdWJzZXQpID0+IHtcbiAgICAgICAgbGV0IGJ1dHRvbkhpbnRzID0gb3B0aW9uc1N1YnNldC5idXR0b25IaW50cyB8fCB7fTtcbiAgICAgICAgbGV0IGJ1dHRvbktleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTsgLy8gdXNlIHNhbWUga2V5IGFzIHRleHRcbiAgICAgICAgaWYgKGJ1dHRvbktleSAhPSBudWxsICYmIGJ1dHRvbkhpbnRzW2J1dHRvbktleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW2J1dHRvbktleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdEZWYudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB2aWV3RGVmLmNvbXBvbmVudCxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uVW5pdCxcbiAgICAgICAgc2luZ2xlVW5pdCxcbiAgICAgICAgb3B0aW9uRGVmYXVsdHM6IHZpZXdEZWYuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaW5nbGVVbml0T3ZlcnJpZGVzKSwgdmlld0RlZi5vdmVycmlkZXMpLFxuICAgICAgICBidXR0b25UZXh0T3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGV4dChkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbk92ZXJyaWRlcykgfHwgLy8gY29uc3RydWN0b3Itc3BlY2lmaWVkIGJ1dHRvblRleHQgbG9va3VwIGhhc2ggdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uVGV4dCxcbiAgICAgICAgYnV0dG9uVGV4dERlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGV4dChsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KEJBU0VfT1BUSU9OX0RFRkFVTFRTKSB8fFxuICAgICAgICAgICAgdmlld0RlZi50eXBlLFxuICAgICAgICAvLyBub3QgRFJZXG4gICAgICAgIGJ1dHRvblRpdGxlT3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGl0bGUoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUob3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uSGludCxcbiAgICAgICAgYnV0dG9uVGl0bGVEZWZhdWx0OiBxdWVyeUJ1dHRvblRpdGxlKGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25IaW50IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKEJBU0VfT1BUSU9OX0RFRkFVTFRTKSxcbiAgICAgICAgLy8gd2lsbCBldmVudHVhbGx5IGZhbGwgYmFjayB0byBidXR0b25UZXh0XG4gICAgfTtcbn1cbi8vIGhhY2sgdG8gZ2V0IG1lbW9pemF0aW9uIHdvcmtpbmdcbmxldCBkdXJhdGlvbklucHV0TWFwID0ge307XG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkdXJhdGlvbklucHV0KTtcbiAgICBsZXQgcmVzID0gZHVyYXRpb25JbnB1dE1hcFtqc29uXTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzID0gY3JlYXRlRHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGR1cmF0aW9uSW5wdXRNYXBbanNvbl0gPSByZXM7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5kYXRlTWFya2VyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgIH1cbn1cbi8vIHNob3VsZCBiZSBpbml0aWFsaXplZCBvbmNlIGFuZCBzdGF5IGNvbnN0YW50XG4vLyB0aGlzIHdpbGwgY2hhbmdlIHRvb1xuZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGUob3B0aW9ucywgZGF0ZUVudiwgbm93TWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0ZUlucHV0ID0gb3B0aW9ucy5pbml0aWFsRGF0ZTtcbiAgICAvLyBjb21wdXRlIHRoZSBpbml0aWFsIGFtYmlnLXRpbWV6b25lIGRhdGVcbiAgICBpZiAoaW5pdGlhbERhdGVJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbml0aWFsRGF0ZUlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vd01hbmFnZXIuZ2V0RGF0ZU1hcmtlcigpO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnU0VUX09QVElPTic6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgeyBbYWN0aW9uLm9wdGlvbk5hbWVdOiBhY3Rpb24ucmF3T3B0aW9uVmFsdWUgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVQcm9maWxlKGN1cnJlbnREYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZHA7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSk7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlcik7XG4gICAgICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnREYXRlUHJvZmlsZTtcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50U291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7XG4gICAgcmV0dXJuIGFkZFNvdXJjZXMoe30sIHBhcnNlSW5pdGlhbFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdBRERfRVZFTlRfU09VUkNFUyc6IC8vIGFscmVhZHkgcGFyc2VkXG4gICAgICAgICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgICAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZHMgPyAvLyB3aHkgbm8gdHlwZT9cbiAgICAgICAgICAgICAgICBhcnJheVRvSGFzaChhY3Rpb24uc291cmNlSWRzKSA6XG4gICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGFjdGlvbi5pc1JlZmV0Y2ggfHwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRfRVJST1InOlxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSZXNwb25zZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIHRydWUsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKSB7XG4gICAgZm9yIChsZXQgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VzLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBoYXNoW3NvdXJjZS5zb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChmZXRjaFJhbmdlKSB7XG4gICAgICAgIGhhc2ggPSBmZXRjaERpcnR5U291cmNlcyhoYXNoLCBmZXRjaFJhbmdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2VIYXNoKSwgaGFzaCk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgKGV2ZW50U291cmNlKSA9PiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQpO1xufVxuZnVuY3Rpb24gZmV0Y2hEaXJ0eVNvdXJjZXMoc291cmNlSGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhzb3VyY2VIYXNoLCBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkpLCBmZXRjaFJhbmdlLCBmYWxzZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQ7XG4gICAgfVxuICAgIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgICBldmVudFNvdXJjZS5pc0ZldGNoaW5nIHx8IC8vIGFsd2F5cyBjYW5jZWwgb3V0ZGF0ZWQgaW4tcHJvZ3Jlc3MgZmV0Y2hlc1xuICAgICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2VzQnlJZHMocHJldlNvdXJjZXMsIHNvdXJjZUlkSGFzaCwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgbGV0IG5leHRTb3VyY2VzID0ge307XG4gICAgZm9yIChsZXQgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXTtcbiAgICAgICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFNvdXJjZXM7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHNvdXJjZURlZiA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXTtcbiAgICBsZXQgZmV0Y2hJZCA9IGd1aWQoKTtcbiAgICBzb3VyY2VEZWYuZmV0Y2goe1xuICAgICAgICBldmVudFNvdXJjZSxcbiAgICAgICAgcmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgIGlzUmVmZXRjaCxcbiAgICAgICAgY29udGV4dCxcbiAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgIGxldCB7IHJhd0V2ZW50cyB9ID0gcmVzO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IGV2ZW50U291cmNlLnN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMucmVzcG9uc2UpIHx8IHJhd0V2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UUycsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIHJhd0V2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgIGxldCBlcnJvckhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZS5jYWxsKGNhbGVuZGFyQXBpLCBlcnJvcik7XG4gICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKTtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnJvckhhbmRsZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVF9FUlJPUicsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogdHJ1ZSwgbGF0ZXN0RmV0Y2hJZDogZmV0Y2hJZCB9KTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShzb3VyY2VIYXNoLCBzb3VyY2VJZCwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSkge1xuICAgIGxldCBldmVudFNvdXJjZSA9IHNvdXJjZUhhc2hbc291cmNlSWRdO1xuICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc291cmNlSGFzaCksIHsgW3NvdXJjZUlkXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogZmFsc2UsIGZldGNoUmFuZ2UgfSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VIYXNoO1xufVxuZnVuY3Rpb24gZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5pdGlhbFNvdXJjZXMocmF3T3B0aW9ucywgY29udGV4dCkge1xuICAgIGxldCByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTtcbiAgICBsZXQgcmF3U291cmNlcyA9IFtdLmNvbmNhdChyYXdPcHRpb25zLmV2ZW50U291cmNlcyB8fCBbXSk7XG4gICAgbGV0IHNvdXJjZXMgPSBbXTsgLy8gcGFyc2VkXG4gICAgaWYgKHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHJhd09wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmV2ZW50cyk7XG4gICAgfVxuICAgIGZvciAobGV0IHJhd1NvdXJjZSBvZiByYXdTb3VyY2VzKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHJhd1NvdXJjZSwgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbn1cbmZ1bmN0aW9uIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcbiAgICBsZXQgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzO1xuICAgIHJldHVybiAhZGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF0uaWdub3JlUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VTZWxlY3RlZEV2ZW50KGN1cnJlbnRJbnN0YW5jZUlkLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAnU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRJbnN0YW5jZUlkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZUlkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnREcmFnKGN1cnJlbnREcmFnLCBhY3Rpb24pIHtcbiAgICBsZXQgbmV3RHJhZztcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIG5ld0RyYWcgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdEcmFnLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld0RyYWcubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdEcmFnLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREcmFnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZSwgYWN0aW9uKSB7XG4gICAgbGV0IG5ld1Jlc2l6ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xiYXJzKGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IGhlYWRlciA9IGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIGxldCBmb290ZXIgPSBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICByZXR1cm4geyBoZWFkZXIsIGZvb3RlciB9O1xufVxuZnVuY3Rpb24gcGFyc2VUb29sYmFyKHNlY3Rpb25TdHJIYXNoLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBzZWN0aW9uV2lkZ2V0cyA9IHt9O1xuICAgIGxldCB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgbGV0IGhhc1RpdGxlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgc2VjdGlvbk5hbWUgaW4gc2VjdGlvblN0ckhhc2gpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25TdHIgPSBzZWN0aW9uU3RySGFzaFtzZWN0aW9uTmFtZV07XG4gICAgICAgIGxldCBzZWN0aW9uUmVzID0gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgc2VjdGlvbldpZGdldHNbc2VjdGlvbk5hbWVdID0gc2VjdGlvblJlcy53aWRnZXRzO1xuICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goLi4uc2VjdGlvblJlcy52aWV3c1dpdGhCdXR0b25zKTtcbiAgICAgICAgaGFzVGl0bGUgPSBoYXNUaXRsZSB8fCBzZWN0aW9uUmVzLmhhc1RpdGxlO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWN0aW9uV2lkZ2V0cywgdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGUgfTtcbn1cbi8qXG5CQUQ6IHF1ZXJ5aW5nIGljb25zIGFuZCB0ZXh0IGhlcmUuIHNob3VsZCBiZSBkb25lIGF0IHJlbmRlciB0aW1lXG4qL1xuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgLy8gZGVmYXVsdHMrb3ZlcnJpZGVzLCB0aGVuIHJlZmluZWRcbmNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCAvLyBvdmVycmlkZXMgb25seSEsIHVucmVmaW5lZCA6KFxudGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgaXNSdGwgPSBjYWxlbmRhck9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICBsZXQgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gY2FsZW5kYXJPcHRpb25zLmN1c3RvbUJ1dHRvbnMgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dCA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25UZXh0IHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25IaW50cyB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25IaW50cyA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25IaW50cyB8fCB7fTtcbiAgICBsZXQgc2VjdGlvblN1YnN0cnMgPSBzZWN0aW9uU3RyID8gc2VjdGlvblN0ci5zcGxpdCgnICcpIDogW107XG4gICAgbGV0IHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcbiAgICBsZXQgaGFzVGl0bGUgPSBmYWxzZTtcbiAgICBsZXQgd2lkZ2V0cyA9IHNlY3Rpb25TdWJzdHJzLm1hcCgoYnV0dG9uR3JvdXBTdHIpID0+IChidXR0b25Hcm91cFN0ci5zcGxpdCgnLCcpLm1hcCgoYnV0dG9uTmFtZSkgPT4ge1xuICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgaGFzVGl0bGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXN0b21CdXR0b25Qcm9wcztcbiAgICAgICAgbGV0IHZpZXdTcGVjO1xuICAgICAgICBsZXQgYnV0dG9uQ2xpY2s7XG4gICAgICAgIGxldCBidXR0b25JY29uOyAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxuICAgICAgICBsZXQgYnV0dG9uVGV4dDsgLy8gXCJcbiAgICAgICAgbGV0IGJ1dHRvbkhpbnQ7XG4gICAgICAgIC8vIF4gZm9yIHRoZSB0aXRsZT1cIlwiIGF0dHJpYnV0ZSwgZm9yIGFjY2Vzc2liaWxpdHlcbiAgICAgICAgaWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoZXYudGFyZ2V0LCBldiwgZXYudGFyZ2V0KTsgLy8gVE9ETzogdXNlIENhbGVuZGFyIHRoaXMgY29udGV4dD9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGN1c3RvbUJ1dHRvblByb3BzLmhpbnQgfHwgY3VzdG9tQnV0dG9uUHJvcHMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmlld1NwZWMgPSB2aWV3U3BlY3NbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KTtcbiAgICAgICAgICAgIGxldCB0ZXh0RmFsbGJhY2sgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdDtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHModmlld1NwZWMuYnV0dG9uVGl0bGVPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRpdGxlRGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy52aWV3SGludCwgW3RleHRGYWxsYmFjaywgYnV0dG9uTmFtZV0sIC8vIHZpZXctbmFtZSA9IGJ1dHRvbk5hbWVcbiAgICAgICAgICAgIHRleHRGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhckFwaSBtZXRob2RcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTsgLy8gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgfHwgYnV0dG9uTmFtZSA9PT0gJ25leHRZZWFyJykge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2T3JOZXh0ID0gYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1twcmV2T3JOZXh0XSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW3ByZXZPck5leHRdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dC55ZWFyIHx8ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gKG5hdlVuaXQpID0+IGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbYnV0dG9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1tidXR0b25OYW1lXSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHRbbmF2VW5pdF0gfHwgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICAgICAgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrLCBidXR0b25JY29uLCBidXR0b25UZXh0LCBidXR0b25IaW50IH07XG4gICAgfSkpKTtcbiAgICByZXR1cm4geyB3aWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZSB9O1xufVxuXG4vLyBhbHdheXMgcmVwcmVzZW50cyB0aGUgY3VycmVudCB2aWV3LiBvdGhlcndpc2UsIGl0J2QgbmVlZCB0byBjaGFuZ2UgdmFsdWUgZXZlcnkgdGltZSBkYXRlIGNoYW5nZXNcbmNsYXNzIFZpZXdJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gZ2V0Q3VycmVudERhdGE7XG4gICAgICAgIHRoaXMuZGF0ZUVudiA9IGRhdGVFbnY7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5jYWxlbmRhckFwaTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdUaXRsZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2Uuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkub3B0aW9uc1tuYW1lXTsgLy8gYXJlIHRoZSB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbiAgICB9XG59XG5cbmxldCBldmVudFNvdXJjZURlZiQyID0ge1xuICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZmluZWQuZXZlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGEsXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuY29uc3QgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2FycmF5LWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXG59KTtcblxubGV0IGV2ZW50U291cmNlRGVmJDEgPSB7XG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVkLmV2ZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgeyBkYXRlRW52IH0gPSBhcmcuY29udGV4dDtcbiAgICAgICAgY29uc3QgZnVuYyA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICB1bnByb21pc2lmeShmdW5jLmJpbmQobnVsbCwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShhcmcucmFuZ2UsIGRhdGVFbnYpKSwgKHJhd0V2ZW50cykgPT4gc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzIH0pLCBlcnJvckNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmNvbnN0IGZ1bmNFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2Z1bmMtZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQxXSxcbn0pO1xuXG5jb25zdCBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIG1ldGhvZDogU3RyaW5nLFxuICAgIGV4dHJhUGFyYW1zOiBpZGVudGl0eSxcbiAgICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gICAgZW5kUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXG59O1xuXG5sZXQgZXZlbnRTb3VyY2VEZWYgPSB7XG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSB9ID0gYXJnLmV2ZW50U291cmNlO1xuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xuICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMpLnRoZW4oKFtyYXdFdmVudHMsIHJlc3BvbnNlXSkgPT4ge1xuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzLCByZXNwb25zZSB9KTtcbiAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgfSxcbn07XG5jb25zdCBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnanNvbi1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSk7XG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCBzdGFydFBhcmFtO1xuICAgIGxldCBlbmRQYXJhbTtcbiAgICBsZXQgdGltZVpvbmVQYXJhbTtcbiAgICBsZXQgY3VzdG9tUmVxdWVzdFBhcmFtcztcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcbiAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XG4gICAgfVxuICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcbiAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XG4gICAgfVxuICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XG4gICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XG4gICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQpO1xuICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpO1xuICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XG4gICAgICAgIHBhcmFtc1t0aW1lWm9uZVBhcmFtXSA9IGRhdGVFbnYudGltZVpvbmU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5cbmNvbnN0IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgPSB7XG4gICAgZGF5c09mV2VlazogaWRlbnRpdHksXG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBlbmRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgc3RhcnRSZWN1cjogaWRlbnRpdHksXG4gICAgZW5kUmVjdXI6IGlkZW50aXR5LFxufTtcblxubGV0IHJlY3VycmluZyA9IHtcbiAgICBwYXJzZShyZWZpbmVkLCBkYXRlRW52KSB7XG4gICAgICAgIGlmIChyZWZpbmVkLmRheXNPZldlZWsgfHwgcmVmaW5lZC5zdGFydFRpbWUgfHwgcmVmaW5lZC5lbmRUaW1lIHx8IHJlZmluZWQuc3RhcnRSZWN1ciB8fCByZWZpbmVkLmVuZFJlY3VyKSB7XG4gICAgICAgICAgICBsZXQgcmVjdXJyaW5nRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXlzT2ZXZWVrOiByZWZpbmVkLmRheXNPZldlZWsgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZW5kVGltZTogcmVmaW5lZC5lbmRUaW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRSZWN1cjogcmVmaW5lZC5zdGFydFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5zdGFydFJlY3VyKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW5kUmVjdXI6IHJlZmluZWQuZW5kUmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLmVuZFJlY3VyKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0ZUVudixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgZHVyYXRpb247XG4gICAgICAgICAgICBpZiAocmVmaW5lZC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcmVmaW5lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHVyYXRpb24gJiYgcmVmaW5lZC5zdGFydFRpbWUgJiYgcmVmaW5lZC5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBzdWJ0cmFjdER1cmF0aW9ucyhyZWZpbmVkLmVuZFRpbWUsIHJlZmluZWQuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsRGF5R3Vlc3M6IEJvb2xlYW4oIXJlZmluZWQuc3RhcnRUaW1lICYmICFyZWZpbmVkLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdEYXRhLCAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kKHR5cGVEYXRhLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICAgICAgbGV0IGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZnJhbWluZ1JhbmdlLCB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH0pO1xuICAgICAgICBpZiAoY2xpcHBlZEZyYW1pbmdSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJhbmdlcyh0eXBlRGF0YS5kYXlzT2ZXZWVrLCB0eXBlRGF0YS5zdGFydFRpbWUsIHR5cGVEYXRhLmRhdGVFbnYsIGRhdGVFbnYsIGNsaXBwZWRGcmFtaW5nUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxufTtcbmNvbnN0IHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ3NpbXBsZS1yZWN1cnJpbmctZXZlbnQnLFxuICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nXSxcbiAgICBldmVudFJlZmluZXJzOiBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTLFxufSk7XG5mdW5jdGlvbiBleHBhbmRSYW5nZXMoZGF5c09mV2Vlaywgc3RhcnRUaW1lLCBldmVudERhdGVFbnYsIGNhbGVuZGFyRGF0ZUVudiwgZnJhbWluZ1JhbmdlKSB7XG4gICAgbGV0IGRvd0hhc2ggPSBkYXlzT2ZXZWVrID8gYXJyYXlUb0hhc2goZGF5c09mV2VlaykgOiBudWxsO1xuICAgIGxldCBkYXlNYXJrZXIgPSBzdGFydE9mRGF5KGZyYW1pbmdSYW5nZS5zdGFydCk7XG4gICAgbGV0IGVuZE1hcmtlciA9IGZyYW1pbmdSYW5nZS5lbmQ7XG4gICAgbGV0IGluc3RhbmNlU3RhcnRzID0gW107XG4gICAgd2hpbGUgKGRheU1hcmtlciA8IGVuZE1hcmtlcikge1xuICAgICAgICBsZXQgaW5zdGFuY2VTdGFydDtcbiAgICAgICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xuICAgICAgICBpZiAoIWRvd0hhc2ggfHwgZG93SGFzaFtkYXlNYXJrZXIuZ2V0VVRDRGF5KCldKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGNhbGVuZGFyRGF0ZUVudi5hZGQoZGF5TWFya2VyLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRheU1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goY2FsZW5kYXJEYXRlRW52LmNyZWF0ZU1hcmtlcihldmVudERhdGVFbnYudG9EYXRlKGluc3RhbmNlU3RhcnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF5TWFya2VyID0gYWRkRGF5cyhkYXlNYXJrZXIsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VTdGFydHM7XG59XG5cbmNvbnN0IGNoYW5nZUhhbmRsZXJQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdjaGFuZ2UtaGFuZGxlcicsXG4gICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHtcbiAgICAgICAgZXZlbnRzKGV2ZW50cywgY29udGV4dCkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRTb3VyY2VzKFtldmVudHNdLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBoYW5kbGVFdmVudFNvdXJjZXMsXG4gICAgfSxcbn0pO1xuLypcbkJVRzogaWYgYGV2ZW50YCB3YXMgc3VwcGxpZWQsIGFsbCBwcmV2aW91c2x5LWdpdmVuIGBldmVudFNvdXJjZXNgIHdpbGwgYmUgd2lwZWQgb3V0XG4qL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY29udGV4dCkge1xuICAgIGxldCB1bmZvdW5kU291cmNlcyA9IGhhc2hWYWx1ZXNUb0FycmF5KGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXMpO1xuICAgIGlmICh1bmZvdW5kU291cmNlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHVuZm91bmRTb3VyY2VzWzBdLl9yYXcpICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoaW5wdXRzWzBdKSkge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRVNFVF9SQVdfRVZFTlRTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlc1swXS5zb3VyY2VJZCxcbiAgICAgICAgICAgIHJhd0V2ZW50czogaW5wdXRzWzBdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmV3SW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICAgIGxldCBpbnB1dEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh1bmZvdW5kU291cmNlc1tpXS5fcmF3ID09PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIHVuZm91bmRTb3VyY2VzLnNwbGljZShpLCAxKTsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgaW5wdXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICAgICAgICBuZXdJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgdW5mb3VuZFNvdXJjZSBvZiB1bmZvdW5kU291cmNlcykge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgbmV3SW5wdXQgb2YgbmV3SW5wdXRzKSB7XG4gICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuYWRkRXZlbnRTb3VyY2UobmV3SW5wdXQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQuZGF0ZUVudikpLCB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgY29udGV4dCkge1xuICAgIGxldCB7IGVtaXR0ZXIgfSA9IGNvbnRleHQ7XG4gICAgaWYgKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50c1NldCcpKSB7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRzU2V0JywgYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCkpO1xuICAgIH1cbn1cblxuLypcbnRoaXMgYXJyYXkgaXMgZXhwb3NlZCBvbiB0aGUgcm9vdCBuYW1lc3BhY2Ugc28gdGhhdCBVTUQgcGx1Z2lucyBjYW4gYWRkIHRvIGl0Llxuc2VlIHRoZSByb2xsdXAtYnVuZGxlcyBzY3JpcHQuXG4qL1xuY29uc3QgZ2xvYmFsUGx1Z2lucyA9IFtcbiAgICBhcnJheUV2ZW50U291cmNlUGx1Z2luLFxuICAgIGZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAgICBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luLFxuICAgIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbixcbiAgICBjaGFuZ2VIYW5kbGVyUGx1Z2luLFxuICAgIGNyZWF0ZVBsdWdpbih7XG4gICAgICAgIG5hbWU6ICdtaXNjJyxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtcbiAgICAgICAgICAgIChzdGF0ZSkgPT4gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoc3RhdGUuZXZlbnRTb3VyY2VzKSxcbiAgICAgICAgXSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogaGFuZGxlRGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBoYW5kbGVFdmVudFN0b3JlLFxuICAgICAgICB9LFxuICAgIH0pLFxuXTtcblxuY2xhc3MgVGFza1J1bm5lciB7XG4gICAgY29uc3RydWN0b3IocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHJlcXVlc3QodGFzaywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XG4gICAgfVxuICAgIHBhdXNlKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5wYXVzZShzY29wZSk7XG4gICAgfVxuICAgIHJlc3VtZShzY29wZSwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgbGV0IHsgcXVldWUgfSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjb21wbGV0ZWRUYXNrcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcbiAgICB9XG4gICAgcnVuVGFzayh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbmVkKGNvbXBsZXRlZFRhc2tzKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbihjb21wbGV0ZWRUYXNrcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5mdW5jdGlvbiBidWlsZFRpdGxlKGRhdGVQcm9maWxlLCB2aWV3T3B0aW9ucywgZGF0ZUVudikge1xuICAgIGxldCByYW5nZTtcbiAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkpLCB7XG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpIHtcbiAgICBsZXQgeyBjdXJyZW50UmFuZ2VVbml0IH0gPSBkYXRlUHJvZmlsZTtcbiAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcbiAgICB9XG4gICAgbGV0IGRheXMgPSBkaWZmV2hvbGVEYXlzKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCk7XG4gICAgaWYgKGRheXMgIT09IG51bGwgJiYgZGF5cyA+IDEpIHtcbiAgICAgICAgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgLy8gb25lIGRheS4gbG9uZ2VyLCBsaWtlIFwiU2VwdGVtYmVyIDkgMjAxNFwiXG4gICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9O1xufVxuXG4vKlxuVE9ETzogdGVzdCBzd2l0Y2hpbmcgdGltZXpvbmVzIHdoZW4gTk8gdGltZXpvbmUgcGx1Z2luXG4qL1xuY2xhc3MgQ2FsZW5kYXJOb3dNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZXNldExpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgaGFuZGxlSW5wdXQoZGF0ZUVudiwgLy8gd2lsbCBjaGFuZ2UgaWYgdGltZXpvbmUgc2V0dXAgY2hhbmdlZFxuICAgIG5vd0lucHV0KSB7XG4gICAgICAgIGNvbnN0IG9sZERhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XG4gICAgICAgIGlmIChkYXRlRW52ICE9PSBvbGREYXRlRW52KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3dGbiA9IG5vd0lucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9sZERhdGVFbnYpIHsgLy8gZmlyc3QgdGltZT9cbiAgICAgICAgICAgICAgICB0aGlzLm5vd0FuY2hvckRhdGUgPSBkYXRlRW52LnRvRGF0ZShub3dJbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KVxuICAgICAgICAgICAgICAgICAgICA6IGRhdGVFbnYuY3JlYXRlTm93TWFya2VyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubm93QW5jaG9yUXVlcmllZCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGVFbnYgPSBkYXRlRW52O1xuICAgICAgICAgICAgLy8gbm90IGZpcnN0IHRpbWU/IGZpcmUgcmVzZXQgaGFuZGxlcnNcbiAgICAgICAgICAgIGlmIChvbGREYXRlRW52KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNldExpc3RlbmVyIG9mIHRoaXMucmVzZXRMaXN0ZW5lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRlTWFya2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3dBbmNob3JEYXRlXG4gICAgICAgICAgICA/IHRoaXMuZGF0ZUVudi50aW1lc3RhbXBUb01hcmtlcih0aGlzLm5vd0FuY2hvckRhdGUudmFsdWVPZigpICtcbiAgICAgICAgICAgICAgICAoRGF0ZS5ub3coKSAtIHRoaXMubm93QW5jaG9yUXVlcmllZCkpXG4gICAgICAgICAgICA6IHRoaXMuZGF0ZUVudi5jcmVhdGVNYXJrZXIodGhpcy5ub3dGbigpKTtcbiAgICB9XG4gICAgYWRkUmVzZXRMaXN0ZW5lcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucmVzZXRMaXN0ZW5lcnMuYWRkKGhhbmRsZXIpO1xuICAgIH1cbiAgICByZW1vdmVSZXNldExpc3RlbmVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5yZXNldExpc3RlbmVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgfVxufVxuXG4vLyBpbiBmdXR1cmUgcmVmYWN0b3IsIGRvIHRoZSByZWR1eC1zdHlsZSBmdW5jdGlvbihzdGF0ZT1pbml0aWFsKSBmb3IgaW5pdGlhbC1zdGF0ZVxuLy8gYWxzbywgd2hhdGV2ZXIgaXMgaGFwcGVuaW5nIGluIGNvbnN0cnVjdG9yLCBoYXZlIGl0IGhhcHBlbiBpbiBhY3Rpb24gcXVldWUgdG9vXG5jbGFzcyBDYWxlbmRhckRhdGFNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEgPSBtZW1vaXplKHRoaXMuX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEpO1xuICAgICAgICB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyA9IG1lbW9pemUob3JnYW5pemVSYXdMb2NhbGVzKTtcbiAgICAgICAgdGhpcy5idWlsZExvY2FsZSA9IG1lbW9pemUoYnVpbGRMb2NhbGUpO1xuICAgICAgICB0aGlzLmJ1aWxkUGx1Z2luSG9va3MgPSBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKTtcbiAgICAgICAgdGhpcy5idWlsZERhdGVFbnYgPSBtZW1vaXplKGJ1aWxkRGF0ZUVudiQxKTtcbiAgICAgICAgdGhpcy5idWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZVRvb2xiYXJzID0gbWVtb2l6ZShwYXJzZVRvb2xiYXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjcyA9IG1lbW9pemUoYnVpbGRWaWV3U3BlY3MpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBtZW1vaXplT2JqQXJnKGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld0FwaSA9IG1lbW9pemUoYnVpbGRWaWV3QXBpKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdVaVByb3BzID0gbWVtb2l6ZU9iakFyZyhidWlsZFZpZXdVaVByb3BzKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemUoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzUHJvcHNFcXVhbCk7XG4gICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQmFzZXMgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJhc2VzKTtcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZU9iakFyZyhwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRpdGxlID0gbWVtb2l6ZShidWlsZFRpdGxlKTtcbiAgICAgICAgdGhpcy5ub3dNYW5hZ2VyID0gbmV3IENhbGVuZGFyTm93TWFuYWdlcigpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lciA9IG5ldyBUYXNrUnVubmVyKHRoaXMuX2hhbmRsZUFjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9ICgpID0+IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoYWN0aW9uKTsgLy8gcHJvdGVjdHMgYWdhaW5zdCByZWN1cnNpdmUgY2FsbHMgdG8gX2hhbmRsZUFjdGlvblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnBhdXNlKCk7XG4gICAgICAgIHRoaXMubm93TWFuYWdlciA9IG5ldyBDYWxlbmRhck5vd01hbmFnZXIoKTtcbiAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIGxldCBjYWxlbmRhckNvbnRleHQgPSB7XG4gICAgICAgICAgICBub3dNYW5hZ2VyOiB0aGlzLm5vd01hbmFnZXIsXG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICAgICAgICBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gZ2V0SW5pdGlhbERhdGUob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52LCB0aGlzLm5vd01hbmFnZXIpO1xuICAgICAgICBsZXQgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgYWZ0ZXIgc2V0VGhpc0NvbnRleHRcbiAgICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuY29udGV4dEluaXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9UIERSWVxuICAgICAgICBsZXQgZXZlbnRTb3VyY2VzID0gaW5pdEV2ZW50U291cmNlcyhvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczoge30sXG4gICAgICAgICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICAgICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY29udGV4dEFuZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGluaXRpYWxTdGF0ZSwgcmVkdWNlcihudWxsLCBudWxsLCBjb250ZXh0QW5kU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZUlzTG9hZGluZyhpbml0aWFsU3RhdGUsIGNhbGVuZGFyQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7IC8vIE5PVCBEUllcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVzdW1lKCk7XG4gICAgfVxuICAgIHJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGNoYW5nZWRPcHRpb25OYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBvcHRpb25PdmVycmlkZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChwcm9wcy5vcHRpb25PdmVycmlkZXMgfHwge30pKSwgb3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0ZvclJlZmluaW5nLnB1c2goLi4uY2hhbmdlZE9wdGlvbk5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZE9wdGlvbk5hbWVzID09PSB1bmRlZmluZWQgfHwgY2hhbmdlZE9wdGlvbk5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ05PVEhJTkcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hhbmRsZUFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBlbWl0dGVyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSByZWR1Y2VWaWV3VHlwZShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIGFjdGlvbik7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICBlbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKTtcbiAgICAgICAgbGV0IGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIG5vd01hbmFnZXI6IHRoaXMubm93TWFuYWdlcixcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgY3VycmVudERhdGUsIGRhdGVQcm9maWxlIH0gPSBzdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgIT09IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcikgeyAvLyBoYWNrXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudERhdGUgPSByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnUFJFVicgfHwgLy8gVE9ETzogbW92ZSB0aGlzIGxvZ2ljIGludG8gRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgICAgICAgICAgIGFjdGlvbi50eXBlID09PSAnTkVYVCcgfHwgLy8gXCJcbiAgICAgICAgICAgICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSByZWR1Y2VFdmVudFN0b3JlKHN0YXRlLmV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGlzRXZlbnRzTG9hZGluZyA9IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcyk7IC8vIEJBRC4gYWxzbyBjYWxsZWQgaW4gdGhpcyBmdW5jIGluIGNvbXB1dGVJc0xvYWRpbmdcbiAgICAgICAgbGV0IHJlbmRlcmFibGVFdmVudFN0b3JlID0gKGlzRXZlbnRzTG9hZGluZyAmJiAhY3VycmVudFZpZXdEYXRhLm9wdGlvbnMucHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZykgP1xuICAgICAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgIGV2ZW50U3RvcmU7XG4gICAgICAgIGxldCB7IGV2ZW50VWlTaW5nbGVCYXNlLCBzZWxlY3Rpb25Db25maWcgfSA9IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpOyAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgICAgIGxldCBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcyk7XG4gICAgICAgIGxldCBldmVudFVpQmFzZXMgPSB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzKHJlbmRlcmFibGVFdmVudFN0b3JlLmRlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpO1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcmVkdWNlRGF0ZVNlbGVjdGlvbihzdGF0ZS5kYXRlU2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHJlZHVjZVNlbGVjdGVkRXZlbnQoc3RhdGUuZXZlbnRTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudERyYWc6IHJlZHVjZUV2ZW50RHJhZyhzdGF0ZS5ldmVudERyYWcsIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogcmVkdWNlRXZlbnRSZXNpemUoc3RhdGUuZXZlbnRSZXNpemUsIGFjdGlvbiksXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250ZXh0QW5kU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIG5ld1N0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdTdGF0ZSwgcmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBjb250ZXh0QW5kU3RhdGUpKTsgLy8gZ2l2ZSB0aGUgT0xEIHN0YXRlLCBmb3Igb2xkIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhuZXdTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogdXNlIHByb3BTZXRIYW5kbGVycyBpbiBwbHVnaW4gc3lzdGVtXG4gICAgICAgIGlmICghd2FzTG9hZGluZyAmJiBpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdhc0xvYWRpbmcgJiYgIWlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByb3BzLm9uQWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZURhdGEoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG9sZERhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBub3dNYW5hZ2VyOiB0aGlzLm5vd01hbmFnZXIsIHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSwgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsIGVtaXR0ZXI6IHRoaXMuZW1pdHRlciwgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEgfSwgb3B0aW9uc0RhdGEpLCBjdXJyZW50Vmlld0RhdGEpLCBzdGF0ZSk7XG4gICAgICAgIGxldCBjaGFuZ2VIYW5kbGVycyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICBsZXQgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgbGV0IG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFja1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlID0gZGF0YS5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIGNoYW5nZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIG9sZENhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhhbmRsZXJzW29wdGlvbk5hbWVdKG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nID0gW107XG4gICAgICAgIGlmIChwcm9wcy5vbkRhdGEpIHtcbiAgICAgICAgICAgIHByb3BzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlT3B0aW9uc0RhdGEob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBjYWxlbmRhckFwaSkge1xuICAgICAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcubGVuZ3RoICYmXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzICYmXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID09PSB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEsIH0gPSB0aGlzLnByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgbGV0IGRhdGVFbnYgPSB0aGlzLmJ1aWxkRGF0ZUVudihyZWZpbmVkT3B0aW9ucy50aW1lWm9uZSwgcmVmaW5lZE9wdGlvbnMubG9jYWxlLCByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LCByZWZpbmVkT3B0aW9ucy53ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIHJlZmluZWRPcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIGxldCB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7XG4gICAgICAgIGxldCB0aGVtZSA9IHRoaXMuYnVpbGRUaGVtZShyZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MpO1xuICAgICAgICBsZXQgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YSA9IHtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9uczogcmVmaW5lZE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGRhdGVFbnYsXG4gICAgICAgICAgICB2aWV3U3BlY3MsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIHRvb2xiYXJDb25maWcsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGF2YWlsYWJsZVJhd0xvY2FsZXM6IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgICBwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgeyBsb2NhbGVzLCBsb2NhbGUgfSA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgYXZhaWxhYmxlTG9jYWxlRGF0YSA9IHRoaXMub3JnYW5pemVSYXdMb2NhbGVzKGxvY2FsZXMpO1xuICAgICAgICBsZXQgYXZhaWxhYmxlUmF3TG9jYWxlcyA9IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwO1xuICAgICAgICBsZXQgbG9jYWxlRGVmYXVsdHMgPSB0aGlzLmJ1aWxkTG9jYWxlKGxvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVSYXdMb2NhbGVzKS5vcHRpb25zO1xuICAgICAgICBsZXQgcGx1Z2luSG9va3MgPSB0aGlzLmJ1aWxkUGx1Z2luSG9va3Mob3B0aW9uT3ZlcnJpZGVzLnBsdWdpbnMgfHwgW10sIGdsb2JhbFBsdWdpbnMpO1xuICAgICAgICBsZXQgcmVmaW5lcnMgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCBleHRyYSA9IHt9O1xuICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5pbmRleE9mKG9wdGlvbk5hbWUpID09PSAtMSAmJiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8IChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmXG4gICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0oY3VycmVudFJhd1tvcHRpb25OYW1lXSwgcmF3W29wdGlvbk5hbWVdKSkpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gY3VycmVudFJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICAgICAgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZy5wdXNoKC4uLnRoaXMub3B0aW9uc0ZvclJlZmluaW5nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSh2aWV3VHlwZSwgb3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdO1xuICAgICAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZpZXdUeXBlIFwiJHt2aWV3VHlwZX1cIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJlZmluZWRPcHRpb25zLCBleHRyYSB9ID0gdGhpcy5wcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLCBvcHRpb25zRGF0YS5sb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgdGhpcy5ub3dNYW5hZ2VyLmhhbmRsZUlucHV0KG9wdGlvbnNEYXRhLmRhdGVFbnYsIHJlZmluZWRPcHRpb25zLm5vdyk7XG4gICAgICAgIGxldCBkYXRlUHJvZmlsZUdlbmVyYXRvciA9IHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcih7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzLFxuICAgICAgICAgICAgbm93TWFuYWdlcjogdGhpcy5ub3dNYW5hZ2VyLFxuICAgICAgICAgICAgZHVyYXRpb246IHZpZXdTcGVjLmR1cmF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb25Vbml0OiB2aWV3U3BlYy5kdXJhdGlvblVuaXQsXG4gICAgICAgICAgICB1c2VzTWluTWF4VGltZTogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMudXNlc01pbk1heFRpbWUsXG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHRoaXMucHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBzbG90TWluVGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1pblRpbWUsXG4gICAgICAgICAgICBzbG90TWF4VGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1heFRpbWUsXG4gICAgICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiByZWZpbmVkT3B0aW9ucy5zaG93Tm9uQ3VycmVudERhdGVzLFxuICAgICAgICAgICAgZGF5Q291bnQ6IHJlZmluZWRPcHRpb25zLmRheUNvdW50LFxuICAgICAgICAgICAgZGF0ZUFsaWdubWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUFsaWdubWVudCxcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVJbmNyZW1lbnQsXG4gICAgICAgICAgICBoaWRkZW5EYXlzOiByZWZpbmVkT3B0aW9ucy5oaWRkZW5EYXlzLFxuICAgICAgICAgICAgd2Vla2VuZHM6IHJlZmluZWRPcHRpb25zLndlZWtlbmRzLFxuICAgICAgICAgICAgdmFsaWRSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52YWxpZFJhbmdlLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZpc2libGVSYW5nZSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiByZWZpbmVkT3B0aW9ucy5maXhlZFdlZWtDb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB2aWV3QXBpID0gdGhpcy5idWlsZFZpZXdBcGkodmlld1R5cGUsIHRoaXMuZ2V0Q3VycmVudERhdGEsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICByZXR1cm4geyB2aWV3U3BlYywgb3B0aW9uczogcmVmaW5lZE9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpIH07XG4gICAgfVxuICAgIHByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBWSUVXX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCByZWZpbmVkID0ge307XG4gICAgICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkO1xuICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCBjdXJyZW50UmF3W29wdGlvbk5hbWVdKSkpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSwgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uTmFtZSBpbiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkKSB7IC8vIG1pZ2h0IGJlIGFuIFwiZXh0cmFcIiBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gcmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHJhdztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXRlRW52JDEodGltZVpvbmUsIGV4cGxpY2l0TG9jYWxlLCB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIGZpcnN0RGF5LCB3ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApO1xuICAgIHJldHVybiBuZXcgRGF0ZUVudih7XG4gICAgICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsXG4gICAgICAgIHRpbWVab25lLFxuICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgICAgICAgZmlyc3REYXksXG4gICAgICAgIHdlZWtUZXh0LFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9ucywgcGx1Z2luSG9va3MpIHtcbiAgICBsZXQgVGhlbWVDbGFzcyA9IHBsdWdpbkhvb2tzLnRoZW1lQ2xhc3Nlc1tvcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICBsZXQgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgIHJldHVybiBuZXcgVmlld0ltcGwodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGV2ZW50U291cmNlLnVpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSkge1xuICAgIGxldCBldmVudFVpQmFzZXMgPSB7ICcnOiBldmVudFVpU2luZ2xlQmFzZSB9O1xuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50RGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnREZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5zb3VyY2VJZCAmJiBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgZXZlbnRVaUJhc2VzW2RlZklkXSA9IGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFVpQmFzZXM7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNhbGVuZGFyQ29udGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgICAgIC8vIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzIC8vIHJlbmRlciBob29rIHdpbGwgaGFuZGxlIHRoaXNcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuc2VsZWN0Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaXNMb2FkaW5nRnVuYyBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmlzTG9hZGluZ0Z1bmNzKSB7XG4gICAgICAgIGlmIChpc0xvYWRpbmdGdW5jKHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dC5vcHRpb25zLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyQ29udGV4dCk7XG59XG5mdW5jdGlvbiB3YXJuVW5rbm93bk9wdGlvbnMob3B0aW9ucywgdmlld05hbWUpIHtcbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIG9wdGlvbiAnJHtvcHRpb25OYW1lfSdgICtcbiAgICAgICAgICAgICh2aWV3TmFtZSA/IGAgZm9yIHZpZXcgJyR7dmlld05hbWV9J2AgOiAnJykpO1xuICAgIH1cbn1cblxuY2xhc3MgVG9vbGJhclNlY3Rpb24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcCgod2lkZ2V0R3JvdXApID0+IHRoaXMucmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgdGhlbWUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGxldCBpc09ubHlCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgd2lkZ2V0IG9mIHdpZGdldEdyb3VwKSB7XG4gICAgICAgICAgICBsZXQgeyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiwgYnV0dG9uSGludCB9ID0gd2lkZ2V0O1xuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiZmMtdG9vbGJhci10aXRsZVwiLCBpZDogcHJvcHMudGl0bGVJZCB9LCBwcm9wcy50aXRsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUHJlc3NlZCA9IGJ1dHRvbk5hbWUgPT09IHByb3BzLmFjdGl2ZUJ1dHRvbjtcbiAgICAgICAgICAgICAgICBsZXQgaXNEaXNhYmxlZCA9ICghcHJvcHMuaXNUb2RheUVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3RvZGF5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc1ByZXZFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICdwcmV2JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc05leHRFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1dHRvbkNsYXNzZXMgPSBbYGZjLSR7YnV0dG9uTmFtZX0tYnV0dG9uYCwgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygnYnV0dG9uQWN0aXZlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCB0aXRsZTogdHlwZW9mIGJ1dHRvbkhpbnQgPT09ICdmdW5jdGlvbicgPyBidXR0b25IaW50KHByb3BzLm5hdlVuaXQpIDogYnV0dG9uSGludCwgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsIFwiYXJpYS1wcmVzc2VkXCI6IGlzUHJlc3NlZCwgY2xhc3NOYW1lOiBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSwgb25DbGljazogYnV0dG9uQ2xpY2sgfSwgYnV0dG9uVGV4dCB8fCAoYnV0dG9uSWNvbiA/IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBidXR0b25JY29uLCByb2xlOiBcImltZ1wiIH0pIDogJycpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogZ3JvdXBDbGFzc05hbWUgfSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG59XG5cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG1vZGVsLCBleHRyYUNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGZvcmNlTHRyID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydENvbnRlbnQ7XG4gICAgICAgIGxldCBlbmRDb250ZW50O1xuICAgICAgICBsZXQgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcbiAgICAgICAgbGV0IGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAgICAgICAnZmMtdG9vbGJhcicsXG4gICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKGtleSwgd2lkZ2V0R3JvdXBzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVmlld0hhcm5lc3MgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGFzcGVjdFJhdGlvIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtdmlldy1oYXJuZXNzJyxcbiAgICAgICAgICAgIChhc3BlY3RSYXRpbyB8fCBwcm9wcy5saXF1aWQgfHwgcHJvcHMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgID8gJ2ZjLXZpZXctaGFybmVzcy1hY3RpdmUnIC8vIGhhcm5lc3MgY29udHJvbHMgdGhlIGhlaWdodFxuICAgICAgICAgICAgICAgIDogJ2ZjLXZpZXctaGFybmVzcy1wYXNzaXZlJywgLy8gbGV0IHRoZSB2aWV3IGRvIHRoZSBoZWlnaHRcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGhlaWdodCA9ICcnO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9ICcnO1xuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hdmFpbGFibGVXaWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHN0YXRlLmF2YWlsYWJsZVdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSB3YWl0aW5nIHRvIGtub3cgYXZhaWxhYmxlV2lkdGgsIHdlIGNhbid0IHNldCBoZWlnaHQgdG8gKnplcm8qXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3aWxsIGNhdXNlIGxvdHMgb2YgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycyB3aXRoaW4gc2Nyb2xsZ3JpZC5cbiAgICAgICAgICAgICAgICAvLyBCRVRURVI6IGRvbid0IHN0YXJ0IHJlbmRlcmluZyBBTllUSElORyB5ZXQgdW50aWwgd2Uga25vdyBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3aHkgbm90IGFsd2F5cyB1c2UgcGFkZGluZ0JvdHRvbT8gQ2F1c2VzIGhlaWdodCBvc2NpbGxhdGlvbiAoaXNzdWUgNTYwNilcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gYCR7KDEgLyBhc3BlY3RSYXRpbykgKiAxMDB9JWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHMubGFiZWxlZEJ5SWQsIHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0LCBwYWRkaW5nQm90dG9tIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgdXBkYXRlQXZhaWxhYmxlV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIC8vIG5lZWRlZC4gYnV0IHdoeT9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuYXNwZWN0UmF0aW8gLy8gYXNwZWN0UmF0aW8gaXMgdGhlIG9ubHkgaGVpZ2h0IHNldHRpbmcgdGhhdCBuZWVkcyBhdmFpbGFibGVXaWR0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBhdmFpbGFibGVXaWR0aDogdGhpcy5lbC5vZmZzZXRXaWR0aCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbmNsYXNzIEV2ZW50Q2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIGlmIChzZWcgJiYgLy8gbWlnaHQgYmUgdGhlIDxkaXY+IHN1cnJvdW5kaW5nIHRoZSBtb3JlIGxpbmtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gb3VyIHdheSB0byBzaW11bGF0ZSBhIGxpbmsgY2xpY2sgZm9yIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgPGE+IHRhZ3NcbiAgICAgICAgICAgICAgICAvLyBncmFiIGJlZm9yZSB0cmlnZ2VyIGZpcmVkIGluIGNhc2UgdHJpZ2dlciB0cmFzaGVzIERPTSB0aHJ1IHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgbGV0IGhhc1VybENvbnRhaW5lciA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgJy5mYy1ldmVudC1mb3JjZWQtdXJsJyk7XG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhhc1VybENvbnRhaW5lciA/IGhhc1VybENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhW2hyZWZdJykuaHJlZiA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbXBvbmVudC5jb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gbGlzdGVuQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJ2NsaWNrJywgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrKTtcbiAgICB9XG59XG5cbi8qXG5UcmlnZ2VycyBldmVudHMgYW5kIGFkZHMvcmVtb3ZlcyBjb3JlIGNsYXNzTmFtZXMgd2hlbiB0aGUgdXNlcidzIHBvaW50ZXJcbmVudGVycy9sZWF2ZXMgZXZlbnQtZWxlbWVudHMgb2YgYSBjb21wb25lbnQuXG4qL1xuY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIHRoaXMuY3VycmVudFNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyLCB0aGlzLmhhbmRsZVNlZ0xlYXZlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcbiAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDYWxlbmRhckNvbnRlbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdDb250ZXh0ID0gbWVtb2l6ZShidWlsZFZpZXdDb250ZXh0KTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzID0gbWVtb2l6ZShidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpO1xuICAgICAgICB0aGlzLmhlYWRlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmZvb3RlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlld0xhYmVsSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbXBvbmVudCBSZWdpc3RyYXRpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCk7XG4gICAgICAgICAgICBsZXQgREVGQVVMVF9JTlRFUkFDVElPTlMgPSBbXG4gICAgICAgICAgICAgICAgRXZlbnRDbGlja2luZyxcbiAgICAgICAgICAgICAgICBFdmVudEhvdmVyaW5nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQodGhpcy5wcm9wcy5wbHVnaW5Ib29rcy5jb21wb25lbnRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoKFRoZUludGVyYWN0aW9uQ2xhc3MpID0+IG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdID0gaW50ZXJhY3Rpb25zO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdID0gc2V0dGluZ3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNpemluZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7IC8vIHNob3VsZCB3aW5kb3cgcmVzaXplcyBiZSBjb25zaWRlcmVkIFwiZm9yY2VkXCIgP1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogdGhpcy5wcm9wcy52aWV3QXBpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIucmVxdWVzdChvcHRpb25zLndpbmRvd1Jlc2l6ZURlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLypcbiAgICByZW5kZXJzIElOU0lERSBvZiBhbiBvdXRlciBkaXZcbiAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHRvb2xiYXJDb25maWcsIG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdmlld1ZHcm93ID0gZmFsc2U7XG4gICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIGxldCB2aWV3QXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Vkdyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gb3B0aW9ucy5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KTsgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQocHJvcHMudmlld1NwZWMsIHByb3BzLnZpZXdBcGksIHByb3BzLm9wdGlvbnMsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5kYXRlRW52LCBwcm9wcy5ub3dNYW5hZ2VyLCBwcm9wcy50aGVtZSwgcHJvcHMucGx1Z2luSG9va3MsIHByb3BzLmRpc3BhdGNoLCBwcm9wcy5nZXRDdXJyZW50RGF0YSwgcHJvcHMuZW1pdHRlciwgcHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpO1xuICAgICAgICBsZXQgdmlld0xhYmVsSWQgPSAodG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgdG9vbGJhckNvbmZpZy5oZWFkZXIuaGFzVGl0bGUpXG4gICAgICAgICAgICA/IHRoaXMuc3RhdGUudmlld0xhYmVsSWRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuY3VycmVudERhdGUsIG5vd0RhdGUsIHByb3BzLnZpZXdUaXRsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0b29sYmFyQ29uZmlnLmhlYWRlciAmJiAoY3JlYXRlRWxlbWVudChUb29sYmFyLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZXh0cmFDbGFzc05hbWU6IFwiZmMtaGVhZGVyLXRvb2xiYXJcIiwgbW9kZWw6IHRvb2xiYXJDb25maWcuaGVhZGVyLCB0aXRsZUlkOiB2aWV3TGFiZWxJZCB9LCB0b29sYmFyUHJvcHMpKSksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVmlld0hhcm5lc3MsIHsgbGlxdWlkOiB2aWV3Vkdyb3csIGhlaWdodDogdmlld0hlaWdodCwgYXNwZWN0UmF0aW86IHZpZXdBc3BlY3RSYXRpbywgbGFiZWxlZEJ5SWQ6IHZpZXdMYWJlbElkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZEFwcGVuZENvbnRlbnQoKSksXG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJDb25maWcuZm9vdGVyICYmIChjcmVhdGVFbGVtZW50KFRvb2xiYXIsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMuZm9vdGVyUmVmLCBleHRyYUNsYXNzTmFtZTogXCJmYy1mb290ZXItdG9vbGJhclwiLCBtb2RlbDogdG9vbGJhckNvbmZpZy5mb290ZXIsIHRpdGxlSWQ6IFwiXCIgfSwgdG9vbGJhclByb3BzKSkpKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5jYWxlbmRhckludGVyYWN0aW9uc1xuICAgICAgICAgICAgLm1hcCgoQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKSA9PiBuZXcgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKHByb3BzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIGxldCB7IHByb3BTZXRIYW5kbGVycyB9ID0gcHJvcHMucGx1Z2luSG9va3M7XG4gICAgICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHByZXZQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5jbGVhcigpO1xuICAgICAgICBmb3IgKGxldCBpbnRlcmFjdGlvbiBvZiB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ191bm1vdW50Jyk7XG4gICAgfVxuICAgIGJ1aWxkQXBwZW5kQ29udGVudCgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHByb3BzLnBsdWdpbkhvb2tzLnZpZXdDb250YWluZXJBcHBlbmRzLm1hcCgoYnVpbGRBcHBlbmRDb250ZW50KSA9PiBidWlsZEFwcGVuZENvbnRlbnQocHJvcHMpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCAuLi5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJlbmRlclZpZXcocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyB2aWV3U3BlYyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB2aWV3UHJvcHMgPSB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcbiAgICAgICAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxuICAgICAgICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XG4gICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRUb29sYmFyUHJvcHModmlld1NwZWMsIGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgY3VycmVudERhdGUsIG5vdywgdGl0bGUpIHtcbiAgICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcbiAgICBsZXQgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXG4gICAgbGV0IHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIGxldCBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxuICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxuICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxuICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxuICAgIH07XG59XG4vLyBQbHVnaW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoKFRoZUNsYXNzKSA9PiBuZXcgVGhlQ2xhc3MoKSk7XG59XG5cbmNsYXNzIENhbGVuZGFyIGV4dGVuZHMgQ2FsZW5kYXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9uT3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCA9IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlQWN0aW9uID0gKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gYWN0aW9ucyB3ZSBrbm93IHdlIHdhbnQgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci50cnlEcmFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KGRhdGEuY2FsZW5kYXJPcHRpb25zLnJlcmVuZGVyRGVsYXkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHsgY3VycmVudERhdGEgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJSb290LCB7IG9wdGlvbnM6IGN1cnJlbnREYXRhLmNhbGVuZGFyT3B0aW9ucywgdGhlbWU6IGN1cnJlbnREYXRhLnRoZW1lLCBlbWl0dGVyOiBjdXJyZW50RGF0YS5lbWl0dGVyIH0sIChjbGFzc05hbWVzLCBoZWlnaHQsIGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySWQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChDYWxlbmRhckNvbnRlbnQsIE9iamVjdC5hc3NpZ24oeyBpc0hlaWdodEF1dG86IGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQ6IGZvclByaW50IH0sIGN1cnJlbnREYXRhKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1JlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbnN1cmVFbEhhc1N0eWxlcyhlbCk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QpO1xuICAgICAgICBuZXcgQ2FsZW5kYXJEYXRhTWFuYWdlcih7XG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcyxcbiAgICAgICAgICAgIG9uQWN0aW9uOiB0aGlzLmhhbmRsZUFjdGlvbixcbiAgICAgICAgICAgIG9uRGF0YTogdGhpcy5oYW5kbGVEYXRhLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgd2FzUmVuZGVyaW5nID0gdGhpcy5pc1JlbmRlcmluZztcbiAgICAgICAgaWYgKCF3YXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KCk7XG4gICAgICAgIGlmICh3YXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgIHN1cGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJhdGNoUmVuZGVyaW5nKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucGF1c2UoJ2JhdGNoUmVuZGVyaW5nJyk7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdiYXRjaFJlbmRlcmluZycpO1xuICAgIH1cbiAgICBwYXVzZVJlbmRlcmluZygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucGF1c2UoJ3BhdXNlUmVuZGVyaW5nJyk7XG4gICAgfVxuICAgIHJlc3VtZVJlbmRlcmluZygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdwYXVzZVJlbmRlcmluZycsIHRydWUpO1xuICAgIH1cbiAgICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIucmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzKSB7XG4gICAgICAgIGlmICghaXNBcnJheXNFcXVhbChjbGFzc05hbWVzLCB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSkge1xuICAgICAgICAgICAgbGV0IHsgY2xhc3NMaXN0IH0gPSB0aGlzLmVsO1xuICAgICAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIHRoaXMuY3VycmVudENsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgYXBwbHlTdHlsZVByb3AodGhpcy5lbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYob3B0aW9ucyk7XG4gICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICBsZXQgZGF0ZU1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZGF0ZUlucHV0KTtcbiAgICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGRhdGVNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudih0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyA/IG9wdGlvbnMgOiB7fSk7IC8vIHBhc3MgaW4gaWYgbm9uLW51bGwgb2JqZWN0XG4gICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICBsZXQgc3RhcnRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGxldCBlbmRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGVuZElucHV0KTtcbiAgICBpZiAoIXN0YXJ0TWV0YSB8fCAhZW5kTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHN0YXJ0TWV0YS5tYXJrZXIsIGVuZE1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YS5mb3JjZWRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YS5mb3JjZWRUem8sXG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBvcHRpb25zLmlzRW5kRXhjbHVzaXZlLFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiBCQVNFX09QVElPTl9ERUZBVUxUUy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IsXG4gICAgfSk7XG59XG4vLyBUT0RPOiBtb3JlIERSWSBhbmQgb3B0aW1pemVkXG5mdW5jdGlvbiBidWlsZERhdGVFbnYoc2V0dGluZ3MpIHtcbiAgICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIG9yZ2FuaXplUmF3TG9jYWxlcyhbXSkubWFwKTsgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHRpbWVab25lOiBCQVNFX09QVElPTl9ERUZBVUxUUy50aW1lWm9uZSwgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyB9LCBzZXR0aW5ncyksIHsgbG9jYWxlIH0pKTtcbn1cblxuLy8gSEVMUEVSU1xuLypcbmlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxueW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxuKi9cbmZ1bmN0aW9uIHNsaWNlRXZlbnRzKHByb3BzLCBhbGxEYXkpIHtcbiAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsKS5mZztcbn1cblxuY29uc3QgdmVyc2lvbiA9ICc2LjEuMTcnO1xuXG5leHBvcnQgeyBDYWxlbmRhciwgY3JlYXRlUGx1Z2luLCBmb3JtYXREYXRlLCBmb3JtYXRSYW5nZSwgZ2xvYmFsTG9jYWxlcywgZ2xvYmFsUGx1Z2lucywgc2xpY2VFdmVudHMsIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJtIiwibWVyZ2VQcm9wcyIsImciLCJndWlkIiwiaSIsImlzQXJyYXlzRXF1YWwiLCJUIiwiVGhlbWUiLCJhIiwibWFwSGFzaCIsIkIiLCJCYXNlQ29tcG9uZW50IiwiViIsIlZpZXdDb250ZXh0VHlwZSIsIkMiLCJDb250ZW50Q29udGFpbmVyIiwiYiIsImJ1aWxkVmlld0NsYXNzTmFtZXMiLCJjIiwiZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIiwiZCIsImNyZWF0ZUR1cmF0aW9uIiwiZSIsIkJBU0VfT1BUSU9OX0RFRkFVTFRTIiwiZiIsImFycmF5VG9IYXNoIiwiaCIsImZpbHRlckhhc2giLCJqIiwiYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIiwicCIsInBhcnNlRXZlbnRTb3VyY2UiLCJrIiwiZm9ybWF0V2l0aE9yZGluYWxzIiwidSIsInVucHJvbWlzaWZ5IiwibCIsImJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUiLCJuIiwiaWRlbnRpdHkiLCJyIiwicmVxdWVzdEpzb24iLCJzIiwic3VidHJhY3REdXJhdGlvbnMiLCJvIiwiaW50ZXJzZWN0UmFuZ2VzIiwicSIsInN0YXJ0T2ZEYXkiLCJ0IiwiYWRkRGF5cyIsInYiLCJoYXNoVmFsdWVzVG9BcnJheSIsInciLCJidWlsZEV2ZW50QXBpcyIsIkQiLCJEZWxheWVkUnVubmVyIiwieCIsImNyZWF0ZUZvcm1hdHRlciIsInkiLCJkaWZmV2hvbGVEYXlzIiwieiIsIm1lbW9pemUiLCJBIiwibWVtb2l6ZU9iakFyZyIsIkUiLCJpc1Byb3BzRXF1YWwiLCJGIiwiRW1pdHRlciIsIkciLCJyYW5nZUNvbnRhaW5zTWFya2VyIiwiSCIsImNyZWF0ZUVtcHR5RXZlbnRTdG9yZSIsIkkiLCJyZWR1Y2VFdmVudFN0b3JlIiwiSiIsInJlem9uZUV2ZW50U3RvcmVEYXRlcyIsIksiLCJtZXJnZVJhd09wdGlvbnMiLCJMIiwiQkFTRV9PUFRJT05fUkVGSU5FUlMiLCJNIiwiQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMiLCJOIiwiQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTIiwiTyIsIkNPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIiwiUCIsIlZJRVdfT1BUSU9OX1JFRklORVJTIiwiUSIsIkRhdGVFbnYiLCJSIiwiRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJTIiwiY3JlYXRlRXZlbnRVaSIsIlUiLCJwYXJzZUJ1c2luZXNzSG91cnMiLCJXIiwic2V0UmVmIiwiWCIsIkludGVyYWN0aW9uIiwiWSIsImdldEVsU2VnIiwiWiIsImVsZW1lbnRDbG9zZXN0IiwiXyIsIkV2ZW50SW1wbCIsIiQiLCJsaXN0ZW5CeVNlbGVjdG9yIiwiYTAiLCJsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciIsImExIiwiUHVyZUNvbXBvbmVudCIsImEyIiwiYnVpbGRWaWV3Q29udGV4dCIsImEzIiwiZ2V0VW5pcXVlRG9tSWQiLCJhNCIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsImE1IiwiaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIiwiYTYiLCJOb3dUaW1lciIsImE3IiwiQ2FsZW5kYXJJbXBsIiwiYTgiLCJmbHVzaFN5bmMiLCJhOSIsIkNhbGVuZGFyUm9vdCIsImFhIiwiUmVuZGVySWQiLCJhYiIsImVuc3VyZUVsSGFzU3R5bGVzIiwiYWMiLCJhcHBseVN0eWxlUHJvcCIsImFkIiwic2xpY2VFdmVudFN0b3JlIiwiYWUiLCJKc29uUmVxdWVzdEVycm9yIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZVJlZiIsIkZyYWdtZW50IiwicmVuZGVyIiwiZ2xvYmFsTG9jYWxlcyIsIk1JTklNQUxfUkFXX0VOX0xPQ0FMRSIsImNvZGUiLCJ3ZWVrIiwiZG93IiwiZG95IiwiZGlyZWN0aW9uIiwiYnV0dG9uVGV4dCIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJuZXh0WWVhciIsInllYXIiLCJ0b2RheSIsIm1vbnRoIiwiZGF5IiwibGlzdCIsIndlZWtUZXh0Iiwid2Vla1RleHRMb25nIiwiY2xvc2VIaW50IiwidGltZUhpbnQiLCJldmVudEhpbnQiLCJhbGxEYXlUZXh0IiwibW9yZUxpbmtUZXh0Iiwibm9FdmVudHNUZXh0IiwiUkFXX0VOX0xPQ0FMRSIsIk9iamVjdCIsImFzc2lnbiIsImJ1dHRvbkhpbnRzIiwidW5pdCIsInZpZXdIaW50IiwibmF2TGlua0hpbnQiLCJtb3JlTGlua0hpbnQiLCJldmVudENudCIsIm9yZ2FuaXplUmF3TG9jYWxlcyIsImV4cGxpY2l0UmF3TG9jYWxlcyIsImRlZmF1bHRDb2RlIiwibGVuZ3RoIiwiYWxsUmF3TG9jYWxlcyIsImNvbmNhdCIsInJhd0xvY2FsZU1hcCIsImVuIiwicmF3TG9jYWxlIiwibWFwIiwiYnVpbGRMb2NhbGUiLCJpbnB1dFNpbmd1bGFyIiwiYXZhaWxhYmxlIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VMb2NhbGUiLCJxdWVyeUxvY2FsZSIsImNvZGVBcmciLCJjb2RlcyIsInJhdyIsInF1ZXJ5UmF3TG9jYWxlIiwicGFydHMiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsInNwbGl0Iiwic2ltcGxlSWQiLCJzbGljZSIsImpvaW4iLCJtZXJnZWQiLCJzaW1wbGVOdW1iZXJGb3JtYXQiLCJJbnRsIiwiTnVtYmVyRm9ybWF0Iiwib3B0aW9ucyIsImNyZWF0ZVBsdWdpbiIsImlucHV0IiwiaWQiLCJuYW1lIiwicHJlbWl1bVJlbGVhc2VEYXRlIiwiRGF0ZSIsInVuZGVmaW5lZCIsImRlcHMiLCJyZWR1Y2VycyIsImlzTG9hZGluZ0Z1bmNzIiwiY29udGV4dEluaXQiLCJldmVudFJlZmluZXJzIiwiZXZlbnREZWZNZW1iZXJBZGRlcnMiLCJldmVudFNvdXJjZVJlZmluZXJzIiwiaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMiLCJldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyIsImV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyIsImRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMiLCJkYXRlUG9pbnRUcmFuc2Zvcm1zIiwiZGF0ZVNwYW5UcmFuc2Zvcm1zIiwidmlld3MiLCJ2aWV3UHJvcHNUcmFuc2Zvcm1lcnMiLCJpc1Byb3BzVmFsaWQiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJ2aWV3Q29udGFpbmVyQXBwZW5kcyIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwidGhlbWVDbGFzc2VzIiwiZXZlbnRTb3VyY2VEZWZzIiwiY21kRm9ybWF0dGVyIiwicmVjdXJyaW5nVHlwZXMiLCJuYW1lZFRpbWVab25lZEltcGwiLCJpbml0aWFsVmlldyIsImVsZW1lbnREcmFnZ2luZ0ltcGwiLCJvcHRpb25DaGFuZ2VIYW5kbGVycyIsInNjcm9sbEdyaWRJbXBsIiwibGlzdGVuZXJSZWZpbmVycyIsIm9wdGlvblJlZmluZXJzIiwicHJvcFNldEhhbmRsZXJzIiwiYnVpbGRQbHVnaW5Ib29rcyIsInBsdWdpbkRlZnMiLCJnbG9iYWxEZWZzIiwiY3VycmVudFBsdWdpbklkcyIsImhvb2tzIiwiYWRkRGVmcyIsImRlZnMiLCJkZWYiLCJwbHVnaW5OYW1lIiwiY3VycmVudElkIiwiY29tYmluZUhvb2tzIiwiY29uc29sZSIsIndhcm4iLCJidWlsZEJ1aWxkUGx1Z2luSG9va3MiLCJjdXJyZW50T3ZlcnJpZGVEZWZzIiwiY3VycmVudEdsb2JhbERlZnMiLCJjdXJyZW50SG9va3MiLCJvdmVycmlkZURlZnMiLCJob29rczAiLCJob29rczEiLCJjb21wYXJlT3B0aW9uYWxEYXRlcyIsImRhdGUwIiwiZGF0ZTEiLCJNYXRoIiwibWF4IiwidmFsdWVPZiIsIlN0YW5kYXJkVGhlbWUiLCJwcm90b3R5cGUiLCJjbGFzc2VzIiwicm9vdCIsInRhYmxlQ2VsbFNoYWRlZCIsImJ1dHRvbkdyb3VwIiwiYnV0dG9uIiwiYnV0dG9uQWN0aXZlIiwiYmFzZUljb25DbGFzcyIsImljb25DbGFzc2VzIiwiY2xvc2UiLCJydGxJY29uQ2xhc3NlcyIsImljb25PdmVycmlkZU9wdGlvbiIsImljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiIsImljb25PdmVycmlkZVByZWZpeCIsImNvbXBpbGVWaWV3RGVmcyIsImRlZmF1bHRDb25maWdzIiwib3ZlcnJpZGVDb25maWdzIiwiaGFzaCIsInZpZXdUeXBlIiwiZW5zdXJlVmlld0RlZiIsInZpZXdEZWYiLCJidWlsZFZpZXdEZWYiLCJkZWZhdWx0Q29uZmlnIiwib3ZlcnJpZGVDb25maWciLCJxdWVyeVByb3AiLCJ0aGVDb21wb25lbnQiLCJzdXBlclR5cGUiLCJzdXBlckRlZiIsIkVycm9yIiwiY29tcG9uZW50IiwidHlwZSIsImRlZmF1bHRzIiwicmF3T3B0aW9ucyIsIm92ZXJyaWRlcyIsInBhcnNlVmlld0NvbmZpZ3MiLCJpbnB1dHMiLCJwYXJzZVZpZXdDb25maWciLCJjb250ZW50IiwiY3JlYXRlVmlld0hvb2tDb21wb25lbnQiLCJ2aWV3UHJvcHMiLCJDb25zdW1lciIsImNvbnRleHQiLCJlbFRhZyIsImVsQ2xhc3NlcyIsInZpZXdTcGVjIiwicmVuZGVyUHJvcHMiLCJuZXh0RGF5VGhyZXNob2xkIiwiZ2VuZXJhdG9yTmFtZSIsImN1c3RvbUdlbmVyYXRvciIsImNsYXNzTmFtZUdlbmVyYXRvciIsImNsYXNzTmFtZXMiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwiYnVpbGRWaWV3U3BlY3MiLCJkZWZhdWx0SW5wdXRzIiwib3B0aW9uT3ZlcnJpZGVzIiwiZHluYW1pY09wdGlvbk92ZXJyaWRlcyIsImxvY2FsZURlZmF1bHRzIiwidmlld0RlZnMiLCJidWlsZFZpZXdTcGVjIiwiZHVyYXRpb25JbnB1dCIsImR1cmF0aW9uIiwiZHVyYXRpb25Vbml0Iiwic2luZ2xlVW5pdCIsInNpbmdsZVVuaXRPdmVycmlkZXMiLCJjcmVhdGVEdXJhdGlvbkNhY2hlZCIsImRlbm9tIiwidmFsdWUiLCJxdWVyeUJ1dHRvblRleHQiLCJvcHRpb25zU3Vic2V0IiwiYnV0dG9uVGV4dE1hcCIsImJ1dHRvblRleHRLZXkiLCJxdWVyeUJ1dHRvblRpdGxlIiwiYnV0dG9uS2V5Iiwib3B0aW9uRGVmYXVsdHMiLCJidXR0b25UZXh0T3ZlcnJpZGUiLCJidXR0b25UZXh0RGVmYXVsdCIsImJ1dHRvblRpdGxlT3ZlcnJpZGUiLCJidXR0b25IaW50IiwiYnV0dG9uVGl0bGVEZWZhdWx0IiwiZHVyYXRpb25JbnB1dE1hcCIsImpzb24iLCJKU09OIiwic3RyaW5naWZ5IiwicmVzIiwicmVkdWNlVmlld1R5cGUiLCJhY3Rpb24iLCJyZWR1Y2VDdXJyZW50RGF0ZSIsImN1cnJlbnREYXRlIiwiZGF0ZU1hcmtlciIsImdldEluaXRpYWxEYXRlIiwiZGF0ZUVudiIsIm5vd01hbmFnZXIiLCJpbml0aWFsRGF0ZUlucHV0IiwiaW5pdGlhbERhdGUiLCJjcmVhdGVNYXJrZXIiLCJnZXREYXRlTWFya2VyIiwicmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsInJlZHVjZURhdGVQcm9maWxlIiwiY3VycmVudERhdGVQcm9maWxlIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJkcCIsImJ1aWxkIiwiYnVpbGRQcmV2IiwiaXNWYWxpZCIsImJ1aWxkTmV4dCIsImluaXRFdmVudFNvdXJjZXMiLCJjYWxlbmRhck9wdGlvbnMiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiYWRkU291cmNlcyIsInBhcnNlSW5pdGlhbFNvdXJjZXMiLCJyZWR1Y2VFdmVudFNvdXJjZXMiLCJldmVudFNvdXJjZXMiLCJzb3VyY2VzIiwicmVtb3ZlU291cmNlIiwic291cmNlSWQiLCJmZXRjaERpcnR5U291cmNlcyIsImZldGNoU291cmNlc0J5SWRzIiwic291cmNlSWRzIiwiZXhjbHVkZVN0YXRpY1NvdXJjZXMiLCJpc1JlZmV0Y2giLCJyZWNlaXZlUmVzcG9uc2UiLCJmZXRjaElkIiwiZmV0Y2hSYW5nZSIsInJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lIiwiY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmciLCJpc0ZldGNoaW5nIiwiZXZlbnRTb3VyY2VIYXNoIiwic291cmNlIiwiZXZlbnRTb3VyY2UiLCJzb3VyY2VIYXNoIiwiaXNTb3VyY2VEaXJ0eSIsImRvZXNTb3VyY2VOZWVkUmFuZ2UiLCJsYXRlc3RGZXRjaElkIiwibGF6eUZldGNoaW5nIiwic3RhcnQiLCJlbmQiLCJwcmV2U291cmNlcyIsInNvdXJjZUlkSGFzaCIsIm5leHRTb3VyY2VzIiwiZmV0Y2hTb3VyY2UiLCJjYWxlbmRhckFwaSIsInNvdXJjZURlZiIsInBsdWdpbkhvb2tzIiwic291cmNlRGVmSWQiLCJmZXRjaCIsInJhbmdlIiwicmF3RXZlbnRzIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiY2FsbCIsInJlc3BvbnNlIiwic3VjY2VzcyIsImRpc3BhdGNoIiwiZXJyb3IiLCJlcnJvckhhbmRsZWQiLCJldmVudFNvdXJjZUZhaWx1cmUiLCJmYWlsdXJlIiwibWVzc2FnZSIsInJlZmluZXJzIiwicmF3U291cmNlcyIsImluaXRpYWxFdmVudHMiLCJ1bnNoaWZ0IiwiZXZlbnRzIiwicmF3U291cmNlIiwicHVzaCIsImlnbm9yZVJhbmdlIiwicmVkdWNlRGF0ZVNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJyZWR1Y2VFdmVudERyYWciLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJzdGF0ZSIsImFmZmVjdGVkRXZlbnRzIiwibXV0YXRlZEV2ZW50cyIsImlzRXZlbnQiLCJyZWR1Y2VFdmVudFJlc2l6ZSIsImN1cnJlbnRSZXNpemUiLCJuZXdSZXNpemUiLCJwYXJzZVRvb2xiYXJzIiwiY2FsZW5kYXJPcHRpb25PdmVycmlkZXMiLCJ0aGVtZSIsInZpZXdTcGVjcyIsImhlYWRlciIsImhlYWRlclRvb2xiYXIiLCJwYXJzZVRvb2xiYXIiLCJmb290ZXIiLCJmb290ZXJUb29sYmFyIiwic2VjdGlvblN0ckhhc2giLCJzZWN0aW9uV2lkZ2V0cyIsInZpZXdzV2l0aEJ1dHRvbnMiLCJoYXNUaXRsZSIsInNlY3Rpb25OYW1lIiwic2VjdGlvblN0ciIsInNlY3Rpb25SZXMiLCJwYXJzZVNlY3Rpb24iLCJ3aWRnZXRzIiwiaXNSdGwiLCJjYWxlbmRhckN1c3RvbUJ1dHRvbnMiLCJjdXN0b21CdXR0b25zIiwiY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25UZXh0IiwiY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25IaW50cyIsInNlY3Rpb25TdWJzdHJzIiwiYnV0dG9uR3JvdXBTdHIiLCJidXR0b25OYW1lIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJidXR0b25DbGljayIsImJ1dHRvbkljb24iLCJldiIsImNsaWNrIiwidGFyZ2V0IiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiZ2V0SWNvbkNsYXNzIiwidGV4dCIsImhpbnQiLCJjaGFuZ2VWaWV3IiwidGV4dEZhbGxiYWNrIiwicHJldk9yTmV4dCIsIm5hdlVuaXQiLCJWaWV3SW1wbCIsImNvbnN0cnVjdG9yIiwiZ2V0Q3VycmVudERhdGEiLCJjYWxlbmRhciIsInRpdGxlIiwidmlld1RpdGxlIiwiYWN0aXZlU3RhcnQiLCJ0b0RhdGUiLCJhY3RpdmVFbmQiLCJjdXJyZW50U3RhcnQiLCJjdXJyZW50UmFuZ2UiLCJjdXJyZW50RW5kIiwiZ2V0T3B0aW9uIiwiZXZlbnRTb3VyY2VEZWYkMiIsInBhcnNlTWV0YSIsInJlZmluZWQiLCJhcmciLCJzdWNjZXNzQ2FsbGJhY2siLCJtZXRhIiwiYXJyYXlFdmVudFNvdXJjZVBsdWdpbiIsImV2ZW50U291cmNlRGVmJDEiLCJlcnJvckNhbGxiYWNrIiwiZnVuYyIsImJpbmQiLCJmdW5jRXZlbnRTb3VyY2VQbHVnaW4iLCJKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTIiwibWV0aG9kIiwiU3RyaW5nIiwiZXh0cmFQYXJhbXMiLCJzdGFydFBhcmFtIiwiZW5kUGFyYW0iLCJ0aW1lWm9uZVBhcmFtIiwiZXZlbnRTb3VyY2VEZWYiLCJ1cmwiLCJmb3JtYXQiLCJ0b1VwcGVyQ2FzZSIsInJlcXVlc3RQYXJhbXMiLCJidWlsZFJlcXVlc3RQYXJhbXMiLCJ0aGVuIiwianNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiIsImN1c3RvbVJlcXVlc3RQYXJhbXMiLCJwYXJhbXMiLCJmb3JtYXRJc28iLCJ0aW1lWm9uZSIsIlNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMiLCJkYXlzT2ZXZWVrIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInN0YXJ0UmVjdXIiLCJlbmRSZWN1ciIsInJlY3VycmluZyIsInBhcnNlIiwicmVjdXJyaW5nRGF0YSIsImFsbERheUd1ZXNzIiwiQm9vbGVhbiIsInR5cGVEYXRhIiwiZXhwYW5kIiwiZnJhbWluZ1JhbmdlIiwiY2xpcHBlZEZyYW1pbmdSYW5nZSIsImV4cGFuZFJhbmdlcyIsInNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiIsImV2ZW50RGF0ZUVudiIsImNhbGVuZGFyRGF0ZUVudiIsImRvd0hhc2giLCJkYXlNYXJrZXIiLCJlbmRNYXJrZXIiLCJpbnN0YW5jZVN0YXJ0cyIsImluc3RhbmNlU3RhcnQiLCJnZXRVVENEYXkiLCJhZGQiLCJjaGFuZ2VIYW5kbGVyUGx1Z2luIiwiaGFuZGxlRXZlbnRTb3VyY2VzIiwidW5mb3VuZFNvdXJjZXMiLCJfcmF3IiwibmV3SW5wdXRzIiwiaW5wdXRGb3VuZCIsInNwbGljZSIsInVuZm91bmRTb3VyY2UiLCJuZXdJbnB1dCIsImFkZEV2ZW50U291cmNlIiwiaGFuZGxlRGF0ZVByb2ZpbGUiLCJlbWl0dGVyIiwidHJpZ2dlciIsInZpZXciLCJ2aWV3QXBpIiwiaGFuZGxlRXZlbnRTdG9yZSIsImV2ZW50U3RvcmUiLCJoYXNIYW5kbGVycyIsImdsb2JhbFBsdWdpbnMiLCJUYXNrUnVubmVyIiwicnVuVGFza09wdGlvbiIsImRyYWluZWRPcHRpb24iLCJxdWV1ZSIsImRlbGF5ZWRSdW5uZXIiLCJkcmFpbiIsInJlcXVlc3QiLCJ0YXNrIiwiZGVsYXkiLCJwYXVzZSIsInNjb3BlIiwicmVzdW1lIiwiZm9yY2UiLCJjb21wbGV0ZWRUYXNrcyIsInNoaWZ0IiwicnVuVGFzayIsImRyYWluZWQiLCJidWlsZFRpdGxlIiwidmlld09wdGlvbnMiLCJ0ZXN0IiwiY3VycmVudFJhbmdlVW5pdCIsImZvcm1hdFJhbmdlIiwidGl0bGVGb3JtYXQiLCJidWlsZFRpdGxlRm9ybWF0IiwiaXNFbmRFeGNsdXNpdmUiLCJpc1JhbmdlQWxsRGF5IiwiZGVmYXVsdFNlcGFyYXRvciIsInRpdGxlUmFuZ2VTZXBhcmF0b3IiLCJkYXlzIiwiQ2FsZW5kYXJOb3dNYW5hZ2VyIiwicmVzZXRMaXN0ZW5lcnMiLCJTZXQiLCJoYW5kbGVJbnB1dCIsIm5vd0lucHV0Iiwib2xkRGF0ZUVudiIsIm5vd0ZuIiwibm93QW5jaG9yRGF0ZSIsImNyZWF0ZU5vd01hcmtlciIsIm5vd0FuY2hvclF1ZXJpZWQiLCJub3ciLCJyZXNldExpc3RlbmVyIiwidmFsdWVzIiwidGltZXN0YW1wVG9NYXJrZXIiLCJhZGRSZXNldExpc3RlbmVyIiwiaGFuZGxlciIsInJlbW92ZVJlc2V0TGlzdGVuZXIiLCJkZWxldGUiLCJDYWxlbmRhckRhdGFNYW5hZ2VyIiwicHJvcHMiLCJjb21wdXRlQ3VycmVudFZpZXdEYXRhIiwiX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJidWlsZERhdGVFbnYiLCJidWlsZERhdGVFbnYkMSIsImJ1aWxkVGhlbWUiLCJidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRWaWV3QXBpIiwiYnVpbGRWaWV3VWlQcm9wcyIsImJ1aWxkRXZlbnRVaUJ5U291cmNlIiwiYnVpbGRFdmVudFVpQmFzZXMiLCJwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzIiwiYWN0aW9uUnVubmVyIiwiX2hhbmRsZUFjdGlvbiIsInVwZGF0ZURhdGEiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCIsImN1cnJlbnRWaWV3T3B0aW9uc0lucHV0IiwiY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyIsIm9wdGlvbnNGb3JSZWZpbmluZyIsIm9wdGlvbnNGb3JIYW5kbGluZyIsImRhdGEiLCJvcHRpb25zRGF0YSIsImNvbXB1dGVPcHRpb25zRGF0YSIsImN1cnJlbnRWaWV3VHlwZSIsImN1cnJlbnRWaWV3RGF0YSIsImN1cnJlbnREYXRhTWFuYWdlciIsInNldFRoaXNDb250ZXh0Iiwic2V0T3B0aW9ucyIsImNhbGVuZGFyQ29udGV4dCIsImNhbGxiYWNrIiwiaW5pdGlhbFN0YXRlIiwiYnVzaW5lc3NIb3VycyIsImV2ZW50VWlCYXNlcyIsInJlbmRlcmFibGVFdmVudFN0b3JlIiwiZGF0ZVNlbGVjdGlvbiIsImV2ZW50U2VsZWN0aW9uIiwiZXZlbnREcmFnIiwiZXZlbnRSZXNpemUiLCJzZWxlY3Rpb25Db25maWciLCJjb250ZXh0QW5kU3RhdGUiLCJyZWR1Y2VyIiwiY29tcHV0ZUlzTG9hZGluZyIsInJlc2V0T3B0aW9ucyIsImNoYW5nZWRPcHRpb25OYW1lcyIsImlzRXZlbnRzTG9hZGluZyIsInByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmciLCJldmVudFVpU2luZ2xlQmFzZSIsImV2ZW50VWlCeVNvdXJjZSIsIm5ld1N0YXRlIiwid2FzTG9hZGluZyIsImlzTG9hZGluZyIsIm9uQWN0aW9uIiwib2xkRGF0YSIsImNoYW5nZUhhbmRsZXJzIiwib2xkQ2FsZW5kYXJPcHRpb25zIiwibmV3Q2FsZW5kYXJPcHRpb25zIiwiaW5kZXhPZiIsIm9uRGF0YSIsInN0YWJsZU9wdGlvbk92ZXJyaWRlcyIsInN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJzdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhIiwicmVmaW5lZE9wdGlvbnMiLCJhdmFpbGFibGVMb2NhbGVEYXRhIiwiZXh0cmEiLCJwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zIiwid2FyblVua25vd25PcHRpb25zIiwibG9jYWxlIiwid2Vla051bWJlckNhbGN1bGF0aW9uIiwiZmlyc3REYXkiLCJkZWZhdWx0UmFuZ2VTZXBhcmF0b3IiLCJ0b29sYmFyQ29uZmlnIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsImxvY2FsZXMiLCJwbHVnaW5zIiwiY3VycmVudFJhdyIsImN1cnJlbnRSZWZpbmVkIiwiYW55Q2hhbmdlcyIsInByb2Nlc3NSYXdWaWV3T3B0aW9ucyIsImRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJ1c2VzTWluTWF4VGltZSIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJzaG93Tm9uQ3VycmVudERhdGVzIiwiZGF5Q291bnQiLCJkYXRlQWxpZ25tZW50IiwiZGF0ZUluY3JlbWVudCIsImhpZGRlbkRheXMiLCJ3ZWVrZW5kcyIsInZhbGlkUmFuZ2VJbnB1dCIsInZhbGlkUmFuZ2UiLCJ2aXNpYmxlUmFuZ2VJbnB1dCIsInZpc2libGVSYW5nZSIsImZpeGVkV2Vla0NvdW50IiwiZXhwbGljaXRMb2NhbGUiLCJjYWxlbmRhclN5c3RlbSIsIm5hbWVkVGltZVpvbmVJbXBsIiwiVGhlbWVDbGFzcyIsInRoZW1lU3lzdGVtIiwiRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVpIiwiZXZlbnREZWZzIiwiZGVmSWQiLCJkaXNwbGF5IiwiZXZlbnREaXNwbGF5IiwiZWRpdGFibGUiLCJzdGFydEVkaXRhYmxlIiwiZXZlbnRTdGFydEVkaXRhYmxlIiwiZHVyYXRpb25FZGl0YWJsZSIsImV2ZW50RHVyYXRpb25FZGl0YWJsZSIsImNvbnN0cmFpbnQiLCJldmVudENvbnN0cmFpbnQiLCJvdmVybGFwIiwiZXZlbnRPdmVybGFwIiwiYWxsb3ciLCJldmVudEFsbG93IiwiYmFja2dyb3VuZENvbG9yIiwiZXZlbnRCYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImV2ZW50Qm9yZGVyQ29sb3IiLCJ0ZXh0Q29sb3IiLCJldmVudFRleHRDb2xvciIsImNvbG9yIiwiZXZlbnRDb2xvciIsInNlbGVjdENvbnN0cmFpbnQiLCJzZWxlY3RPdmVybGFwIiwic2VsZWN0QWxsb3ciLCJpc0xvYWRpbmdGdW5jIiwidmlld05hbWUiLCJUb29sYmFyU2VjdGlvbiIsImNoaWxkcmVuIiwid2lkZ2V0R3JvdXBzIiwid2lkZ2V0R3JvdXAiLCJyZW5kZXJXaWRnZXRHcm91cCIsImNsYXNzTmFtZSIsImlzT25seUJ1dHRvbnMiLCJ3aWRnZXQiLCJ0aXRsZUlkIiwiaXNQcmVzc2VkIiwiYWN0aXZlQnV0dG9uIiwiaXNEaXNhYmxlZCIsImlzVG9kYXlFbmFibGVkIiwiaXNQcmV2RW5hYmxlZCIsImlzTmV4dEVuYWJsZWQiLCJidXR0b25DbGFzc2VzIiwiZ2V0Q2xhc3MiLCJkaXNhYmxlZCIsIm9uQ2xpY2siLCJyb2xlIiwiZ3JvdXBDbGFzc05hbWUiLCJUb29sYmFyIiwibW9kZWwiLCJleHRyYUNsYXNzTmFtZSIsImZvcmNlTHRyIiwic3RhcnRDb250ZW50IiwiZW5kQ29udGVudCIsImNlbnRlckNvbnRlbnQiLCJjZW50ZXIiLCJsZWZ0IiwicmlnaHQiLCJyZW5kZXJTZWN0aW9uIiwia2V5IiwiVmlld0hhcm5lc3MiLCJhcmd1bWVudHMiLCJhdmFpbGFibGVXaWR0aCIsImhhbmRsZUVsIiwiZWwiLCJlbFJlZiIsInVwZGF0ZUF2YWlsYWJsZVdpZHRoIiwiaGFuZGxlUmVzaXplIiwiYXNwZWN0UmF0aW8iLCJsaXF1aWQiLCJoZWlnaHQiLCJwYWRkaW5nQm90dG9tIiwibGFiZWxlZEJ5SWQiLCJyZWYiLCJzdHlsZSIsImNvbXBvbmVudERpZE1vdW50IiwiYWRkUmVzaXplSGFuZGxlciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlUmVzaXplSGFuZGxlciIsInNldFN0YXRlIiwib2Zmc2V0V2lkdGgiLCJFdmVudENsaWNraW5nIiwic2V0dGluZ3MiLCJoYW5kbGVTZWdDbGljayIsInNlZ0VsIiwic2VnIiwiaXNWYWxpZFNlZ0Rvd25FbCIsImhhc1VybENvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZXZlbnQiLCJldmVudFJhbmdlIiwiaW5zdGFuY2UiLCJqc0V2ZW50IiwiZGVmYXVsdFByZXZlbnRlZCIsIndpbmRvdyIsImxvY2F0aW9uIiwiZGVzdHJveSIsIkV2ZW50SG92ZXJpbmciLCJoYW5kbGVFdmVudEVsUmVtb3ZlIiwiY3VycmVudFNlZ0VsIiwiaGFuZGxlU2VnTGVhdmUiLCJoYW5kbGVTZWdFbnRlciIsInRyaWdnZXJFdmVudCIsInJlbW92ZUhvdmVyTGlzdGVuZXJzIiwicHVibGljRXZOYW1lIiwiQ2FsZW5kYXJDb250ZW50IiwiYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyIsImJ1aWxkVG9vbGJhclByb3BzIiwiaGVhZGVyUmVmIiwiZm9vdGVyUmVmIiwiaW50ZXJhY3Rpb25zU3RvcmUiLCJ2aWV3TGFiZWxJZCIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJzZXR0aW5nc0lucHV0IiwiREVGQVVMVF9JTlRFUkFDVElPTlMiLCJpbnRlcmFjdGlvbkNsYXNzZXMiLCJpbnRlcmFjdGlvbnMiLCJUaGVJbnRlcmFjdGlvbkNsYXNzIiwidWlkIiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwibGlzdGVuZXJzIiwibGlzdGVuZXIiLCJyZXNpemVSdW5uZXIiLCJoYW5kbGVXaW5kb3dSZXNpemUiLCJ3aW5kb3dSZXNpemVEZWxheSIsInZpZXdWR3JvdyIsInZpZXdIZWlnaHQiLCJ2aWV3QXNwZWN0UmF0aW8iLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsImNvbnRlbnRIZWlnaHQiLCJ2aWV3Q29udGV4dCIsIlByb3ZpZGVyIiwibm93RGF0ZSIsInRvb2xiYXJQcm9wcyIsInJlbmRlclZpZXciLCJidWlsZEFwcGVuZENvbnRlbnQiLCJDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MiLCJhZGRFdmVudExpc3RlbmVyIiwicHJvcE5hbWUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXIiLCJpbnRlcmFjdGlvbiIsInRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVyIiwidHJhbnNmb3JtIiwiVmlld0NvbXBvbmVudCIsInRvZGF5SW5mbyIsInByZXZJbmZvIiwibmV4dEluZm8iLCJ0aGVDbGFzc2VzIiwiVGhlQ2xhc3MiLCJDYWxlbmRhciIsImlzUmVuZGVyaW5nIiwiaXNSZW5kZXJlZCIsImN1cnJlbnRDbGFzc05hbWVzIiwiY3VzdG9tQ29udGVudFJlbmRlcklkIiwiaGFuZGxlQWN0aW9uIiwicmVuZGVyUnVubmVyIiwidHJ5RHJhaW4iLCJoYW5kbGVEYXRhIiwiY3VycmVudERhdGEiLCJyZXJlbmRlckRlbGF5IiwiaGFuZGxlUmVuZGVyUmVxdWVzdCIsInNldENsYXNzTmFtZXMiLCJzZXRIZWlnaHQiLCJ3YXNSZW5kZXJpbmciLCJ1cGRhdGVTaXplIiwiYmF0Y2hSZW5kZXJpbmciLCJwYXVzZVJlbmRlcmluZyIsInJlc3VtZVJlbmRlcmluZyIsImNsYXNzTGlzdCIsInJlbW92ZSIsImZvcm1hdERhdGUiLCJkYXRlSW5wdXQiLCJmb3JtYXR0ZXIiLCJkYXRlTWV0YSIsImNyZWF0ZU1hcmtlck1ldGEiLCJtYXJrZXIiLCJmb3JjZWRUem8iLCJzdGFydElucHV0IiwiZW5kSW5wdXQiLCJzdGFydE1ldGEiLCJlbmRNZXRhIiwiZm9yY2VkU3RhcnRUem8iLCJmb3JjZWRFbmRUem8iLCJzbGljZUV2ZW50cyIsImFsbERheSIsImZnIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/core/internal-common.js":
/*!************************************************************!*\
  !*** ./node_modules/@fullcalendar/core/internal-common.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ listenBySelector),\n/* harmony export */   A: () => (/* binding */ memoizeObjArg),\n/* harmony export */   B: () => (/* binding */ BaseComponent),\n/* harmony export */   C: () => (/* binding */ ContentContainer),\n/* harmony export */   D: () => (/* binding */ DelayedRunner),\n/* harmony export */   E: () => (/* binding */ isPropsEqual),\n/* harmony export */   F: () => (/* binding */ Emitter),\n/* harmony export */   G: () => (/* binding */ rangeContainsMarker),\n/* harmony export */   H: () => (/* binding */ createEmptyEventStore),\n/* harmony export */   I: () => (/* binding */ reduceEventStore),\n/* harmony export */   J: () => (/* binding */ rezoneEventStoreDates),\n/* harmony export */   K: () => (/* binding */ mergeRawOptions),\n/* harmony export */   L: () => (/* binding */ BASE_OPTION_REFINERS),\n/* harmony export */   M: () => (/* binding */ CALENDAR_LISTENER_REFINERS),\n/* harmony export */   N: () => (/* binding */ CALENDAR_OPTION_REFINERS),\n/* harmony export */   O: () => (/* binding */ COMPLEX_OPTION_COMPARATORS),\n/* harmony export */   P: () => (/* binding */ VIEW_OPTION_REFINERS),\n/* harmony export */   Q: () => (/* binding */ DateEnv),\n/* harmony export */   R: () => (/* binding */ DateProfileGenerator),\n/* harmony export */   S: () => (/* binding */ createEventUi),\n/* harmony export */   T: () => (/* binding */ Theme),\n/* harmony export */   U: () => (/* binding */ parseBusinessHours),\n/* harmony export */   V: () => (/* binding */ ViewContextType),\n/* harmony export */   W: () => (/* binding */ setRef),\n/* harmony export */   X: () => (/* binding */ Interaction),\n/* harmony export */   Y: () => (/* binding */ getElSeg),\n/* harmony export */   Z: () => (/* binding */ elementClosest),\n/* harmony export */   _: () => (/* binding */ EventImpl),\n/* harmony export */   a: () => (/* binding */ mapHash),\n/* harmony export */   a$: () => (/* binding */ preventDefault),\n/* harmony export */   a0: () => (/* binding */ listenToHoverBySelector),\n/* harmony export */   a1: () => (/* binding */ PureComponent),\n/* harmony export */   a2: () => (/* binding */ buildViewContext),\n/* harmony export */   a3: () => (/* binding */ getUniqueDomId),\n/* harmony export */   a4: () => (/* binding */ parseInteractionSettings),\n/* harmony export */   a5: () => (/* binding */ interactionSettingsStore),\n/* harmony export */   a6: () => (/* binding */ NowTimer),\n/* harmony export */   a7: () => (/* binding */ CalendarImpl),\n/* harmony export */   a8: () => (/* binding */ flushSync),\n/* harmony export */   a9: () => (/* binding */ CalendarRoot),\n/* harmony export */   aA: () => (/* binding */ memoizeArraylike),\n/* harmony export */   aB: () => (/* binding */ memoizeHashlike),\n/* harmony export */   aC: () => (/* binding */ intersectRects),\n/* harmony export */   aD: () => (/* binding */ pointInsideRect),\n/* harmony export */   aE: () => (/* binding */ constrainPoint),\n/* harmony export */   aF: () => (/* binding */ getRectCenter),\n/* harmony export */   aG: () => (/* binding */ diffPoints),\n/* harmony export */   aH: () => (/* binding */ translateRect),\n/* harmony export */   aI: () => (/* binding */ compareObjs),\n/* harmony export */   aJ: () => (/* binding */ collectFromHash),\n/* harmony export */   aK: () => (/* binding */ findElements),\n/* harmony export */   aL: () => (/* binding */ findDirectChildren),\n/* harmony export */   aM: () => (/* binding */ removeElement),\n/* harmony export */   aN: () => (/* binding */ applyStyle),\n/* harmony export */   aO: () => (/* binding */ elementMatches),\n/* harmony export */   aP: () => (/* binding */ getEventTargetViaRoot),\n/* harmony export */   aQ: () => (/* binding */ parseClassNames),\n/* harmony export */   aR: () => (/* binding */ getCanVGrowWithinCell),\n/* harmony export */   aS: () => (/* binding */ mergeEventStores),\n/* harmony export */   aT: () => (/* binding */ getRelevantEvents),\n/* harmony export */   aU: () => (/* binding */ eventTupleToStore),\n/* harmony export */   aV: () => (/* binding */ combineEventUis),\n/* harmony export */   aW: () => (/* binding */ Splitter),\n/* harmony export */   aX: () => (/* binding */ getDayClassNames),\n/* harmony export */   aY: () => (/* binding */ getDateMeta),\n/* harmony export */   aZ: () => (/* binding */ getSlotClassNames),\n/* harmony export */   a_: () => (/* binding */ buildNavLinkAttrs),\n/* harmony export */   aa: () => (/* binding */ RenderId),\n/* harmony export */   ab: () => (/* binding */ ensureElHasStyles),\n/* harmony export */   ac: () => (/* binding */ applyStyleProp),\n/* harmony export */   ad: () => (/* binding */ sliceEventStore),\n/* harmony export */   ae: () => (/* binding */ JsonRequestError),\n/* harmony export */   af: () => (/* binding */ createContext),\n/* harmony export */   ag: () => (/* binding */ refineProps),\n/* harmony export */   ah: () => (/* binding */ createEventInstance),\n/* harmony export */   ai: () => (/* binding */ parseEventDef),\n/* harmony export */   aj: () => (/* binding */ refineEventDef),\n/* harmony export */   ak: () => (/* binding */ padStart),\n/* harmony export */   al: () => (/* binding */ isInt),\n/* harmony export */   am: () => (/* binding */ parseFieldSpecs),\n/* harmony export */   an: () => (/* binding */ compareByFieldSpecs),\n/* harmony export */   ao: () => (/* binding */ flexibleCompare),\n/* harmony export */   ap: () => (/* binding */ preventSelection),\n/* harmony export */   aq: () => (/* binding */ allowSelection),\n/* harmony export */   ar: () => (/* binding */ preventContextMenu),\n/* harmony export */   as: () => (/* binding */ allowContextMenu),\n/* harmony export */   at: () => (/* binding */ compareNumbers),\n/* harmony export */   au: () => (/* binding */ enableCursor),\n/* harmony export */   av: () => (/* binding */ disableCursor),\n/* harmony export */   aw: () => (/* binding */ computeVisibleDayRange),\n/* harmony export */   ax: () => (/* binding */ isMultiDayRange),\n/* harmony export */   ay: () => (/* binding */ diffDates),\n/* harmony export */   az: () => (/* binding */ removeExact),\n/* harmony export */   b: () => (/* binding */ buildViewClassNames),\n/* harmony export */   b$: () => (/* binding */ renderMicroColGroup),\n/* harmony export */   b0: () => (/* binding */ whenTransitionDone),\n/* harmony export */   b1: () => (/* binding */ computeInnerRect),\n/* harmony export */   b2: () => (/* binding */ computeEdges),\n/* harmony export */   b3: () => (/* binding */ getClippingParents),\n/* harmony export */   b4: () => (/* binding */ computeRect),\n/* harmony export */   b5: () => (/* binding */ rangesEqual),\n/* harmony export */   b6: () => (/* binding */ rangesIntersect),\n/* harmony export */   b7: () => (/* binding */ rangeContainsRange),\n/* harmony export */   b8: () => (/* binding */ PositionCache),\n/* harmony export */   b9: () => (/* binding */ ScrollController),\n/* harmony export */   bA: () => (/* binding */ getEntrySpanEnd),\n/* harmony export */   bB: () => (/* binding */ binarySearch),\n/* harmony export */   bC: () => (/* binding */ groupIntersectingEntries),\n/* harmony export */   bD: () => (/* binding */ intersectSpans),\n/* harmony export */   bE: () => (/* binding */ interactionSettingsToStore),\n/* harmony export */   bF: () => (/* binding */ ElementDragging),\n/* harmony export */   bG: () => (/* binding */ config),\n/* harmony export */   bH: () => (/* binding */ parseDragMeta),\n/* harmony export */   bI: () => (/* binding */ DayHeader),\n/* harmony export */   bJ: () => (/* binding */ computeFallbackHeaderFormat),\n/* harmony export */   bK: () => (/* binding */ TableDateCell),\n/* harmony export */   bL: () => (/* binding */ TableDowCell),\n/* harmony export */   bM: () => (/* binding */ DaySeriesModel),\n/* harmony export */   bN: () => (/* binding */ hasBgRendering),\n/* harmony export */   bO: () => (/* binding */ buildSegTimeText),\n/* harmony export */   bP: () => (/* binding */ sortEventSegs),\n/* harmony export */   bQ: () => (/* binding */ getSegMeta),\n/* harmony export */   bR: () => (/* binding */ buildEventRangeKey),\n/* harmony export */   bS: () => (/* binding */ getSegAnchorAttrs),\n/* harmony export */   bT: () => (/* binding */ DayTableModel),\n/* harmony export */   bU: () => (/* binding */ Slicer),\n/* harmony export */   bV: () => (/* binding */ applyMutationToEventStore),\n/* harmony export */   bW: () => (/* binding */ isPropsValid),\n/* harmony export */   bX: () => (/* binding */ isInteractionValid),\n/* harmony export */   bY: () => (/* binding */ isDateSelectionValid),\n/* harmony export */   bZ: () => (/* binding */ SimpleScrollGrid),\n/* harmony export */   b_: () => (/* binding */ hasShrinkWidth),\n/* harmony export */   ba: () => (/* binding */ ElementScrollController),\n/* harmony export */   bb: () => (/* binding */ WindowScrollController),\n/* harmony export */   bc: () => (/* binding */ DateComponent),\n/* harmony export */   bd: () => (/* binding */ isDateSpansEqual),\n/* harmony export */   be: () => (/* binding */ addMs),\n/* harmony export */   bf: () => (/* binding */ addWeeks),\n/* harmony export */   bg: () => (/* binding */ diffWeeks),\n/* harmony export */   bh: () => (/* binding */ diffWholeWeeks),\n/* harmony export */   bi: () => (/* binding */ diffDayAndTime),\n/* harmony export */   bj: () => (/* binding */ diffDays),\n/* harmony export */   bk: () => (/* binding */ isValidDate),\n/* harmony export */   bl: () => (/* binding */ asCleanDays),\n/* harmony export */   bm: () => (/* binding */ multiplyDuration),\n/* harmony export */   bn: () => (/* binding */ addDurations),\n/* harmony export */   bo: () => (/* binding */ asRoughMinutes),\n/* harmony export */   bp: () => (/* binding */ asRoughSeconds),\n/* harmony export */   bq: () => (/* binding */ asRoughMs),\n/* harmony export */   br: () => (/* binding */ wholeDivideDurations),\n/* harmony export */   bs: () => (/* binding */ formatIsoTimeString),\n/* harmony export */   bt: () => (/* binding */ formatDayString),\n/* harmony export */   bu: () => (/* binding */ buildIsoString),\n/* harmony export */   bv: () => (/* binding */ formatIsoMonthStr),\n/* harmony export */   bw: () => (/* binding */ NamedTimeZoneImpl),\n/* harmony export */   bx: () => (/* binding */ parse),\n/* harmony export */   by: () => (/* binding */ SegHierarchy),\n/* harmony export */   bz: () => (/* binding */ buildEntryKey),\n/* harmony export */   c: () => (/* binding */ greatestDurationDenominator),\n/* harmony export */   c0: () => (/* binding */ getScrollGridClassNames),\n/* harmony export */   c1: () => (/* binding */ getSectionClassNames),\n/* harmony export */   c2: () => (/* binding */ getSectionHasLiquidHeight),\n/* harmony export */   c3: () => (/* binding */ getAllowYScrolling),\n/* harmony export */   c4: () => (/* binding */ renderChunkContent),\n/* harmony export */   c5: () => (/* binding */ computeShrinkWidth),\n/* harmony export */   c6: () => (/* binding */ sanitizeShrinkWidth),\n/* harmony export */   c7: () => (/* binding */ isColPropsEqual),\n/* harmony export */   c8: () => (/* binding */ renderScrollShim),\n/* harmony export */   c9: () => (/* binding */ getStickyFooterScrollbar),\n/* harmony export */   ca: () => (/* binding */ getStickyHeaderDates),\n/* harmony export */   cb: () => (/* binding */ Scroller),\n/* harmony export */   cc: () => (/* binding */ getScrollbarWidths),\n/* harmony export */   cd: () => (/* binding */ RefMap),\n/* harmony export */   ce: () => (/* binding */ getIsRtlScrollbarOnLeft),\n/* harmony export */   cf: () => (/* binding */ ScrollResponder),\n/* harmony export */   cg: () => (/* binding */ StandardEvent),\n/* harmony export */   ch: () => (/* binding */ NowIndicatorContainer),\n/* harmony export */   ci: () => (/* binding */ DayCellContainer),\n/* harmony export */   cj: () => (/* binding */ hasCustomDayCellContent),\n/* harmony export */   ck: () => (/* binding */ EventContainer),\n/* harmony export */   cl: () => (/* binding */ renderFill),\n/* harmony export */   cm: () => (/* binding */ BgEvent),\n/* harmony export */   cn: () => (/* binding */ WeekNumberContainer),\n/* harmony export */   co: () => (/* binding */ MoreLinkContainer),\n/* harmony export */   cp: () => (/* binding */ computeEarliestSegStart),\n/* harmony export */   cq: () => (/* binding */ ViewContainer),\n/* harmony export */   cr: () => (/* binding */ triggerDateSelect),\n/* harmony export */   cs: () => (/* binding */ getDefaultEventEnd),\n/* harmony export */   ct: () => (/* binding */ injectStyles),\n/* harmony export */   cu: () => (/* binding */ buildElAttrs),\n/* harmony export */   cv: () => (/* binding */ CustomRenderingStore),\n/* harmony export */   d: () => (/* binding */ createDuration),\n/* harmony export */   e: () => (/* binding */ BASE_OPTION_DEFAULTS),\n/* harmony export */   f: () => (/* binding */ arrayToHash),\n/* harmony export */   g: () => (/* binding */ guid),\n/* harmony export */   h: () => (/* binding */ filterHash),\n/* harmony export */   i: () => (/* binding */ isArraysEqual),\n/* harmony export */   j: () => (/* binding */ buildEventSourceRefiners),\n/* harmony export */   k: () => (/* binding */ formatWithOrdinals),\n/* harmony export */   l: () => (/* binding */ buildRangeApiWithTimeZone),\n/* harmony export */   m: () => (/* binding */ mergeProps),\n/* harmony export */   n: () => (/* binding */ identity),\n/* harmony export */   o: () => (/* binding */ intersectRanges),\n/* harmony export */   p: () => (/* binding */ parseEventSource),\n/* harmony export */   q: () => (/* binding */ startOfDay),\n/* harmony export */   r: () => (/* binding */ requestJson),\n/* harmony export */   s: () => (/* binding */ subtractDurations),\n/* harmony export */   t: () => (/* binding */ addDays),\n/* harmony export */   u: () => (/* binding */ unpromisify),\n/* harmony export */   v: () => (/* binding */ hashValuesToArray),\n/* harmony export */   w: () => (/* binding */ buildEventApis),\n/* harmony export */   x: () => (/* binding */ createFormatter),\n/* harmony export */   y: () => (/* binding */ diffWholeDays),\n/* harmony export */   z: () => (/* binding */ memoize)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(ssr)/./node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/compat */ \"(ssr)/./node_modules/preact/compat/dist/compat.mjs\");\n\n\n\nconst styleTexts = [];\nconst styleEls = new Map();\nfunction injectStyles(styleText) {\n    styleTexts.push(styleText);\n    styleEls.forEach((styleEl)=>{\n        appendStylesTo(styleEl, styleText);\n    });\n}\nfunction ensureElHasStyles(el) {\n    if (el.isConnected && // sometimes true if SSR system simulates DOM\n    el.getRootNode // sometimes undefined if SSR system simulates DOM\n    ) {\n        registerStylesRoot(el.getRootNode());\n    }\n}\nfunction registerStylesRoot(rootNode) {\n    let styleEl = styleEls.get(rootNode);\n    if (!styleEl || !styleEl.isConnected) {\n        styleEl = rootNode.querySelector(\"style[data-fullcalendar]\");\n        if (!styleEl) {\n            styleEl = document.createElement(\"style\");\n            styleEl.setAttribute(\"data-fullcalendar\", \"\");\n            const nonce = getNonceValue();\n            if (nonce) {\n                styleEl.nonce = nonce;\n            }\n            const parentEl = rootNode === document ? document.head : rootNode;\n            const insertBefore = rootNode === document ? parentEl.querySelector(\"script,link[rel=stylesheet],link[as=style],style\") : parentEl.firstChild;\n            parentEl.insertBefore(styleEl, insertBefore);\n        }\n        styleEls.set(rootNode, styleEl);\n        hydrateStylesRoot(styleEl);\n    }\n}\nfunction hydrateStylesRoot(styleEl) {\n    for (const styleText of styleTexts){\n        appendStylesTo(styleEl, styleText);\n    }\n}\nfunction appendStylesTo(styleEl, styleText) {\n    const { sheet } = styleEl;\n    const ruleCnt = sheet.cssRules.length;\n    styleText.split(\"}\").forEach((styleStr, i)=>{\n        styleStr = styleStr.trim();\n        if (styleStr) {\n            sheet.insertRule(styleStr + \"}\", ruleCnt + i);\n        }\n    });\n}\n// nonce\n// -------------------------------------------------------------------------------------------------\nlet queriedNonceValue;\nfunction getNonceValue() {\n    if (queriedNonceValue === undefined) {\n        queriedNonceValue = queryNonceValue();\n    }\n    return queriedNonceValue;\n}\n/*\nTODO: discourage meta tag and instead put nonce attribute on placeholder <style> tag\n*/ function queryNonceValue() {\n    const metaWithNonce = document.querySelector('meta[name=\"csp-nonce\"]');\n    if (metaWithNonce && metaWithNonce.hasAttribute(\"content\")) {\n        return metaWithNonce.getAttribute(\"content\");\n    }\n    const elWithNonce = document.querySelector(\"script[nonce]\");\n    if (elWithNonce) {\n        return elWithNonce.nonce || \"\";\n    }\n    return \"\";\n}\n// main\n// -------------------------------------------------------------------------------------------------\nif (typeof document !== \"undefined\") {\n    registerStylesRoot(document);\n}\nvar css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\"data:application/x-font-ttf;charset=utf-8;base64,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\") format(\"truetype\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\"\\\\e900\"}.fc-icon-chevron-right:before{content:\"\\\\e901\"}.fc-icon-chevrons-left:before{content:\"\\\\e902\"}.fc-icon-chevrons-right:before{content:\"\\\\e903\"}.fc-icon-minus-square:before{content:\"\\\\e904\"}.fc-icon-plus-square:before{content:\"\\\\e905\"}.fc-icon-x:before{content:\"\\\\e906\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\"\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\"\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\"\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';\ninjectStyles(css_248z);\nclass DelayedRunner {\n    constructor(drainedOption){\n        this.drainedOption = drainedOption;\n        this.isRunning = false;\n        this.isDirty = false;\n        this.pauseDepths = {};\n        this.timeoutId = 0;\n    }\n    request(delay) {\n        this.isDirty = true;\n        if (!this.isPaused()) {\n            this.clearTimeout();\n            if (delay == null) {\n                this.tryDrain();\n            } else {\n                this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n            }\n        }\n    }\n    pause(scope = \"\") {\n        let { pauseDepths } = this;\n        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n        this.clearTimeout();\n    }\n    resume(scope = \"\", force) {\n        let { pauseDepths } = this;\n        if (scope in pauseDepths) {\n            if (force) {\n                delete pauseDepths[scope];\n            } else {\n                pauseDepths[scope] -= 1;\n                let depth = pauseDepths[scope];\n                if (depth <= 0) {\n                    delete pauseDepths[scope];\n                }\n            }\n            this.tryDrain();\n        }\n    }\n    isPaused() {\n        return Object.keys(this.pauseDepths).length;\n    }\n    tryDrain() {\n        if (!this.isRunning && !this.isPaused()) {\n            this.isRunning = true;\n            while(this.isDirty){\n                this.isDirty = false;\n                this.drained(); // might set isDirty to true again\n            }\n            this.isRunning = false;\n        }\n    }\n    clear() {\n        this.clearTimeout();\n        this.isDirty = false;\n        this.pauseDepths = {};\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n        }\n    }\n    drained() {\n        if (this.drainedOption) {\n            this.drainedOption();\n        }\n    }\n}\nfunction removeElement(el) {\n    if (el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n// Querying\n// ----------------------------------------------------------------------------------------------------------------\nfunction elementClosest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    }\n    if (!document.documentElement.contains(el)) {\n        return null;\n    }\n    do {\n        if (elementMatches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement || el.parentNode;\n    }while (el !== null && el.nodeType === 1);\n    return null;\n}\nfunction elementMatches(el, selector) {\n    let method = el.matches || el.matchesSelector || el.msMatchesSelector;\n    return method.call(el, selector);\n}\n// accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\nfunction findElements(container, selector) {\n    let containers = container instanceof HTMLElement ? [\n        container\n    ] : container;\n    let allMatches = [];\n    for(let i = 0; i < containers.length; i += 1){\n        let matches = containers[i].querySelectorAll(selector);\n        for(let j = 0; j < matches.length; j += 1){\n            allMatches.push(matches[j]);\n        }\n    }\n    return allMatches;\n}\n// accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\nfunction findDirectChildren(parent, selector) {\n    let parents = parent instanceof HTMLElement ? [\n        parent\n    ] : parent;\n    let allMatches = [];\n    for(let i = 0; i < parents.length; i += 1){\n        let childNodes = parents[i].children; // only ever elements\n        for(let j = 0; j < childNodes.length; j += 1){\n            let childNode = childNodes[j];\n            if (!selector || elementMatches(childNode, selector)) {\n                allMatches.push(childNode);\n            }\n        }\n    }\n    return allMatches;\n}\n// Style\n// ----------------------------------------------------------------------------------------------------------------\nconst PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\nfunction applyStyle(el, props) {\n    for(let propName in props){\n        applyStyleProp(el, propName, props[propName]);\n    }\n}\nfunction applyStyleProp(el, name, val) {\n    if (val == null) {\n        el.style[name] = \"\";\n    } else if (typeof val === \"number\" && PIXEL_PROP_RE.test(name)) {\n        el.style[name] = `${val}px`;\n    } else {\n        el.style[name] = val;\n    }\n}\n// Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\nfunction getEventTargetViaRoot(ev) {\n    var _a, _b;\n    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n}\n// Unique ID for DOM attribute\nlet guid$1 = 0;\nfunction getUniqueDomId() {\n    guid$1 += 1;\n    return \"fc-dom-\" + guid$1;\n}\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n    ev.preventDefault();\n}\n// Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\nfunction buildDelegationHandler(selector, handler) {\n    return (ev)=>{\n        let matchedChild = elementClosest(ev.target, selector);\n        if (matchedChild) {\n            handler.call(matchedChild, ev, matchedChild);\n        }\n    };\n}\nfunction listenBySelector(container, eventType, selector, handler) {\n    let attachedHandler = buildDelegationHandler(selector, handler);\n    container.addEventListener(eventType, attachedHandler);\n    return ()=>{\n        container.removeEventListener(eventType, attachedHandler);\n    };\n}\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n    let currentMatchedChild;\n    return listenBySelector(container, \"mouseover\", selector, (mouseOverEv, matchedChild)=>{\n        if (matchedChild !== currentMatchedChild) {\n            currentMatchedChild = matchedChild;\n            onMouseEnter(mouseOverEv, matchedChild);\n            let realOnMouseLeave = (mouseLeaveEv)=>{\n                currentMatchedChild = null;\n                onMouseLeave(mouseLeaveEv, matchedChild);\n                matchedChild.removeEventListener(\"mouseleave\", realOnMouseLeave);\n            };\n            // listen to the next mouseleave, and then unattach\n            matchedChild.addEventListener(\"mouseleave\", realOnMouseLeave);\n        }\n    });\n}\n// Animation\n// ----------------------------------------------------------------------------------------------------------------\nconst transitionEventNames = [\n    \"webkitTransitionEnd\",\n    \"otransitionend\",\n    \"oTransitionEnd\",\n    \"msTransitionEnd\",\n    \"transitionend\"\n];\n// triggered only when the next single subsequent transition finishes\nfunction whenTransitionDone(el, callback) {\n    let realCallback = (ev)=>{\n        callback(ev);\n        transitionEventNames.forEach((eventName)=>{\n            el.removeEventListener(eventName, realCallback);\n        });\n    };\n    transitionEventNames.forEach((eventName)=>{\n        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n    });\n}\n// ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\nfunction createAriaClickAttrs(handler) {\n    return Object.assign({\n        onClick: handler\n    }, createAriaKeyboardAttrs(handler));\n}\nfunction createAriaKeyboardAttrs(handler) {\n    return {\n        tabIndex: 0,\n        onKeyDown (ev) {\n            if (ev.key === \"Enter\" || ev.key === \" \") {\n                handler(ev);\n                ev.preventDefault(); // if space, don't scroll down page\n            }\n        }\n    };\n}\nlet guidNumber = 0;\nfunction guid() {\n    guidNumber += 1;\n    return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n    document.body.classList.add(\"fc-not-allowed\");\n}\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n    document.body.classList.remove(\"fc-not-allowed\");\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n    el.style.userSelect = \"none\";\n    el.style.webkitUserSelect = \"none\";\n    el.addEventListener(\"selectstart\", preventDefault);\n}\nfunction allowSelection(el) {\n    el.style.userSelect = \"\";\n    el.style.webkitUserSelect = \"\";\n    el.removeEventListener(\"selectstart\", preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n    el.addEventListener(\"contextmenu\", preventDefault);\n}\nfunction allowContextMenu(el) {\n    el.removeEventListener(\"contextmenu\", preventDefault);\n}\nfunction parseFieldSpecs(input) {\n    let specs = [];\n    let tokens = [];\n    let i;\n    let token;\n    if (typeof input === \"string\") {\n        tokens = input.split(/\\s*,\\s*/);\n    } else if (typeof input === \"function\") {\n        tokens = [\n            input\n        ];\n    } else if (Array.isArray(input)) {\n        tokens = input;\n    }\n    for(i = 0; i < tokens.length; i += 1){\n        token = tokens[i];\n        if (typeof token === \"string\") {\n            specs.push(token.charAt(0) === \"-\" ? {\n                field: token.substring(1),\n                order: -1\n            } : {\n                field: token,\n                order: 1\n            });\n        } else if (typeof token === \"function\") {\n            specs.push({\n                func: token\n            });\n        }\n    }\n    return specs;\n}\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n    let i;\n    let cmp;\n    for(i = 0; i < fieldSpecs.length; i += 1){\n        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    return 0;\n}\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n    if (fieldSpec.func) {\n        return fieldSpec.func(obj0, obj1);\n    }\n    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\nfunction flexibleCompare(a, b) {\n    if (!a && !b) {\n        return 0;\n    }\n    if (b == null) {\n        return -1;\n    }\n    if (a == null) {\n        return 1;\n    }\n    if (typeof a === \"string\" || typeof b === \"string\") {\n        return String(a).localeCompare(String(b));\n    }\n    return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n    let s = String(val);\n    return \"000\".substr(0, len - s.length) + s;\n}\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n    if (typeof formatter === \"function\") {\n        return formatter(...args);\n    }\n    if (typeof formatter === \"string\") {\n        return args.reduce((str, arg, index)=>str.replace(\"$\" + index, arg || \"\"), formatter);\n    }\n    return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n    return a - b;\n}\nfunction isInt(n) {\n    return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n    let allWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-frame\");\n    let contentWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-cushion\");\n    if (!allWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-frame className\"); // TODO: use const\n    }\n    if (!contentWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-cushion className\");\n    }\n    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n    contentWidthEl.getBoundingClientRect().width;\n}\nconst INTERNAL_UNITS = [\n    \"years\",\n    \"months\",\n    \"days\",\n    \"milliseconds\"\n];\nconst PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n// Parsing and Creation\nfunction createDuration(input, unit) {\n    if (typeof input === \"string\") {\n        return parseString(input);\n    }\n    if (typeof input === \"object\" && input) {\n        return parseObject(input);\n    }\n    if (typeof input === \"number\") {\n        return parseObject({\n            [unit || \"milliseconds\"]: input\n        });\n    }\n    return null;\n}\nfunction parseString(s) {\n    let m = PARSE_RE.exec(s);\n    if (m) {\n        let sign = m[1] ? -1 : 1;\n        return {\n            years: 0,\n            months: 0,\n            days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n            (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n            (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n            (m[6] ? parseInt(m[6], 10) : 0 // ms\n            ))\n        };\n    }\n    return null;\n}\nfunction parseObject(obj) {\n    let duration = {\n        years: obj.years || obj.year || 0,\n        months: obj.months || obj.month || 0,\n        days: obj.days || obj.day || 0,\n        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n        (obj.seconds || obj.second || 0) * 1000 + // seconds\n        (obj.milliseconds || obj.millisecond || obj.ms || 0)\n    };\n    let weeks = obj.weeks || obj.week;\n    if (weeks) {\n        duration.days += weeks * 7;\n        duration.specifiedWeeks = true;\n    }\n    return duration;\n}\n// Equality\nfunction durationsEqual(d0, d1) {\n    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\nfunction asCleanDays(dur) {\n    if (!dur.years && !dur.months && !dur.milliseconds) {\n        return dur.days;\n    }\n    return 0;\n}\n// Simple Math\nfunction addDurations(d0, d1) {\n    return {\n        years: d0.years + d1.years,\n        months: d0.months + d1.months,\n        days: d0.days + d1.days,\n        milliseconds: d0.milliseconds + d1.milliseconds\n    };\n}\nfunction subtractDurations(d1, d0) {\n    return {\n        years: d1.years - d0.years,\n        months: d1.months - d0.months,\n        days: d1.days - d0.days,\n        milliseconds: d1.milliseconds - d0.milliseconds\n    };\n}\nfunction multiplyDuration(d, n) {\n    return {\n        years: d.years * n,\n        months: d.months * n,\n        days: d.days * n,\n        milliseconds: d.milliseconds * n\n    };\n}\n// Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\nfunction asRoughYears(dur) {\n    return asRoughDays(dur) / 365;\n}\nfunction asRoughMonths(dur) {\n    return asRoughDays(dur) / 30;\n}\nfunction asRoughDays(dur) {\n    return asRoughMs(dur) / 864e5;\n}\nfunction asRoughMinutes(dur) {\n    return asRoughMs(dur) / (1000 * 60);\n}\nfunction asRoughSeconds(dur) {\n    return asRoughMs(dur) / 1000;\n}\nfunction asRoughMs(dur) {\n    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n}\n// Advanced Math\nfunction wholeDivideDurations(numerator, denominator) {\n    let res = null;\n    for(let i = 0; i < INTERNAL_UNITS.length; i += 1){\n        let unit = INTERNAL_UNITS[i];\n        if (denominator[unit]) {\n            let localRes = numerator[unit] / denominator[unit];\n            if (!isInt(localRes) || res !== null && res !== localRes) {\n                return null;\n            }\n            res = localRes;\n        } else if (numerator[unit]) {\n            // needs to divide by something but can't!\n            return null;\n        }\n    }\n    return res;\n}\nfunction greatestDurationDenominator(dur) {\n    let ms = dur.milliseconds;\n    if (ms) {\n        if (ms % 1000 !== 0) {\n            return {\n                unit: \"millisecond\",\n                value: ms\n            };\n        }\n        if (ms % (1000 * 60) !== 0) {\n            return {\n                unit: \"second\",\n                value: ms / 1000\n            };\n        }\n        if (ms % (1000 * 60 * 60) !== 0) {\n            return {\n                unit: \"minute\",\n                value: ms / (1000 * 60)\n            };\n        }\n        if (ms) {\n            return {\n                unit: \"hour\",\n                value: ms / (1000 * 60 * 60)\n            };\n        }\n    }\n    if (dur.days) {\n        if (dur.specifiedWeeks && dur.days % 7 === 0) {\n            return {\n                unit: \"week\",\n                value: dur.days / 7\n            };\n        }\n        return {\n            unit: \"day\",\n            value: dur.days\n        };\n    }\n    if (dur.months) {\n        return {\n            unit: \"month\",\n            value: dur.months\n        };\n    }\n    if (dur.years) {\n        return {\n            unit: \"year\",\n            value: dur.years\n        };\n    }\n    return {\n        unit: \"millisecond\",\n        value: 0\n    };\n}\n// TODO: new util arrayify?\nfunction removeExact(array, exactVal) {\n    let removeCnt = 0;\n    let i = 0;\n    while(i < array.length){\n        if (array[i] === exactVal) {\n            array.splice(i, 1);\n            removeCnt += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return removeCnt;\n}\nfunction isArraysEqual(a0, a1, equalityFunc) {\n    if (a0 === a1) {\n        return true;\n    }\n    let len = a0.length;\n    let i;\n    if (len !== a1.length) {\n        return false;\n    }\n    for(i = 0; i < len; i += 1){\n        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nconst DAY_IDS = [\n    \"sun\",\n    \"mon\",\n    \"tue\",\n    \"wed\",\n    \"thu\",\n    \"fri\",\n    \"sat\"\n];\n// Adding\nfunction addWeeks(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n * 7;\n    return arrayToUtcDate(a);\n}\nfunction addDays(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n;\n    return arrayToUtcDate(a);\n}\nfunction addMs(m, n) {\n    let a = dateToUtcArray(m);\n    a[6] += n;\n    return arrayToUtcDate(a);\n}\n// Diffing (all return floats)\n// TODO: why not use ranges?\nfunction diffWeeks(m0, m1) {\n    return diffDays(m0, m1) / 7;\n}\nfunction diffDays(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\nfunction diffHours(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\nfunction diffMinutes(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\nfunction diffSeconds(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / 1000;\n}\nfunction diffDayAndTime(m0, m1) {\n    let m0day = startOfDay(m0);\n    let m1day = startOfDay(m1);\n    return {\n        years: 0,\n        months: 0,\n        days: Math.round(diffDays(m0day, m1day)),\n        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n    };\n}\n// Diffing Whole Units\nfunction diffWholeWeeks(m0, m1) {\n    let d = diffWholeDays(m0, m1);\n    if (d !== null && d % 7 === 0) {\n        return d / 7;\n    }\n    return null;\n}\nfunction diffWholeDays(m0, m1) {\n    if (timeAsMs(m0) === timeAsMs(m1)) {\n        return Math.round(diffDays(m0, m1));\n    }\n    return null;\n}\n// Start-Of\nfunction startOfDay(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate()\n    ]);\n}\nfunction startOfHour(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours()\n    ]);\n}\nfunction startOfMinute(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes()\n    ]);\n}\nfunction startOfSecond(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n        m.getUTCSeconds()\n    ]);\n}\n// Week Computation\nfunction weekOfYear(marker, dow, doy) {\n    let y = marker.getUTCFullYear();\n    let w = weekOfGivenYear(marker, y, dow, doy);\n    if (w < 1) {\n        return weekOfGivenYear(marker, y - 1, dow, doy);\n    }\n    let nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n    if (nextW >= 1) {\n        return Math.min(w, nextW);\n    }\n    return w;\n}\nfunction weekOfGivenYear(marker, year, dow, doy) {\n    let firstWeekStart = arrayToUtcDate([\n        year,\n        0,\n        1 + firstWeekOffset(year, dow, doy)\n    ]);\n    let dayStart = startOfDay(marker);\n    let days = Math.round(diffDays(firstWeekStart, dayStart));\n    return Math.floor(days / 7) + 1; // zero-indexed\n}\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    let fwd = 7 + dow - doy;\n    // first-week day local weekday -- which local weekday is fwd\n    let fwdlw = (7 + arrayToUtcDate([\n        year,\n        0,\n        fwd\n    ]).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n}\n// Array Conversion\nfunction dateToLocalArray(date) {\n    return [\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        date.getMilliseconds()\n    ];\n}\nfunction arrayToLocalDate(a) {\n    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n}\nfunction dateToUtcArray(date) {\n    return [\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds()\n    ];\n}\nfunction arrayToUtcDate(a) {\n    // according to web standards (and Safari), a month index is required.\n    // massage if only given a year.\n    if (a.length === 1) {\n        a = a.concat([\n            0\n        ]);\n    }\n    return new Date(Date.UTC(...a));\n}\n// Other Utils\nfunction isValidDate(m) {\n    return !isNaN(m.valueOf());\n}\nfunction timeAsMs(m) {\n    return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n// timeZoneOffset is in minutes\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {\n    let s = marker.toISOString();\n    s = s.replace(\".000\", \"\");\n    if (stripZeroTime) {\n        s = s.replace(\"T00:00:00Z\", \"\");\n    }\n    if (s.length > 10) {\n        if (timeZoneOffset == null) {\n            s = s.replace(\"Z\", \"\");\n        } else if (timeZoneOffset !== 0) {\n            s = s.replace(\"Z\", formatTimeZoneOffset(timeZoneOffset, true));\n        }\n    // otherwise, its UTC-0 and we want to keep the Z\n    }\n    return s;\n}\n// formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\nfunction formatDayString(marker) {\n    return marker.toISOString().replace(/T.*$/, \"\");\n}\nfunction formatIsoMonthStr(marker) {\n    return marker.toISOString().match(/^\\d{4}-\\d{2}/)[0];\n}\n// TODO: use Date::toISOString and use everything after the T?\nfunction formatIsoTimeString(marker) {\n    return padStart(marker.getUTCHours(), 2) + \":\" + padStart(marker.getUTCMinutes(), 2) + \":\" + padStart(marker.getUTCSeconds(), 2);\n}\nfunction formatTimeZoneOffset(minutes, doIso = false) {\n    let sign = minutes < 0 ? \"-\" : \"+\";\n    let abs = Math.abs(minutes);\n    let hours = Math.floor(abs / 60);\n    let mins = Math.round(abs % 60);\n    if (doIso) {\n        return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;\n    }\n    return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : \"\"}`;\n}\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n    let currentArgs;\n    let currentRes;\n    return function(...newArgs) {\n        if (!currentArgs) {\n            currentRes = workerFunc.apply(this, newArgs);\n        } else if (!isArraysEqual(currentArgs, newArgs)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.apply(this, newArgs);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArgs = newArgs;\n        return currentRes;\n    };\n}\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n    let currentArg;\n    let currentRes;\n    return (newArg)=>{\n        if (!currentArg) {\n            currentRes = workerFunc.call(this, newArg);\n        } else if (!isPropsEqual(currentArg, newArg)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.call(this, newArg);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArg = newArg;\n        return currentRes;\n    };\n}\nfunction memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n    let currentArgSets = [];\n    let currentResults = [];\n    return (newArgSets)=>{\n        let currentLen = currentArgSets.length;\n        let newLen = newArgSets.length;\n        let i = 0;\n        for(; i < currentLen; i += 1){\n            if (!newArgSets[i]) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n            } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n                let res = workerFunc.apply(this, newArgSets[i]);\n                if (!resEquality || !resEquality(res, currentResults[i])) {\n                    currentResults[i] = res;\n                }\n            }\n        }\n        for(; i < newLen; i += 1){\n            currentResults[i] = workerFunc.apply(this, newArgSets[i]);\n        }\n        currentArgSets = newArgSets;\n        currentResults.splice(newLen); // remove excess\n        return currentResults;\n    };\n}\nfunction memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n    let currentArgHash = {};\n    let currentResHash = {};\n    return (newArgHash)=>{\n        let newResHash = {};\n        for(let key in newArgHash){\n            if (!currentResHash[key]) {\n                newResHash[key] = workerFunc.apply(this, newArgHash[key]);\n            } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResHash[key]);\n                }\n                let res = workerFunc.apply(this, newArgHash[key]);\n                newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n            } else {\n                newResHash[key] = currentResHash[key];\n            }\n        }\n        currentArgHash = newArgHash;\n        currentResHash = newResHash;\n        return newResHash;\n    };\n}\nconst EXTENDED_SETTINGS_AND_SEVERITIES = {\n    week: 3,\n    separator: 9,\n    omitZeroMinute: 9,\n    meridiem: 9,\n    omitCommas: 9\n};\nconst STANDARD_DATE_PROP_SEVERITIES = {\n    timeZoneName: 7,\n    era: 6,\n    year: 5,\n    month: 4,\n    day: 2,\n    weekday: 2,\n    hour: 1,\n    minute: 1,\n    second: 1\n};\nconst MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\nconst COMMA_RE = /,/g; // we need re for globalness\nconst MULTI_SPACE_RE = /\\s+/g;\nconst LTR_RE = /\\u200e/g; // control character\nconst UTC_RE = /UTC|GMT/;\nclass NativeFormatter {\n    constructor(formatSettings){\n        let standardDateProps = {};\n        let extendedSettings = {};\n        let smallestUnitNum = 9; // the smallest unit in the formatter (9 is a sentinel, beyond max)\n        for(let name in formatSettings){\n            if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                extendedSettings[name] = formatSettings[name];\n                const severity = EXTENDED_SETTINGS_AND_SEVERITIES[name];\n                if (severity < 9) {\n                    smallestUnitNum = Math.min(EXTENDED_SETTINGS_AND_SEVERITIES[name], smallestUnitNum);\n                }\n            } else {\n                standardDateProps[name] = formatSettings[name];\n                if (name in STANDARD_DATE_PROP_SEVERITIES) {\n                    smallestUnitNum = Math.min(STANDARD_DATE_PROP_SEVERITIES[name], smallestUnitNum);\n                }\n            }\n        }\n        this.standardDateProps = standardDateProps;\n        this.extendedSettings = extendedSettings;\n        this.smallestUnitNum = smallestUnitNum;\n        this.buildFormattingFunc = memoize(buildFormattingFunc);\n    }\n    format(date, context) {\n        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        let { standardDateProps, extendedSettings } = this;\n        let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n        if (!diffSeverity) {\n            return this.format(start, context);\n        }\n        let biggestUnitForPartial = diffSeverity;\n        if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n        (standardDateProps.year === \"numeric\" || standardDateProps.year === \"2-digit\") && (standardDateProps.month === \"numeric\" || standardDateProps.month === \"2-digit\") && (standardDateProps.day === \"numeric\" || standardDateProps.day === \"2-digit\")) {\n            biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n        }\n        let full0 = this.format(start, context);\n        let full1 = this.format(end, context);\n        if (full0 === full1) {\n            return full0;\n        }\n        let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n        let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n        let partial0 = partialFormattingFunc(start);\n        let partial1 = partialFormattingFunc(end);\n        let insertion = findCommonInsertion(full0, partial0, full1, partial1);\n        let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || \"\";\n        if (insertion) {\n            return insertion.before + partial0 + separator + partial1 + insertion.after;\n        }\n        return full0 + separator + full1;\n    }\n    getSmallestUnit() {\n        switch(this.smallestUnitNum){\n            case 7:\n            case 6:\n            case 5:\n                return \"year\";\n            case 4:\n                return \"month\";\n            case 3:\n                return \"week\";\n            case 2:\n                return \"day\";\n            default:\n                return \"time\"; // really?\n        }\n    }\n}\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n    let standardDatePropCnt = Object.keys(standardDateProps).length;\n    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === \"short\") {\n        return (date)=>formatTimeZoneOffset(date.timeZoneOffset);\n    }\n    if (standardDatePropCnt === 0 && extendedSettings.week) {\n        return (date)=>formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n    }\n    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n    standardDateProps = Object.assign({}, standardDateProps); // copy\n    extendedSettings = Object.assign({}, extendedSettings); // copy\n    sanitizeSettings(standardDateProps, extendedSettings);\n    standardDateProps.timeZone = \"UTC\"; // we leverage the only guaranteed timeZone for our UTC markers\n    let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n    let zeroFormat; // needed?\n    if (extendedSettings.omitZeroMinute) {\n        let zeroProps = Object.assign({}, standardDateProps);\n        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n    }\n    return (date)=>{\n        let { marker } = date;\n        let format;\n        if (zeroFormat && !marker.getUTCMinutes()) {\n            format = zeroFormat;\n        } else {\n            format = normalFormat;\n        }\n        let s = format.format(marker);\n        return postProcess(s, date, standardDateProps, extendedSettings, context);\n    };\n}\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n    // deal with a browser inconsistency where formatting the timezone\n    // requires that the hour/minute be present.\n    if (standardDateProps.timeZoneName) {\n        if (!standardDateProps.hour) {\n            standardDateProps.hour = \"2-digit\";\n        }\n        if (!standardDateProps.minute) {\n            standardDateProps.minute = \"2-digit\";\n        }\n    }\n    // only support short timezone names\n    if (standardDateProps.timeZoneName === \"long\") {\n        standardDateProps.timeZoneName = \"short\";\n    }\n    // if requesting to display seconds, MUST display minutes\n    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n        delete extendedSettings.omitZeroMinute;\n    }\n}\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n    s = s.replace(LTR_RE, \"\"); // remove left-to-right control chars. do first. good for other regexes\n    if (standardDateProps.timeZoneName === \"short\") {\n        s = injectTzoStr(s, context.timeZone === \"UTC\" || date.timeZoneOffset == null ? \"UTC\" : formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (extendedSettings.omitCommas) {\n        s = s.replace(COMMA_RE, \"\").trim();\n    }\n    if (extendedSettings.omitZeroMinute) {\n        s = s.replace(\":00\", \"\"); // zeroFormat doesn't always achieve this\n    }\n    // ^ do anything that might create adjacent spaces before this point,\n    // because MERIDIEM_RE likes to eat up loading spaces\n    if (extendedSettings.meridiem === false) {\n        s = s.replace(MERIDIEM_RE, \"\").trim();\n    } else if (extendedSettings.meridiem === \"narrow\") {\n        s = s.replace(MERIDIEM_RE, (m0, m1)=>m1.toLocaleLowerCase());\n    } else if (extendedSettings.meridiem === \"short\") {\n        s = s.replace(MERIDIEM_RE, (m0, m1)=>`${m1.toLocaleLowerCase()}m`);\n    } else if (extendedSettings.meridiem === \"lowercase\") {\n        s = s.replace(MERIDIEM_RE, (m0)=>m0.toLocaleLowerCase());\n    }\n    s = s.replace(MULTI_SPACE_RE, \" \");\n    s = s.trim();\n    return s;\n}\nfunction injectTzoStr(s, tzoStr) {\n    let replaced = false;\n    s = s.replace(UTC_RE, ()=>{\n        replaced = true;\n        return tzoStr;\n    });\n    // IE11 doesn't include UTC/GMT in the original string, so append to end\n    if (!replaced) {\n        s += ` ${tzoStr}`;\n    }\n    return s;\n}\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n    let parts = [];\n    if (display === \"long\") {\n        parts.push(weekTextLong);\n    } else if (display === \"short\" || display === \"narrow\") {\n        parts.push(weekText);\n    }\n    if (display === \"long\" || display === \"short\") {\n        parts.push(\" \");\n    }\n    parts.push(locale.simpleNumberFormat.format(num));\n    if (locale.options.direction === \"rtl\") {\n        parts.reverse();\n    }\n    return parts.join(\"\");\n}\n// Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n        return 5;\n    }\n    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n        return 4;\n    }\n    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n        return 2;\n    }\n    if (timeAsMs(d0) !== timeAsMs(d1)) {\n        return 1;\n    }\n    return 0;\n}\nfunction computePartialFormattingOptions(options, biggestUnit) {\n    let partialOptions = {};\n    for(let name in options){\n        if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n        STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {\n            partialOptions[name] = options[name];\n        }\n    }\n    return partialOptions;\n}\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n    let i0 = 0;\n    while(i0 < full0.length){\n        let found0 = full0.indexOf(partial0, i0);\n        if (found0 === -1) {\n            break;\n        }\n        let before0 = full0.substr(0, found0);\n        i0 = found0 + partial0.length;\n        let after0 = full0.substr(i0);\n        let i1 = 0;\n        while(i1 < full1.length){\n            let found1 = full1.indexOf(partial1, i1);\n            if (found1 === -1) {\n                break;\n            }\n            let before1 = full1.substr(0, found1);\n            i1 = found1 + partial1.length;\n            let after1 = full1.substr(i1);\n            if (before0 === before1 && after0 === after1) {\n                return {\n                    before: before0,\n                    after: after0\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n    let a = calendarSystem.markerToArray(dateInfo.marker);\n    return {\n        marker: dateInfo.marker,\n        timeZoneOffset: dateInfo.timeZoneOffset,\n        array: a,\n        year: a[0],\n        month: a[1],\n        day: a[2],\n        hour: a[3],\n        minute: a[4],\n        second: a[5],\n        millisecond: a[6]\n    };\n}\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n    let startInfo = expandZonedMarker(start, context.calendarSystem);\n    let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n    return {\n        date: startInfo,\n        start: startInfo,\n        end: endInfo,\n        timeZone: context.timeZone,\n        localeCodes: context.locale.codes,\n        defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n    };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/ /*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/ class CmdFormatter {\n    constructor(cmdStr){\n        this.cmdStr = cmdStr;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\nclass FuncFormatter {\n    constructor(func){\n        this.func = func;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\nfunction createFormatter(input) {\n    if (typeof input === \"object\" && input) {\n        return new NativeFormatter(input);\n    }\n    if (typeof input === \"string\") {\n        return new CmdFormatter(input);\n    }\n    if (typeof input === \"function\") {\n        return new FuncFormatter(input);\n    }\n    return null;\n}\n// base options\n// ------------\nconst BASE_OPTION_REFINERS = {\n    navLinkDayClick: identity,\n    navLinkWeekClick: identity,\n    duration: createDuration,\n    bootstrapFontAwesome: identity,\n    buttonIcons: identity,\n    customButtons: identity,\n    defaultAllDayEventDuration: createDuration,\n    defaultTimedEventDuration: createDuration,\n    nextDayThreshold: createDuration,\n    scrollTime: createDuration,\n    scrollTimeReset: Boolean,\n    slotMinTime: createDuration,\n    slotMaxTime: createDuration,\n    dayPopoverFormat: createFormatter,\n    slotDuration: createDuration,\n    snapDuration: createDuration,\n    headerToolbar: identity,\n    footerToolbar: identity,\n    defaultRangeSeparator: String,\n    titleRangeSeparator: String,\n    forceEventDuration: Boolean,\n    dayHeaders: Boolean,\n    dayHeaderFormat: createFormatter,\n    dayHeaderClassNames: identity,\n    dayHeaderContent: identity,\n    dayHeaderDidMount: identity,\n    dayHeaderWillUnmount: identity,\n    dayCellClassNames: identity,\n    dayCellContent: identity,\n    dayCellDidMount: identity,\n    dayCellWillUnmount: identity,\n    initialView: String,\n    aspectRatio: Number,\n    weekends: Boolean,\n    weekNumberCalculation: identity,\n    weekNumbers: Boolean,\n    weekNumberClassNames: identity,\n    weekNumberContent: identity,\n    weekNumberDidMount: identity,\n    weekNumberWillUnmount: identity,\n    editable: Boolean,\n    viewClassNames: identity,\n    viewDidMount: identity,\n    viewWillUnmount: identity,\n    nowIndicator: Boolean,\n    nowIndicatorClassNames: identity,\n    nowIndicatorContent: identity,\n    nowIndicatorDidMount: identity,\n    nowIndicatorWillUnmount: identity,\n    showNonCurrentDates: Boolean,\n    lazyFetching: Boolean,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n    timeZone: String,\n    locales: identity,\n    locale: identity,\n    themeSystem: String,\n    dragRevertDuration: Number,\n    dragScroll: Boolean,\n    allDayMaintainDuration: Boolean,\n    unselectAuto: Boolean,\n    dropAccept: identity,\n    eventOrder: parseFieldSpecs,\n    eventOrderStrict: Boolean,\n    handleWindowResize: Boolean,\n    windowResizeDelay: Number,\n    longPressDelay: Number,\n    eventDragMinDistance: Number,\n    expandRows: Boolean,\n    height: identity,\n    contentHeight: identity,\n    direction: String,\n    weekNumberFormat: createFormatter,\n    eventResizableFromStart: Boolean,\n    displayEventTime: Boolean,\n    displayEventEnd: Boolean,\n    weekText: String,\n    weekTextLong: String,\n    progressiveEventRendering: Boolean,\n    businessHours: identity,\n    initialDate: identity,\n    now: identity,\n    eventDataTransform: identity,\n    stickyHeaderDates: identity,\n    stickyFooterScrollbar: identity,\n    viewHeight: identity,\n    defaultAllDay: Boolean,\n    eventSourceFailure: identity,\n    eventSourceSuccess: identity,\n    eventDisplay: String,\n    eventStartEditable: Boolean,\n    eventDurationEditable: Boolean,\n    eventOverlap: identity,\n    eventConstraint: identity,\n    eventAllow: identity,\n    eventBackgroundColor: String,\n    eventBorderColor: String,\n    eventTextColor: String,\n    eventColor: String,\n    eventClassNames: identity,\n    eventContent: identity,\n    eventDidMount: identity,\n    eventWillUnmount: identity,\n    selectConstraint: identity,\n    selectOverlap: identity,\n    selectAllow: identity,\n    droppable: Boolean,\n    unselectCancel: String,\n    slotLabelFormat: identity,\n    slotLaneClassNames: identity,\n    slotLaneContent: identity,\n    slotLaneDidMount: identity,\n    slotLaneWillUnmount: identity,\n    slotLabelClassNames: identity,\n    slotLabelContent: identity,\n    slotLabelDidMount: identity,\n    slotLabelWillUnmount: identity,\n    dayMaxEvents: identity,\n    dayMaxEventRows: identity,\n    dayMinWidth: Number,\n    slotLabelInterval: createDuration,\n    allDayText: String,\n    allDayClassNames: identity,\n    allDayContent: identity,\n    allDayDidMount: identity,\n    allDayWillUnmount: identity,\n    slotMinWidth: Number,\n    navLinks: Boolean,\n    eventTimeFormat: createFormatter,\n    rerenderDelay: Number,\n    moreLinkText: identity,\n    moreLinkHint: identity,\n    selectMinDistance: Number,\n    selectable: Boolean,\n    selectLongPressDelay: Number,\n    eventLongPressDelay: Number,\n    selectMirror: Boolean,\n    eventMaxStack: Number,\n    eventMinHeight: Number,\n    eventMinWidth: Number,\n    eventShortHeight: Number,\n    slotEventOverlap: Boolean,\n    plugins: identity,\n    firstDay: Number,\n    dayCount: Number,\n    dateAlignment: String,\n    dateIncrement: createDuration,\n    hiddenDays: identity,\n    fixedWeekCount: Boolean,\n    validRange: identity,\n    visibleRange: identity,\n    titleFormat: identity,\n    eventInteractive: Boolean,\n    // only used by list-view, but languages define the value, so we need it in base options\n    noEventsText: String,\n    viewHint: identity,\n    navLinkHint: identity,\n    closeHint: String,\n    timeHint: String,\n    eventHint: String,\n    moreLinkClick: identity,\n    moreLinkClassNames: identity,\n    moreLinkContent: identity,\n    moreLinkDidMount: identity,\n    moreLinkWillUnmount: identity,\n    monthStartFormat: createFormatter,\n    // for connectors\n    // (can't be part of plugin system b/c must be provided at runtime)\n    handleCustomRendering: identity,\n    customRenderingMetaMap: identity,\n    customRenderingReplaces: Boolean\n};\n// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\nconst BASE_OPTION_DEFAULTS = {\n    eventDisplay: \"auto\",\n    defaultRangeSeparator: \" - \",\n    titleRangeSeparator: \"  \",\n    defaultTimedEventDuration: \"01:00:00\",\n    defaultAllDayEventDuration: {\n        day: 1\n    },\n    forceEventDuration: false,\n    nextDayThreshold: \"00:00:00\",\n    dayHeaders: true,\n    initialView: \"\",\n    aspectRatio: 1.35,\n    headerToolbar: {\n        start: \"title\",\n        center: \"\",\n        end: \"today prev,next\"\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberCalculation: \"local\",\n    editable: false,\n    nowIndicator: false,\n    scrollTime: \"06:00:00\",\n    scrollTimeReset: true,\n    slotMinTime: \"00:00:00\",\n    slotMaxTime: \"24:00:00\",\n    showNonCurrentDates: true,\n    lazyFetching: true,\n    startParam: \"start\",\n    endParam: \"end\",\n    timeZoneParam: \"timeZone\",\n    timeZone: \"local\",\n    locales: [],\n    locale: \"\",\n    themeSystem: \"standard\",\n    dragRevertDuration: 500,\n    dragScroll: true,\n    allDayMaintainDuration: false,\n    unselectAuto: true,\n    dropAccept: \"*\",\n    eventOrder: \"start,-duration,allDay,title\",\n    dayPopoverFormat: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n    },\n    handleWindowResize: true,\n    windowResizeDelay: 100,\n    longPressDelay: 1000,\n    eventDragMinDistance: 5,\n    expandRows: false,\n    navLinks: false,\n    selectable: false,\n    eventMinHeight: 15,\n    eventMinWidth: 30,\n    eventShortHeight: 30,\n    monthStartFormat: {\n        month: \"long\",\n        day: \"numeric\"\n    }\n};\n// calendar listeners\n// ------------------\nconst CALENDAR_LISTENER_REFINERS = {\n    datesSet: identity,\n    eventsSet: identity,\n    eventAdd: identity,\n    eventChange: identity,\n    eventRemove: identity,\n    windowResize: identity,\n    eventClick: identity,\n    eventMouseEnter: identity,\n    eventMouseLeave: identity,\n    select: identity,\n    unselect: identity,\n    loading: identity,\n    // internal\n    _unmount: identity,\n    _beforeprint: identity,\n    _afterprint: identity,\n    _noEventDrop: identity,\n    _noEventResize: identity,\n    _resize: identity,\n    _scrollRequest: identity\n};\n// calendar-specific options\n// -------------------------\nconst CALENDAR_OPTION_REFINERS = {\n    buttonText: identity,\n    buttonHints: identity,\n    views: identity,\n    plugins: identity,\n    initialEvents: identity,\n    events: identity,\n    eventSources: identity\n};\nconst COMPLEX_OPTION_COMPARATORS = {\n    headerToolbar: isMaybeObjectsEqual,\n    footerToolbar: isMaybeObjectsEqual,\n    buttonText: isMaybeObjectsEqual,\n    buttonHints: isMaybeObjectsEqual,\n    buttonIcons: isMaybeObjectsEqual,\n    dateIncrement: isMaybeObjectsEqual,\n    plugins: isMaybeArraysEqual,\n    events: isMaybeArraysEqual,\n    eventSources: isMaybeArraysEqual,\n    [\"resources\"]: isMaybeArraysEqual\n};\nfunction isMaybeObjectsEqual(a, b) {\n    if (typeof a === \"object\" && typeof b === \"object\" && a && b) {\n        return isPropsEqual(a, b);\n    }\n    return a === b;\n}\nfunction isMaybeArraysEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return isArraysEqual(a, b);\n    }\n    return a === b;\n}\n// view-specific options\n// ---------------------\nconst VIEW_OPTION_REFINERS = {\n    type: String,\n    component: identity,\n    buttonText: String,\n    buttonTextKey: String,\n    dateProfileGeneratorClass: identity,\n    usesMinMaxTime: Boolean,\n    classNames: identity,\n    content: identity,\n    didMount: identity,\n    willUnmount: identity\n};\n// util funcs\n// ----------------------------------------------------------------------------------------------------\nfunction mergeRawOptions(optionSets) {\n    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\nfunction refineProps(input, refiners) {\n    let refined = {};\n    let extra = {};\n    for(let propName in refiners){\n        if (propName in input) {\n            refined[propName] = refiners[propName](input[propName]);\n        }\n    }\n    for(let propName in input){\n        if (!(propName in refiners)) {\n            extra[propName] = input[propName];\n        }\n    }\n    return {\n        refined,\n        extra\n    };\n}\nfunction identity(raw) {\n    return raw;\n}\nconst { hasOwnProperty } = Object.prototype;\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexPropsMap) {\n    let dest = {};\n    if (complexPropsMap) {\n        for(let name in complexPropsMap){\n            if (complexPropsMap[name] === isMaybeObjectsEqual) {\n                let complexObjs = [];\n                // collect the trailing object values, stopping when a non-object is discovered\n                for(let i = propObjs.length - 1; i >= 0; i -= 1){\n                    let val = propObjs[i][name];\n                    if (typeof val === \"object\" && val) {\n                        complexObjs.unshift(val);\n                    } else if (val !== undefined) {\n                        dest[name] = val; // if there were no objects, this value will be used\n                        break;\n                    }\n                }\n                // if the trailing values were objects, use the merged value\n                if (complexObjs.length) {\n                    dest[name] = mergeProps(complexObjs);\n                }\n            }\n        }\n    }\n    // copy values into the destination, going from last to first\n    for(let i = propObjs.length - 1; i >= 0; i -= 1){\n        let props = propObjs[i];\n        for(let name in props){\n            if (!(name in dest)) {\n                dest[name] = props[name];\n            }\n        }\n    }\n    return dest;\n}\nfunction filterHash(hash, func) {\n    let filtered = {};\n    for(let key in hash){\n        if (func(hash[key], key)) {\n            filtered[key] = hash[key];\n        }\n    }\n    return filtered;\n}\nfunction mapHash(hash, func) {\n    let newHash = {};\n    for(let key in hash){\n        newHash[key] = func(hash[key], key);\n    }\n    return newHash;\n}\nfunction arrayToHash(a) {\n    let hash = {};\n    for (let item of a){\n        hash[item] = true;\n    }\n    return hash;\n}\n// TODO: reassess browser support\n// https://caniuse.com/?search=object.values\nfunction hashValuesToArray(obj) {\n    let a = [];\n    for(let key in obj){\n        a.push(obj[key]);\n    }\n    return a;\n}\nfunction isPropsEqual(obj0, obj1) {\n    if (obj0 === obj1) {\n        return true;\n    }\n    for(let key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                return false;\n            }\n        }\n    }\n    for(let key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nconst HANDLER_RE = /^on[A-Z]/;\nfunction isNonHandlerPropsEqual(obj0, obj1) {\n    const keys = getUnequalProps(obj0, obj1);\n    for (let key of keys){\n        if (!HANDLER_RE.test(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getUnequalProps(obj0, obj1) {\n    let keys = [];\n    for(let key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                keys.push(key);\n            }\n        }\n    }\n    for(let key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                keys.push(key);\n            }\n        }\n    }\n    return keys;\n}\nfunction compareObjs(oldProps, newProps, equalityFuncs = {}) {\n    if (oldProps === newProps) {\n        return true;\n    }\n    for(let key in newProps){\n        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n        else {\n            return false;\n        }\n    }\n    // check for props that were omitted in the new\n    for(let key in oldProps){\n        if (!(key in newProps)) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/ function isObjValsEqual(val0, val1, comparator) {\n    if (val0 === val1 || comparator === true) {\n        return true;\n    }\n    if (comparator) {\n        return comparator(val0, val1);\n    }\n    return false;\n}\nfunction collectFromHash(hash, startIndex = 0, endIndex, step = 1) {\n    let res = [];\n    if (endIndex == null) {\n        endIndex = Object.keys(hash).length;\n    }\n    for(let i = startIndex; i < endIndex; i += step){\n        let val = hash[i];\n        if (val !== undefined) {\n            res.push(val);\n        }\n    }\n    return res;\n}\nlet calendarSystemClassMap = {};\nfunction registerCalendarSystem(name, theClass) {\n    calendarSystemClassMap[name] = theClass;\n}\nfunction createCalendarSystem(name) {\n    return new calendarSystemClassMap[name]();\n}\nclass GregorianCalendarSystem {\n    getMarkerYear(d) {\n        return d.getUTCFullYear();\n    }\n    getMarkerMonth(d) {\n        return d.getUTCMonth();\n    }\n    getMarkerDay(d) {\n        return d.getUTCDate();\n    }\n    arrayToMarker(arr) {\n        return arrayToUtcDate(arr);\n    }\n    markerToArray(marker) {\n        return dateToUtcArray(marker);\n    }\n}\nregisterCalendarSystem(\"gregory\", GregorianCalendarSystem);\nconst ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\nfunction parse(str) {\n    let m = ISO_RE.exec(str);\n    if (m) {\n        let marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(`0.${m[12]}`) * 1000 : 0));\n        if (isValidDate(marker)) {\n            let timeZoneOffset = null;\n            if (m[13]) {\n                timeZoneOffset = (m[15] === \"-\" ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n            }\n            return {\n                marker,\n                isTimeUnspecified: !m[6],\n                timeZoneOffset\n            };\n        }\n    }\n    return null;\n}\nclass DateEnv {\n    constructor(settings){\n        let timeZone = this.timeZone = settings.timeZone;\n        let isNamedTimeZone = timeZone !== \"local\" && timeZone !== \"UTC\";\n        if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n            this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n        }\n        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n        this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n        this.locale = settings.locale;\n        this.weekDow = settings.locale.week.dow;\n        this.weekDoy = settings.locale.week.doy;\n        if (settings.weekNumberCalculation === \"ISO\") {\n            this.weekDow = 1;\n            this.weekDoy = 4;\n        }\n        if (typeof settings.firstDay === \"number\") {\n            this.weekDow = settings.firstDay;\n        }\n        if (typeof settings.weekNumberCalculation === \"function\") {\n            this.weekNumberFunc = settings.weekNumberCalculation;\n        }\n        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n        this.cmdFormatter = settings.cmdFormatter;\n        this.defaultSeparator = settings.defaultSeparator;\n    }\n    // Creating / Parsing\n    createMarker(input) {\n        let meta = this.createMarkerMeta(input);\n        if (meta === null) {\n            return null;\n        }\n        return meta.marker;\n    }\n    createNowMarker() {\n        if (this.canComputeOffset) {\n            return this.timestampToMarker(new Date().valueOf());\n        }\n        // if we can't compute the current date val for a timezone,\n        // better to give the current local date vals than UTC\n        return arrayToUtcDate(dateToLocalArray(new Date()));\n    }\n    createMarkerMeta(input) {\n        if (typeof input === \"string\") {\n            return this.parse(input);\n        }\n        let marker = null;\n        if (typeof input === \"number\") {\n            marker = this.timestampToMarker(input);\n        } else if (input instanceof Date) {\n            input = input.valueOf();\n            if (!isNaN(input)) {\n                marker = this.timestampToMarker(input);\n            }\n        } else if (Array.isArray(input)) {\n            marker = arrayToUtcDate(input);\n        }\n        if (marker === null || !isValidDate(marker)) {\n            return null;\n        }\n        return {\n            marker,\n            isTimeUnspecified: false,\n            forcedTzo: null\n        };\n    }\n    parse(s) {\n        let parts = parse(s);\n        if (parts === null) {\n            return null;\n        }\n        let { marker } = parts;\n        let forcedTzo = null;\n        if (parts.timeZoneOffset !== null) {\n            if (this.canComputeOffset) {\n                marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n            } else {\n                forcedTzo = parts.timeZoneOffset;\n            }\n        }\n        return {\n            marker,\n            isTimeUnspecified: parts.isTimeUnspecified,\n            forcedTzo\n        };\n    }\n    // Accessors\n    getYear(marker) {\n        return this.calendarSystem.getMarkerYear(marker);\n    }\n    getMonth(marker) {\n        return this.calendarSystem.getMarkerMonth(marker);\n    }\n    getDay(marker) {\n        return this.calendarSystem.getMarkerDay(marker);\n    }\n    // Adding / Subtracting\n    add(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += dur.years;\n        a[1] += dur.months;\n        a[2] += dur.days;\n        a[6] += dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    subtract(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] -= dur.years;\n        a[1] -= dur.months;\n        a[2] -= dur.days;\n        a[6] -= dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addYears(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addMonths(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[1] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    // Diffing Whole Units\n    diffWholeYears(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n            return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n        }\n        return null;\n    }\n    diffWholeMonths(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n            return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n        }\n        return null;\n    }\n    // Range / Duration\n    greatestWholeUnit(m0, m1) {\n        let n = this.diffWholeYears(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"year\",\n                value: n\n            };\n        }\n        n = this.diffWholeMonths(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"month\",\n                value: n\n            };\n        }\n        n = diffWholeWeeks(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"week\",\n                value: n\n            };\n        }\n        n = diffWholeDays(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"day\",\n                value: n\n            };\n        }\n        n = diffHours(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"hour\",\n                value: n\n            };\n        }\n        n = diffMinutes(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"minute\",\n                value: n\n            };\n        }\n        n = diffSeconds(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"second\",\n                value: n\n            };\n        }\n        return {\n            unit: \"millisecond\",\n            value: m1.valueOf() - m0.valueOf()\n        };\n    }\n    countDurationsBetween(m0, m1, d) {\n        // TODO: can use greatestWholeUnit\n        let diff;\n        if (d.years) {\n            diff = this.diffWholeYears(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughYears(d);\n            }\n        }\n        if (d.months) {\n            diff = this.diffWholeMonths(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughMonths(d);\n            }\n        }\n        if (d.days) {\n            diff = diffWholeDays(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughDays(d);\n            }\n        }\n        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n    }\n    // Start-Of\n    // these DON'T return zoned-dates. only UTC start-of dates\n    startOf(m, unit) {\n        if (unit === \"year\") {\n            return this.startOfYear(m);\n        }\n        if (unit === \"month\") {\n            return this.startOfMonth(m);\n        }\n        if (unit === \"week\") {\n            return this.startOfWeek(m);\n        }\n        if (unit === \"day\") {\n            return startOfDay(m);\n        }\n        if (unit === \"hour\") {\n            return startOfHour(m);\n        }\n        if (unit === \"minute\") {\n            return startOfMinute(m);\n        }\n        if (unit === \"second\") {\n            return startOfSecond(m);\n        }\n        return null;\n    }\n    startOfYear(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m)\n        ]);\n    }\n    startOfMonth(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m)\n        ]);\n    }\n    startOfWeek(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n            m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n        ]);\n    }\n    // Week Number\n    computeWeekNumber(marker) {\n        if (this.weekNumberFunc) {\n            return this.weekNumberFunc(this.toDate(marker));\n        }\n        return weekOfYear(marker, this.weekDow, this.weekDoy);\n    }\n    // TODO: choke on timeZoneName: long\n    format(marker, formatter, dateOptions = {}) {\n        return formatter.format({\n            marker,\n            timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n        }, this);\n    }\n    formatRange(start, end, formatter, dateOptions = {}) {\n        if (dateOptions.isEndExclusive) {\n            end = addMs(end, -1);\n        }\n        return formatter.formatRange({\n            marker: start,\n            timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n        }, {\n            marker: end,\n            timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n        }, this, dateOptions.defaultSeparator);\n    }\n    /*\n    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n    might as well use buildIsoString or some other util directly\n    */ formatIso(marker, extraOptions = {}) {\n        let timeZoneOffset = null;\n        if (!extraOptions.omitTimeZoneOffset) {\n            if (extraOptions.forcedTzo != null) {\n                timeZoneOffset = extraOptions.forcedTzo;\n            } else {\n                timeZoneOffset = this.offsetForMarker(marker);\n            }\n        }\n        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n    }\n    // TimeZone\n    timestampToMarker(ms) {\n        if (this.timeZone === \"local\") {\n            return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n        }\n        if (this.timeZone === \"UTC\" || !this.namedTimeZoneImpl) {\n            return new Date(ms);\n        }\n        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    }\n    offsetForMarker(m) {\n        if (this.timeZone === \"local\") {\n            return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n        }\n        if (this.timeZone === \"UTC\") {\n            return 0;\n        }\n        if (this.namedTimeZoneImpl) {\n            return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n        }\n        return null;\n    }\n    // Conversion\n    toDate(m, forcedTzo) {\n        if (this.timeZone === \"local\") {\n            return arrayToLocalDate(dateToUtcArray(m));\n        }\n        if (this.timeZone === \"UTC\") {\n            return new Date(m.valueOf()); // make sure it's a copy\n        }\n        if (!this.namedTimeZoneImpl) {\n            return new Date(m.valueOf() - (forcedTzo || 0));\n        }\n        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n    }\n}\nclass Theme {\n    constructor(calendarOptions){\n        if (this.iconOverrideOption) {\n            this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n        }\n    }\n    setIconOverride(iconOverrideHash) {\n        let iconClassesCopy;\n        let buttonName;\n        if (typeof iconOverrideHash === \"object\" && iconOverrideHash) {\n            iconClassesCopy = Object.assign({}, this.iconClasses);\n            for(buttonName in iconOverrideHash){\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n            }\n            this.iconClasses = iconClassesCopy;\n        } else if (iconOverrideHash === false) {\n            this.iconClasses = {};\n        }\n    }\n    applyIconOverridePrefix(className) {\n        let prefix = this.iconOverridePrefix;\n        if (prefix && className.indexOf(prefix) !== 0) {\n            className = prefix + className;\n        }\n        return className;\n    }\n    getClass(key) {\n        return this.classes[key] || \"\";\n    }\n    getIconClass(buttonName, isRtl) {\n        let className;\n        if (isRtl && this.rtlIconClasses) {\n            className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n        } else {\n            className = this.iconClasses[buttonName];\n        }\n        if (className) {\n            return `${this.baseIconClass} ${className}`;\n        }\n        return \"\";\n    }\n    getCustomButtonIconClass(customButtonProps) {\n        let className;\n        if (this.iconOverrideCustomButtonOption) {\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\n            if (className) {\n                return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;\n            }\n        }\n        return \"\";\n    }\n}\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = \"\";\nTheme.prototype.iconOverridePrefix = \"\";\n/*\nNOTE: this can be a public API, especially createElement for hooks.\nSee examples/typescript-scheduler/src/index.ts\n*/ function flushSync(runBeforeFlush) {\n    runBeforeFlush();\n    let oldDebounceRendering = preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering; // orig\n    let callbackQ = [];\n    function execCallbackSync(callback) {\n        callbackQ.push(callback);\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = execCallbackSync;\n    preact__WEBPACK_IMPORTED_MODULE_0__.render(preact__WEBPACK_IMPORTED_MODULE_0__.createElement(FakeComponent, {}), document.createElement(\"div\"));\n    while(callbackQ.length){\n        callbackQ.shift()();\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = oldDebounceRendering;\n}\nclass FakeComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    render() {\n        return preact__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {});\n    }\n    componentDidMount() {\n        this.setState({});\n    }\n}\n// TODO: use preact/compat instead?\nfunction createContext(defaultValue) {\n    let ContextType = preact__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultValue);\n    let origProvider = ContextType.Provider;\n    ContextType.Provider = function() {\n        let isNew = !this.getChildContext;\n        let children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        if (isNew) {\n            let subs = [];\n            this.shouldComponentUpdate = (_props)=>{\n                if (this.props.value !== _props.value) {\n                    subs.forEach((c)=>{\n                        c.context = _props.value;\n                        c.forceUpdate();\n                    });\n                }\n            };\n            this.sub = (c)=>{\n                subs.push(c);\n                let old = c.componentWillUnmount;\n                c.componentWillUnmount = ()=>{\n                    subs.splice(subs.indexOf(c), 1);\n                    old && old.call(c);\n                };\n            };\n        }\n        return children;\n    };\n    return ContextType;\n}\nclass ScrollResponder {\n    constructor(execFunc, emitter, scrollTime, scrollTimeReset){\n        this.execFunc = execFunc;\n        this.emitter = emitter;\n        this.scrollTime = scrollTime;\n        this.scrollTimeReset = scrollTimeReset;\n        this.handleScrollRequest = (request)=>{\n            this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);\n            this.drain();\n        };\n        emitter.on(\"_scrollRequest\", this.handleScrollRequest);\n        this.fireInitialScroll();\n    }\n    detach() {\n        this.emitter.off(\"_scrollRequest\", this.handleScrollRequest);\n    }\n    update(isDatesNew) {\n        if (isDatesNew && this.scrollTimeReset) {\n            this.fireInitialScroll(); // will drain\n        } else {\n            this.drain();\n        }\n    }\n    fireInitialScroll() {\n        this.handleScrollRequest({\n            time: this.scrollTime\n        });\n    }\n    drain() {\n        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n            this.queuedRequest = null;\n        }\n    }\n}\nconst ViewContextType = createContext({}); // for Components\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, nowManager, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n    return {\n        dateEnv,\n        nowManager,\n        options: viewOptions,\n        pluginHooks,\n        emitter,\n        dispatch,\n        getCurrentData,\n        calendarApi,\n        viewSpec,\n        viewApi,\n        dateProfileGenerator,\n        theme,\n        isRtl: viewOptions.direction === \"rtl\",\n        addResizeHandler (handler) {\n            emitter.on(\"_resize\", handler);\n        },\n        removeResizeHandler (handler) {\n            emitter.off(\"_resize\", handler);\n        },\n        createScrollResponder (execFunc) {\n            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n        },\n        registerInteractiveComponent,\n        unregisterInteractiveComponent\n    };\n}\n/* eslint max-classes-per-file: off */ class PureComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    shouldComponentUpdate(nextProps, nextState) {\n        if (this.debug) {\n            // eslint-disable-next-line no-console\n            console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n        }\n        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n    }\n    // HACK for freakin' React StrictMode\n    safeSetState(newState) {\n        if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {\n            this.setState(newState);\n        }\n    }\n}\nPureComponent.addPropsEquality = addPropsEquality;\nPureComponent.addStateEquality = addStateEquality;\nPureComponent.contextType = ViewContextType;\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\nclass BaseComponent extends PureComponent {\n}\nBaseComponent.contextType = ViewContextType;\nfunction addPropsEquality(propEquality) {\n    let hash = Object.create(this.prototype.propEquality);\n    Object.assign(hash, propEquality);\n    this.prototype.propEquality = hash;\n}\nfunction addStateEquality(stateEquality) {\n    let hash = Object.create(this.prototype.stateEquality);\n    Object.assign(hash, stateEquality);\n    this.prototype.stateEquality = hash;\n}\n// use other one\nfunction setRef(ref, current) {\n    if (typeof ref === \"function\") {\n        ref(current);\n    } else if (ref) {\n        // see https://github.com/facebook/react/issues/13029\n        ref.current = current;\n    }\n}\nclass ContentInjector extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.id = guid();\n        this.queuedDomNodes = [];\n        this.currentDomNodes = [];\n        this.handleEl = (el)=>{\n            const { options } = this.context;\n            const { generatorName } = this.props;\n            if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {\n                this.updateElRef(el);\n            }\n        };\n        this.updateElRef = (el)=>{\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { customGenerator, defaultGenerator, renderProps } = props;\n        const attrs = buildElAttrs(props, [], this.handleEl);\n        let useDefault = false;\n        let innerContent;\n        let queuedDomNodes = [];\n        let currentGeneratorMeta;\n        if (customGenerator != null) {\n            const customGeneratorRes = typeof customGenerator === \"function\" ? customGenerator(renderProps, preact__WEBPACK_IMPORTED_MODULE_0__.createElement) : customGenerator;\n            if (customGeneratorRes === true) {\n                useDefault = true;\n            } else {\n                const isObject = customGeneratorRes && typeof customGeneratorRes === \"object\"; // non-null\n                if (isObject && \"html\" in customGeneratorRes) {\n                    attrs.dangerouslySetInnerHTML = {\n                        __html: customGeneratorRes.html\n                    };\n                } else if (isObject && \"domNodes\" in customGeneratorRes) {\n                    queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);\n                } else if (isObject ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(customGeneratorRes) // vdom node\n                 : typeof customGeneratorRes !== \"function\" // primitive value (like string or number)\n                ) {\n                    // use in vdom\n                    innerContent = customGeneratorRes;\n                } else {\n                    // an exotic object for handleCustomRendering\n                    currentGeneratorMeta = customGeneratorRes;\n                }\n            }\n        } else {\n            useDefault = !hasCustomRenderingHandler(props.generatorName, options);\n        }\n        if (useDefault && defaultGenerator) {\n            innerContent = defaultGenerator(renderProps);\n        }\n        this.queuedDomNodes = queuedDomNodes;\n        this.currentGeneratorMeta = currentGeneratorMeta;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, attrs, innerContent);\n    }\n    componentDidMount() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentDidUpdate() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentWillUnmount() {\n        this.triggerCustomRendering(false); // TODO: different API for removal?\n    }\n    triggerCustomRendering(isActive) {\n        var _a;\n        const { props, context } = this;\n        const { handleCustomRendering, customRenderingMetaMap } = context.options;\n        if (handleCustomRendering) {\n            const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];\n            if (generatorMeta) {\n                handleCustomRendering(Object.assign(Object.assign({\n                    id: this.id,\n                    isActive,\n                    containerEl: this.base,\n                    reportNewContainerEl: this.updateElRef,\n                    generatorMeta\n                }, props), {\n                    elClasses: (props.elClasses || []).filter(isTruthy)\n                }));\n            }\n        }\n    }\n    applyQueueudDomNodes() {\n        const { queuedDomNodes, currentDomNodes } = this;\n        const el = this.base;\n        if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {\n            currentDomNodes.forEach(removeElement);\n            for (let newNode of queuedDomNodes){\n                el.appendChild(newNode);\n            }\n            this.currentDomNodes = queuedDomNodes;\n        }\n    }\n}\nContentInjector.addPropsEquality({\n    elClasses: isArraysEqual,\n    elStyle: isPropsEqual,\n    elAttrs: isNonHandlerPropsEqual,\n    renderProps: isPropsEqual\n});\n// Util\n/*\nDoes UI-framework provide custom way of rendering that does not use Preact VDOM\nAND does the calendar's options define custom rendering?\nAKA. Should we NOT render the default content?\n*/ function hasCustomRenderingHandler(generatorName, options) {\n    var _a;\n    return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));\n}\nfunction buildElAttrs(props, extraClassNames, elRef) {\n    const attrs = Object.assign(Object.assign({}, props.elAttrs), {\n        ref: elRef\n    });\n    if (props.elClasses || extraClassNames) {\n        attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(\" \");\n    }\n    if (props.elStyle) {\n        attrs.style = props.elStyle;\n    }\n    return attrs;\n}\nfunction isTruthy(val) {\n    return Boolean(val);\n}\nconst RenderId = createContext(0);\nclass ContentContainer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(){\n        super(...arguments);\n        this.InnerContent = InnerContentInjector.bind(undefined, this);\n        this.handleEl = (el)=>{\n            this.el = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n                if (el && this.didMountMisfire) {\n                    this.componentDidMount();\n                }\n            }\n        };\n    }\n    render() {\n        const { props } = this;\n        const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);\n        if (props.children) {\n            const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);\n            const children = props.children(this.InnerContent, props.renderProps, elAttrs);\n            if (props.elTag) {\n                return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, elAttrs, children);\n            } else {\n                return children;\n            }\n        } else {\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentInjector, Object.assign(Object.assign({}, props), {\n                elRef: this.handleEl,\n                elTag: props.elTag || \"div\",\n                elClasses: (props.elClasses || []).concat(generatedClassNames),\n                renderId: this.context\n            }));\n        }\n    }\n    componentDidMount() {\n        var _a, _b;\n        if (this.el) {\n            (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n                el: this.el\n            }));\n        } else {\n            this.didMountMisfire = true;\n        }\n    }\n    componentWillUnmount() {\n        var _a, _b;\n        (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n            el: this.el\n        }));\n    }\n}\nContentContainer.contextType = RenderId;\nfunction InnerContentInjector(containerComponent, props) {\n    const parentProps = containerComponent.props;\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentInjector, Object.assign({\n        renderProps: parentProps.renderProps,\n        generatorName: parentProps.generatorName,\n        customGenerator: parentProps.customGenerator,\n        defaultGenerator: parentProps.defaultGenerator,\n        renderId: containerComponent.context\n    }, props));\n}\n// Utils\nfunction generateClassNames(classNameGenerator, renderProps) {\n    const classNames = typeof classNameGenerator === \"function\" ? classNameGenerator(renderProps) : classNameGenerator || [];\n    return typeof classNames === \"string\" ? [\n        classNames\n    ] : classNames;\n}\nclass ViewContainer extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = {\n            view: context.viewApi\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props, {\n            elTag: props.elTag || \"div\",\n            elClasses: [\n                ...buildViewClassNames(props.viewSpec),\n                ...props.elClasses || []\n            ],\n            renderProps: renderProps,\n            classNameGenerator: options.viewClassNames,\n            generatorName: undefined,\n            didMount: options.viewDidMount,\n            willUnmount: options.viewWillUnmount\n        }), ()=>props.children);\n    }\n}\nfunction buildViewClassNames(viewSpec) {\n    return [\n        `fc-${viewSpec.type}-view`,\n        \"fc-view\"\n    ];\n}\nfunction parseRange(input, dateEnv) {\n    let start = null;\n    let end = null;\n    if (input.start) {\n        start = dateEnv.createMarker(input.start);\n    }\n    if (input.end) {\n        end = dateEnv.createMarker(input.end);\n    }\n    if (!start && !end) {\n        return null;\n    }\n    if (start && end && end < start) {\n        return null;\n    }\n    return {\n        start,\n        end\n    };\n}\n// SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\nfunction invertRanges(ranges, constraintRange) {\n    let invertedRanges = [];\n    let { start } = constraintRange; // the end of the previous range. the start of the new range\n    let i;\n    let dateRange;\n    // ranges need to be in order. required for our date-walking algorithm\n    ranges.sort(compareRanges);\n    for(i = 0; i < ranges.length; i += 1){\n        dateRange = ranges[i];\n        // add the span of time before the event (if there is any)\n        if (dateRange.start > start) {\n            invertedRanges.push({\n                start,\n                end: dateRange.start\n            });\n        }\n        if (dateRange.end > start) {\n            start = dateRange.end;\n        }\n    }\n    // add the span of time after the last event (if there is any)\n    if (start < constraintRange.end) {\n        invertedRanges.push({\n            start,\n            end: constraintRange.end\n        });\n    }\n    return invertedRanges;\n}\nfunction compareRanges(range0, range1) {\n    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\nfunction intersectRanges(range0, range1) {\n    let { start, end } = range0;\n    let newRange = null;\n    if (range1.start !== null) {\n        if (start === null) {\n            start = range1.start;\n        } else {\n            start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n        }\n    }\n    if (range1.end != null) {\n        if (end === null) {\n            end = range1.end;\n        } else {\n            end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n        }\n    }\n    if (start === null || end === null || start < end) {\n        newRange = {\n            start,\n            end\n        };\n    }\n    return newRange;\n}\nfunction rangesEqual(range0, range1) {\n    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\nfunction rangesIntersect(range0, range1) {\n    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\nfunction rangeContainsRange(outerRange, innerRange) {\n    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\nfunction rangeContainsMarker(range, date) {\n    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n}\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\nfunction constrainMarkerToRange(date, range) {\n    if (range.start != null && date < range.start) {\n        return range.start;\n    }\n    if (range.end != null && date >= range.end) {\n        return new Date(range.end.valueOf() - 1);\n    }\n    return date;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\nfunction computeAlignedDayRange(timedRange) {\n    let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n    let start = startOfDay(timedRange.start);\n    let end = addDays(start, dayCnt);\n    return {\n        start,\n        end\n    };\n}\n// given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\nfunction computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {\n    let startDay = null;\n    let endDay = null;\n    if (timedRange.end) {\n        endDay = startOfDay(timedRange.end);\n        let endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n            endDay = addDays(endDay, 1);\n        }\n    }\n    if (timedRange.start) {\n        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n        if (endDay && endDay <= startDay) {\n            endDay = addDays(startDay, 1);\n        }\n    }\n    return {\n        start: startDay,\n        end: endDay\n    };\n}\n// spans from one day into another?\nfunction isMultiDayRange(range) {\n    let visibleRange = computeVisibleDayRange(range);\n    return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n    if (largeUnit === \"year\") {\n        return createDuration(dateEnv.diffWholeYears(date0, date1), \"year\");\n    }\n    if (largeUnit === \"month\") {\n        return createDuration(dateEnv.diffWholeMonths(date0, date1), \"month\");\n    }\n    return diffDayAndTime(date0, date1); // returns a duration\n}\nclass DateProfileGenerator {\n    constructor(props){\n        this.props = props;\n        this.initHiddenDays();\n    }\n    /* Date Range Computation\n    ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n    buildPrev(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(prevDate, -1, forceToValid);\n    }\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n    buildNext(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(nextDate, 1, forceToValid);\n    }\n    // Builds a structure holding dates/ranges for rendering around the given date.\n    // Optional direction param indicates whether the date is being incremented/decremented\n    // from its previous value. decremented = -1, incremented = 1 (default).\n    build(currentDate, direction, forceToValid = true) {\n        let { props } = this;\n        let validRange;\n        let currentInfo;\n        let isRangeAllDay;\n        let renderRange;\n        let activeRange;\n        let isValid;\n        validRange = this.buildValidRange();\n        validRange = this.trimHiddenDays(validRange);\n        if (forceToValid) {\n            currentDate = constrainMarkerToRange(currentDate, validRange);\n        }\n        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n        renderRange = this.trimHiddenDays(renderRange);\n        activeRange = renderRange;\n        if (!props.showNonCurrentDates) {\n            activeRange = intersectRanges(activeRange, currentInfo.range);\n        }\n        activeRange = this.adjustActiveRange(activeRange);\n        activeRange = intersectRanges(activeRange, validRange); // might return null\n        // it's invalid if the originally requested date is not contained,\n        // or if the range is completely outside of the valid range.\n        isValid = rangesIntersect(currentInfo.range, validRange);\n        // HACK: constrain to render-range so `currentDate` is more useful to view rendering\n        if (!rangeContainsMarker(renderRange, currentDate)) {\n            currentDate = renderRange.start;\n        }\n        return {\n            currentDate,\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\n            // an object with optional start and end properties.\n            validRange,\n            // range the view is formally responsible for.\n            // for example, a month view might have 1st-31st, excluding padded dates\n            currentRange: currentInfo.range,\n            // name of largest unit being displayed, like \"month\" or \"week\"\n            currentRangeUnit: currentInfo.unit,\n            isRangeAllDay,\n            // dates that display events and accept drag-n-drop\n            // will be `null` if no dates accept events\n            activeRange,\n            // date range with a rendered skeleton\n            // includes not-active days that need some sort of DOM\n            renderRange,\n            // Duration object that denotes the first visible time of any given day\n            slotMinTime: props.slotMinTime,\n            // Duration object that denotes the exclusive visible end time of any given day\n            slotMaxTime: props.slotMaxTime,\n            isValid,\n            // how far the current date will move for a prev/next operation\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\n        };\n    }\n    // Builds an object with optional start/end properties.\n    // Indicates the minimum/maximum dates to display.\n    // not responsible for trimming hidden days.\n    buildValidRange() {\n        let input = this.props.validRangeInput;\n        let simpleInput = typeof input === \"function\" ? input.call(this.props.calendarApi, this.props.dateEnv.toDate(this.props.nowManager.getDateMarker())) : input;\n        return this.refineRange(simpleInput) || {\n            start: null,\n            end: null\n        }; // completely open-ended\n    }\n    // Builds a structure with info about the \"current\" range, the range that is\n    // highlighted as being the current month for example.\n    // See build() for a description of `direction`.\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n    buildCurrentRangeInfo(date, direction) {\n        let { props } = this;\n        let duration = null;\n        let unit = null;\n        let range = null;\n        let dayCount;\n        if (props.duration) {\n            duration = props.duration;\n            unit = props.durationUnit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        } else if (dayCount = this.props.dayCount) {\n            unit = \"day\";\n            range = this.buildRangeFromDayCount(date, direction, dayCount);\n        } else if (range = this.buildCustomVisibleRange(date)) {\n            unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n        } else {\n            duration = this.getFallbackDuration();\n            unit = greatestDurationDenominator(duration).unit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        return {\n            duration,\n            unit,\n            range\n        };\n    }\n    getFallbackDuration() {\n        return createDuration({\n            day: 1\n        });\n    }\n    // Returns a new activeRange to have time values (un-ambiguate)\n    // slotMinTime or slotMaxTime causes the range to expand.\n    adjustActiveRange(range) {\n        let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;\n        let { start, end } = range;\n        if (usesMinMaxTime) {\n            // expand active range if slotMinTime is negative (why not when positive?)\n            if (asRoughDays(slotMinTime) < 0) {\n                start = startOfDay(start); // necessary?\n                start = dateEnv.add(start, slotMinTime);\n            }\n            // expand active range if slotMaxTime is beyond one day (why not when negative?)\n            if (asRoughDays(slotMaxTime) > 1) {\n                end = startOfDay(end); // necessary?\n                end = addDays(end, -1);\n                end = dateEnv.add(end, slotMaxTime);\n            }\n        }\n        return {\n            start,\n            end\n        };\n    }\n    // Builds the \"current\" range when it is specified as an explicit duration.\n    // `unit` is the already-computed greatestDurationDenominator unit of duration.\n    buildRangeFromDuration(date, direction, duration, unit) {\n        let { dateEnv, dateAlignment } = this.props;\n        let start;\n        let end;\n        let res;\n        // compute what the alignment should be\n        if (!dateAlignment) {\n            let { dateIncrement } = this.props;\n            if (dateIncrement) {\n                // use the smaller of the two units\n                if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                    dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                } else {\n                    dateAlignment = unit;\n                }\n            } else {\n                dateAlignment = unit;\n            }\n        }\n        // if the view displays a single day or smaller\n        if (asRoughDays(duration) <= 1) {\n            if (this.isHiddenDay(start)) {\n                start = this.skipHiddenDays(start, direction);\n                start = startOfDay(start);\n            }\n        }\n        function computeRes() {\n            start = dateEnv.startOf(date, dateAlignment);\n            end = dateEnv.add(start, duration);\n            res = {\n                start,\n                end\n            };\n        }\n        computeRes();\n        // if range is completely enveloped by hidden days, go past the hidden days\n        if (!this.trimHiddenDays(res)) {\n            date = this.skipHiddenDays(date, direction);\n            computeRes();\n        }\n        return res;\n    }\n    // Builds the \"current\" range when a dayCount is specified.\n    buildRangeFromDayCount(date, direction, dayCount) {\n        let { dateEnv, dateAlignment } = this.props;\n        let runningCount = 0;\n        let start = date;\n        let end;\n        if (dateAlignment) {\n            start = dateEnv.startOf(start, dateAlignment);\n        }\n        start = startOfDay(start);\n        start = this.skipHiddenDays(start, direction);\n        end = start;\n        do {\n            end = addDays(end, 1);\n            if (!this.isHiddenDay(end)) {\n                runningCount += 1;\n            }\n        }while (runningCount < dayCount);\n        return {\n            start,\n            end\n        };\n    }\n    // Builds a normalized range object for the \"visible\" range,\n    // which is a way to define the currentRange and activeRange at the same time.\n    buildCustomVisibleRange(date) {\n        let { props } = this;\n        let input = props.visibleRangeInput;\n        let simpleInput = typeof input === \"function\" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n        let range = this.refineRange(simpleInput);\n        if (range && (range.start == null || range.end == null)) {\n            return null;\n        }\n        return range;\n    }\n    // Computes the range that will represent the element/cells for *rendering*,\n    // but which may have voided days/times.\n    // not responsible for trimming hidden days.\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        return currentRange;\n    }\n    // Compute the duration value that should be added/substracted to the current date\n    // when a prev/next operation happens.\n    buildDateIncrement(fallback) {\n        let { dateIncrement } = this.props;\n        let customAlignment;\n        if (dateIncrement) {\n            return dateIncrement;\n        }\n        if (customAlignment = this.props.dateAlignment) {\n            return createDuration(1, customAlignment);\n        }\n        if (fallback) {\n            return fallback;\n        }\n        return createDuration({\n            days: 1\n        });\n    }\n    refineRange(rangeInput) {\n        if (rangeInput) {\n            let range = parseRange(rangeInput, this.props.dateEnv);\n            if (range) {\n                range = computeVisibleDayRange(range);\n            }\n            return range;\n        }\n        return null;\n    }\n    /* Hidden Days\n    ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n    initHiddenDays() {\n        let hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n        let isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n        let dayCnt = 0;\n        let i;\n        if (this.props.weekends === false) {\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n        }\n        for(i = 0; i < 7; i += 1){\n            if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                dayCnt += 1;\n            }\n        }\n        if (!dayCnt) {\n            throw new Error(\"invalid hiddenDays\"); // all days were hidden? bad.\n        }\n        this.isHiddenDayHash = isHiddenDayHash;\n    }\n    // Remove days from the beginning and end of the range that are computed as hidden.\n    // If the whole range is trimmed off, returns null\n    trimHiddenDays(range) {\n        let { start, end } = range;\n        if (start) {\n            start = this.skipHiddenDays(start);\n        }\n        if (end) {\n            end = this.skipHiddenDays(end, -1, true);\n        }\n        if (start == null || end == null || start < end) {\n            return {\n                start,\n                end\n            };\n        }\n        return null;\n    }\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n    isHiddenDay(day) {\n        if (day instanceof Date) {\n            day = day.getUTCDay();\n        }\n        return this.isHiddenDayHash[day];\n    }\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // DOES NOT CONSIDER validRange!\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    skipHiddenDays(date, inc = 1, isExclusive = false) {\n        while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n            date = addDays(date, inc);\n        }\n        return date;\n    }\n}\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n    return {\n        instanceId: guid(),\n        defId,\n        range,\n        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n    };\n}\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n    for(let i = 0; i < recurringTypes.length; i += 1){\n        let parsed = recurringTypes[i].parse(refined, dateEnv);\n        if (parsed) {\n            let { allDay } = refined;\n            if (allDay == null) {\n                allDay = defaultAllDay;\n                if (allDay == null) {\n                    allDay = parsed.allDayGuess;\n                    if (allDay == null) {\n                        allDay = false;\n                    }\n                }\n            }\n            return {\n                allDay,\n                duration: parsed.duration,\n                typeData: parsed.typeData,\n                typeId: i\n            };\n        }\n    }\n    return null;\n}\nfunction expandRecurring(eventStore, framingRange, context) {\n    let { dateEnv, pluginHooks, options } = context;\n    let { defs, instances } = eventStore;\n    // remove existing recurring instances\n    // TODO: bad. always expand events as a second step\n    instances = filterHash(instances, (instance)=>!defs[instance.defId].recurringDef);\n    for(let defId in defs){\n        let def = defs[defId];\n        if (def.recurringDef) {\n            let { duration } = def.recurringDef;\n            if (!duration) {\n                duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n            }\n            let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n            for (let start of starts){\n                let instance = createEventInstance(defId, {\n                    start,\n                    end: dateEnv.add(start, duration)\n                });\n                instances[instance.instanceId] = instance;\n            }\n        }\n    }\n    return {\n        defs,\n        instances\n    };\n}\n/*\nEvent MUST have a recurringDef\n*/ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n    let typeDef = recurringTypes[eventDef.recurringDef.typeId];\n    let markers = typeDef.expand(eventDef.recurringDef.typeData, {\n        start: dateEnv.subtract(framingRange.start, duration),\n        end: framingRange.end\n    }, dateEnv);\n    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n    if (eventDef.allDay) {\n        markers = markers.map(startOfDay);\n    }\n    return markers;\n}\nconst EVENT_NON_DATE_REFINERS = {\n    id: String,\n    groupId: String,\n    title: String,\n    url: String,\n    interactive: Boolean\n};\nconst EVENT_DATE_REFINERS = {\n    start: identity,\n    end: identity,\n    date: identity,\n    allDay: Boolean\n};\nconst EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n    extendedProps: identity\n});\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {\n    let { refined, extra } = refineEventDef(raw, context, refiners);\n    let defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n    let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n    if (recurringRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);\n        def.recurringDef = {\n            typeId: recurringRes.typeId,\n            typeData: recurringRes.typeData,\n            duration: recurringRes.duration\n        };\n        return {\n            def,\n            instance: null\n        };\n    }\n    let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n    if (singleRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", singleRes.allDay, singleRes.hasEnd, context, defIdMap);\n        let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n        if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {\n            instance.instanceId = instanceIdMap[def.publicId];\n        }\n        return {\n            def,\n            instance\n        };\n    }\n    return null;\n}\nfunction refineEventDef(raw, context, refiners = buildEventRefiners(context)) {\n    return refineProps(raw, refiners);\n}\nfunction buildEventRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {\n    let def = {\n        title: refined.title || \"\",\n        groupId: refined.groupId || \"\",\n        publicId: refined.id || \"\",\n        url: refined.url || \"\",\n        recurringDef: null,\n        defId: (defIdMap && refined.id ? defIdMap[refined.id] : \"\") || guid(),\n        sourceId,\n        allDay,\n        hasEnd,\n        interactive: refined.interactive,\n        ui: createEventUi(refined, context),\n        extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)\n    };\n    for (let memberAdder of context.pluginHooks.eventDefMemberAdders){\n        Object.assign(def, memberAdder(refined));\n    }\n    // help out EventImpl from having user modify props\n    Object.freeze(def.ui.classNames);\n    Object.freeze(def.extendedProps);\n    return def;\n}\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n    let { allDay } = refined;\n    let startMeta;\n    let startMarker = null;\n    let hasEnd = false;\n    let endMeta;\n    let endMarker = null;\n    let startInput = refined.start != null ? refined.start : refined.date;\n    startMeta = context.dateEnv.createMarkerMeta(startInput);\n    if (startMeta) {\n        startMarker = startMeta.marker;\n    } else if (!allowOpenRange) {\n        return null;\n    }\n    if (refined.end != null) {\n        endMeta = context.dateEnv.createMarkerMeta(refined.end);\n    }\n    if (allDay == null) {\n        if (defaultAllDay != null) {\n            allDay = defaultAllDay;\n        } else {\n            // fall back to the date props LAST\n            allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n        }\n    }\n    if (allDay && startMarker) {\n        startMarker = startOfDay(startMarker);\n    }\n    if (endMeta) {\n        endMarker = endMeta.marker;\n        if (allDay) {\n            endMarker = startOfDay(endMarker);\n        }\n        if (startMarker && endMarker <= startMarker) {\n            endMarker = null;\n        }\n    }\n    if (endMarker) {\n        hasEnd = true;\n    } else if (!allowOpenRange) {\n        hasEnd = context.options.forceEventDuration || false;\n        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n    }\n    return {\n        allDay,\n        hasEnd,\n        range: {\n            start: startMarker,\n            end: endMarker\n        },\n        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n        forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n    };\n}\nfunction computeIsDefaultAllDay(eventSource, context) {\n    let res = null;\n    if (eventSource) {\n        res = eventSource.defaultAllDay;\n    }\n    if (res == null) {\n        res = context.options.defaultAllDay;\n    }\n    return res;\n}\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {\n    let eventStore = createEmptyEventStore();\n    let eventRefiners = buildEventRefiners(context);\n    for (let rawEvent of rawEvents){\n        let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);\n        if (tuple) {\n            eventTupleToStore(tuple, eventStore);\n        }\n    }\n    return eventStore;\n}\nfunction eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {\n    eventStore.defs[tuple.def.defId] = tuple.def;\n    if (tuple.instance) {\n        eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n    }\n    return eventStore;\n}\n// retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\nfunction getRelevantEvents(eventStore, instanceId) {\n    let instance = eventStore.instances[instanceId];\n    if (instance) {\n        let def = eventStore.defs[instance.defId];\n        // get events/instances with same group\n        let newStore = filterEventStoreDefs(eventStore, (lookDef)=>isEventDefsGrouped(def, lookDef));\n        // add the original\n        // TODO: wish we could use eventTupleToStore or something like it\n        newStore.defs[def.defId] = def;\n        newStore.instances[instance.instanceId] = instance;\n        return newStore;\n    }\n    return createEmptyEventStore();\n}\nfunction isEventDefsGrouped(def0, def1) {\n    return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\nfunction createEmptyEventStore() {\n    return {\n        defs: {},\n        instances: {}\n    };\n}\nfunction mergeEventStores(store0, store1) {\n    return {\n        defs: Object.assign(Object.assign({}, store0.defs), store1.defs),\n        instances: Object.assign(Object.assign({}, store0.instances), store1.instances)\n    };\n}\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n    let defs = filterHash(eventStore.defs, filterFunc);\n    let instances = filterHash(eventStore.instances, (instance)=>defs[instance.defId] // still exists?\n    );\n    return {\n        defs,\n        instances\n    };\n}\nfunction excludeSubEventStore(master, sub) {\n    let { defs, instances } = master;\n    let filteredDefs = {};\n    let filteredInstances = {};\n    for(let defId in defs){\n        if (!sub.defs[defId]) {\n            filteredDefs[defId] = defs[defId];\n        }\n    }\n    for(let instanceId in instances){\n        if (!sub.instances[instanceId] && // not explicitly excluded\n        filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n        ) {\n            filteredInstances[instanceId] = instances[instanceId];\n        }\n    }\n    return {\n        defs: filteredDefs,\n        instances: filteredInstances\n    };\n}\nfunction normalizeConstraint(input, context) {\n    if (Array.isArray(input)) {\n        return parseEvents(input, null, context, true); // allowOpenRange=true\n    }\n    if (typeof input === \"object\" && input) {\n        return parseEvents([\n            input\n        ], null, context, true); // allowOpenRange=true\n    }\n    if (input != null) {\n        return String(input);\n    }\n    return null;\n}\nfunction parseClassNames(raw) {\n    if (Array.isArray(raw)) {\n        return raw;\n    }\n    if (typeof raw === \"string\") {\n        return raw.split(/\\s+/);\n    }\n    return [];\n}\n// TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\nconst EVENT_UI_REFINERS = {\n    display: String,\n    editable: Boolean,\n    startEditable: Boolean,\n    durationEditable: Boolean,\n    constraint: identity,\n    overlap: identity,\n    allow: identity,\n    className: parseClassNames,\n    classNames: parseClassNames,\n    color: String,\n    backgroundColor: String,\n    borderColor: String,\n    textColor: String\n};\nconst EMPTY_EVENT_UI = {\n    display: null,\n    startEditable: null,\n    durationEditable: null,\n    constraints: [],\n    overlap: null,\n    allows: [],\n    backgroundColor: \"\",\n    borderColor: \"\",\n    textColor: \"\",\n    classNames: []\n};\nfunction createEventUi(refined, context) {\n    let constraint = normalizeConstraint(refined.constraint, context);\n    return {\n        display: refined.display || null,\n        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n        constraints: constraint != null ? [\n            constraint\n        ] : [],\n        overlap: refined.overlap != null ? refined.overlap : null,\n        allows: refined.allow != null ? [\n            refined.allow\n        ] : [],\n        backgroundColor: refined.backgroundColor || refined.color || \"\",\n        borderColor: refined.borderColor || refined.color || \"\",\n        textColor: refined.textColor || \"\",\n        classNames: (refined.className || []).concat(refined.classNames || [])\n    };\n}\n// TODO: prevent against problems with <2 args!\nfunction combineEventUis(uis) {\n    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\nfunction combineTwoEventUis(item0, item1) {\n    return {\n        display: item1.display != null ? item1.display : item0.display,\n        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n        constraints: item0.constraints.concat(item1.constraints),\n        overlap: typeof item1.overlap === \"boolean\" ? item1.overlap : item0.overlap,\n        allows: item0.allows.concat(item1.allows),\n        backgroundColor: item1.backgroundColor || item0.backgroundColor,\n        borderColor: item1.borderColor || item0.borderColor,\n        textColor: item1.textColor || item0.textColor,\n        classNames: item0.classNames.concat(item1.classNames)\n    };\n}\nconst EVENT_SOURCE_REFINERS = {\n    id: String,\n    defaultAllDay: Boolean,\n    url: String,\n    format: String,\n    events: identity,\n    eventDataTransform: identity,\n    // for any network-related sources\n    success: identity,\n    failure: identity\n};\nfunction parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {\n    let rawObj;\n    if (typeof raw === \"string\") {\n        rawObj = {\n            url: raw\n        };\n    } else if (typeof raw === \"function\" || Array.isArray(raw)) {\n        rawObj = {\n            events: raw\n        };\n    } else if (typeof raw === \"object\" && raw) {\n        rawObj = raw;\n    }\n    if (rawObj) {\n        let { refined, extra } = refineProps(rawObj, refiners);\n        let metaRes = buildEventSourceMeta(refined, context);\n        if (metaRes) {\n            return {\n                _raw: raw,\n                isFetching: false,\n                latestFetchId: \"\",\n                fetchRange: null,\n                defaultAllDay: refined.defaultAllDay,\n                eventDataTransform: refined.eventDataTransform,\n                success: refined.success,\n                failure: refined.failure,\n                publicId: refined.id || \"\",\n                sourceId: guid(),\n                sourceDefId: metaRes.sourceDefId,\n                meta: metaRes.meta,\n                ui: createEventUi(refined, context),\n                extendedProps: extra\n            };\n        }\n    }\n    return null;\n}\nfunction buildEventSourceRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\nfunction buildEventSourceMeta(raw, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    for(let i = defs.length - 1; i >= 0; i -= 1){\n        let def = defs[i];\n        let meta = def.parseMeta(raw);\n        if (meta) {\n            return {\n                sourceDefId: i,\n                meta\n            };\n        }\n    }\n    return null;\n}\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n    switch(action.type){\n        case \"RECEIVE_EVENTS\":\n            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n        case \"RESET_RAW_EVENTS\":\n            return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);\n        case \"ADD_EVENTS\":\n            return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n        case \"RESET_EVENTS\":\n            return action.eventStore;\n        case \"MERGE_EVENTS\":\n            return mergeEventStores(eventStore, action.eventStore);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return expandRecurring(eventStore, dateProfile.activeRange, context);\n            }\n            return eventStore;\n        case \"REMOVE_EVENTS\":\n            return excludeSubEventStore(eventStore, action.eventStore);\n        case \"REMOVE_EVENT_SOURCE\":\n            return excludeEventsBySourceId(eventStore, action.sourceId);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return filterEventStoreDefs(eventStore, (eventDef)=>!eventDef.sourceId // only keep events with no source id\n            );\n        case \"REMOVE_ALL_EVENTS\":\n            return createEmptyEventStore();\n        default:\n            return eventStore;\n    }\n}\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n    ) {\n        let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n        if (fetchRange) {\n            subset = expandRecurring(subset, fetchRange, context);\n        }\n        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n    return eventStore;\n}\nfunction resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {\n    const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);\n    let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);\n    return expandRecurring(newEventStore, activeRange, context);\n}\nfunction transformRawEvents(rawEvents, eventSource, context) {\n    let calEachTransform = context.options.eventDataTransform;\n    let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n    if (sourceEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n    }\n    if (calEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n    }\n    return rawEvents;\n}\nfunction transformEachRawEvent(rawEvents, func) {\n    let refinedEvents;\n    if (!func) {\n        refinedEvents = rawEvents;\n    } else {\n        refinedEvents = [];\n        for (let rawEvent of rawEvents){\n            let refinedEvent = func(rawEvent);\n            if (refinedEvent) {\n                refinedEvents.push(refinedEvent);\n            } else if (refinedEvent == null) {\n                refinedEvents.push(rawEvent);\n            } // if a different falsy value, do nothing\n        }\n    }\n    return refinedEvents;\n}\nfunction addEvent(eventStore, subset, expandRange, context) {\n    if (expandRange) {\n        subset = expandRecurring(subset, expandRange, context);\n    }\n    return mergeEventStores(eventStore, subset);\n}\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n    let { defs } = eventStore;\n    let instances = mapHash(eventStore.instances, (instance)=>{\n        let def = defs[instance.defId];\n        if (def.allDay) {\n            return instance; // isn't dependent on timezone\n        }\n        return Object.assign(Object.assign({}, instance), {\n            range: {\n                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n            },\n            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n        });\n    });\n    return {\n        defs,\n        instances\n    };\n}\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n    return filterEventStoreDefs(eventStore, (eventDef)=>eventDef.sourceId !== sourceId);\n}\n// QUESTION: why not just return instances? do a general object-property-exclusion util\nfunction excludeInstances(eventStore, removals) {\n    return {\n        defs: eventStore.defs,\n        instances: filterHash(eventStore.instances, (instance)=>!removals[instance.instanceId])\n    };\n}\nfunction buildPublicIdMaps(eventStore) {\n    const { defs, instances } = eventStore;\n    const defIdMap = {};\n    const instanceIdMap = {};\n    for(let defId in defs){\n        const def = defs[defId];\n        const { publicId } = def;\n        if (publicId) {\n            defIdMap[publicId] = defId;\n        }\n    }\n    for(let instanceId in instances){\n        const instance = instances[instanceId];\n        const def = defs[instance.defId];\n        const { publicId } = def;\n        if (publicId) {\n            instanceIdMap[publicId] = instanceId;\n        }\n    }\n    return {\n        defIdMap,\n        instanceIdMap\n    };\n}\nclass Emitter {\n    constructor(){\n        this.handlers = {};\n        this.thisContext = null;\n    }\n    setThisContext(thisContext) {\n        this.thisContext = thisContext;\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    on(type, handler) {\n        addToHash(this.handlers, type, handler);\n    }\n    off(type, handler) {\n        removeFromHash(this.handlers, type, handler);\n    }\n    trigger(type, ...args) {\n        let attachedHandlers = this.handlers[type] || [];\n        let optionHandler = this.options && this.options[type];\n        let handlers = [].concat(optionHandler || [], attachedHandlers);\n        for (let handler of handlers){\n            handler.apply(this.thisContext, args);\n        }\n    }\n    hasHandlers(type) {\n        return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n    }\n}\nfunction addToHash(hash, type, handler) {\n    (hash[type] || (hash[type] = [])).push(handler);\n}\nfunction removeFromHash(hash, type, handler) {\n    if (handler) {\n        if (hash[type]) {\n            hash[type] = hash[type].filter((func)=>func !== handler);\n        }\n    } else {\n        delete hash[type]; // remove all handler funcs for this type\n    }\n}\nconst DEF_DEFAULTS = {\n    startTime: \"09:00\",\n    endTime: \"17:00\",\n    daysOfWeek: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    display: \"inverse-background\",\n    classNames: \"fc-non-business\",\n    groupId: \"_businessHours\"\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/ function parseBusinessHours(input, context) {\n    return parseEvents(refineInputs(input), null, context);\n}\nfunction refineInputs(input) {\n    let rawDefs;\n    if (input === true) {\n        rawDefs = [\n            {}\n        ]; // will get DEF_DEFAULTS verbatim\n    } else if (Array.isArray(input)) {\n        // if specifying an array, every sub-definition NEEDS a day-of-week\n        rawDefs = input.filter((rawDef)=>rawDef.daysOfWeek);\n    } else if (typeof input === \"object\" && input) {\n        rawDefs = [\n            input\n        ];\n    } else {\n        rawDefs = [];\n    }\n    rawDefs = rawDefs.map((rawDef)=>Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));\n    return rawDefs;\n}\nfunction triggerDateSelect(selection, pev, context) {\n    context.emitter.trigger(\"select\", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    }));\n}\nfunction triggerDateUnselect(pev, context) {\n    context.emitter.trigger(\"unselect\", {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    });\n}\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n    let props = {};\n    for (let transform of context.pluginHooks.dateSpanTransforms){\n        Object.assign(props, transform(dateSpan, context));\n    }\n    Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n    return props;\n}\n// Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\nfunction getDefaultEventEnd(allDay, marker, context) {\n    let { dateEnv, options } = context;\n    let end = marker;\n    if (allDay) {\n        end = startOfDay(end);\n        end = dateEnv.add(end, options.defaultAllDayEventDuration);\n    } else {\n        end = dateEnv.add(end, options.defaultTimedEventDuration);\n    }\n    return end;\n}\n// applies the mutation to ALL defs/instances within the event store\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n    let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n    let dest = createEmptyEventStore();\n    for(let defId in eventStore.defs){\n        let def = eventStore.defs[defId];\n        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n    }\n    for(let instanceId in eventStore.instances){\n        let instance = eventStore.instances[instanceId];\n        let def = dest.defs[instance.defId]; // important to grab the newly modified def\n        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n    }\n    return dest;\n}\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n    let standardProps = mutation.standardProps || {};\n    // if hasEnd has not been specified, guess a good value based on deltas.\n    // if duration will change, there's no way the default duration will persist,\n    // and thus, we need to mark the event as having a real end\n    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n        standardProps.hasEnd = true; // TODO: is this mutation okay?\n    }\n    let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), {\n        ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui)\n    });\n    if (mutation.extendedProps) {\n        copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);\n    }\n    for (let applier of context.pluginHooks.eventDefMutationAppliers){\n        applier(copy, mutation, context);\n    }\n    if (!copy.hasEnd && context.options.forceEventDuration) {\n        copy.hasEnd = true;\n    }\n    return copy;\n}\nfunction applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n    let { dateEnv } = context;\n    let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n    let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n    let copy = Object.assign({}, eventInstance);\n    if (forceAllDay) {\n        copy.range = computeAlignedDayRange(copy.range);\n    }\n    if (mutation.datesDelta && eventConfig.startEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.datesDelta),\n            end: dateEnv.add(copy.range.end, mutation.datesDelta)\n        };\n    }\n    if (mutation.startDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.startDelta),\n            end: copy.range.end\n        };\n    }\n    if (mutation.endDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: copy.range.start,\n            end: dateEnv.add(copy.range.end, mutation.endDelta)\n        };\n    }\n    if (clearEnd) {\n        copy.range = {\n            start: copy.range.start,\n            end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n        };\n    }\n    // in case event was all-day but the supplied deltas were not\n    // better util for this?\n    if (eventDef.allDay) {\n        copy.range = {\n            start: startOfDay(copy.range.start),\n            end: startOfDay(copy.range.end)\n        };\n    }\n    // handle invalid durations\n    if (copy.range.end < copy.range.start) {\n        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n    }\n    return copy;\n}\nclass EventSourceImpl {\n    constructor(context, internalEventSource){\n        this.context = context;\n        this.internalEventSource = internalEventSource;\n    }\n    remove() {\n        this.context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: this.internalEventSource.sourceId\n        });\n    }\n    refetch() {\n        this.context.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            sourceIds: [\n                this.internalEventSource.sourceId\n            ],\n            isRefetch: true\n        });\n    }\n    get id() {\n        return this.internalEventSource.publicId;\n    }\n    get url() {\n        return this.internalEventSource.meta.url;\n    }\n    get format() {\n        return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    }\n}\nclass EventImpl {\n    // instance will be null if expressing a recurring event that has no current instances,\n    // OR if trying to validate an incoming external event that has no dates assigned\n    constructor(context, def, instance){\n        this._context = context;\n        this._def = def;\n        this._instance = instance || null;\n    }\n    /*\n    TODO: make event struct more responsible for this\n    */ setProp(name, val) {\n        if (name in EVENT_DATE_REFINERS) {\n            console.warn(\"Could not set date-related prop 'name'. Use one of the date-related methods instead.\");\n        // TODO: make proper aliasing system?\n        } else if (name === \"id\") {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    publicId: val\n                }\n            });\n        } else if (name in EVENT_NON_DATE_REFINERS) {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    [name]: val\n                }\n            });\n        } else if (name in EVENT_UI_REFINERS) {\n            let ui = EVENT_UI_REFINERS[name](val);\n            if (name === \"color\") {\n                ui = {\n                    backgroundColor: val,\n                    borderColor: val\n                };\n            } else if (name === \"editable\") {\n                ui = {\n                    startEditable: val,\n                    durationEditable: val\n                };\n            } else {\n                ui = {\n                    [name]: val\n                };\n            }\n            this.mutate({\n                standardProps: {\n                    ui\n                }\n            });\n        } else {\n            console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);\n        }\n    }\n    setExtendedProp(name, val) {\n        this.mutate({\n            extendedProps: {\n                [name]: val\n            }\n        });\n    }\n    setStart(startInput, options = {}) {\n        let { dateEnv } = this._context;\n        let start = dateEnv.createMarker(startInput);\n        if (start && this._instance) {\n            let instanceRange = this._instance.range;\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n            if (options.maintainDuration) {\n                this.mutate({\n                    datesDelta: startDelta\n                });\n            } else {\n                this.mutate({\n                    startDelta\n                });\n            }\n        }\n    }\n    setEnd(endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let end;\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return; // TODO: warning if parsed bad\n            }\n        }\n        if (this._instance) {\n            if (end) {\n                let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                this.mutate({\n                    endDelta\n                });\n            } else {\n                this.mutate({\n                    standardProps: {\n                        hasEnd: false\n                    }\n                });\n            }\n        }\n    }\n    setDates(startInput, endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let standardProps = {\n            allDay: options.allDay\n        };\n        let start = dateEnv.createMarker(startInput);\n        let end;\n        if (!start) {\n            return; // TODO: warning if parsed bad\n        }\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return;\n            }\n        }\n        if (this._instance) {\n            let instanceRange = this._instance.range;\n            // when computing the diff for an event being converted to all-day,\n            // compute diff off of the all-day values the way event-mutation does.\n            if (options.allDay === true) {\n                instanceRange = computeAlignedDayRange(instanceRange);\n            }\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n            if (end) {\n                let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                if (durationsEqual(startDelta, endDelta)) {\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps\n                    });\n                } else {\n                    this.mutate({\n                        startDelta,\n                        endDelta,\n                        standardProps\n                    });\n                }\n            } else {\n                standardProps.hasEnd = false;\n                this.mutate({\n                    datesDelta: startDelta,\n                    standardProps\n                });\n            }\n        }\n    }\n    moveStart(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                startDelta: delta\n            });\n        }\n    }\n    moveEnd(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                endDelta: delta\n            });\n        }\n    }\n    moveDates(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                datesDelta: delta\n            });\n        }\n    }\n    setAllDay(allDay, options = {}) {\n        let standardProps = {\n            allDay\n        };\n        let { maintainDuration } = options;\n        if (maintainDuration == null) {\n            maintainDuration = this._context.options.allDayMaintainDuration;\n        }\n        if (this._def.allDay !== allDay) {\n            standardProps.hasEnd = maintainDuration;\n        }\n        this.mutate({\n            standardProps\n        });\n    }\n    formatRange(formatInput) {\n        let { dateEnv } = this._context;\n        let instance = this._instance;\n        let formatter = createFormatter(formatInput);\n        if (this._def.hasEnd) {\n            return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                forcedStartTzo: instance.forcedStartTzo,\n                forcedEndTzo: instance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(instance.range.start, formatter, {\n            forcedTzo: instance.forcedStartTzo\n        });\n    }\n    mutate(mutation) {\n        let instance = this._instance;\n        if (instance) {\n            let def = this._def;\n            let context = this._context;\n            let { eventStore } = context.getCurrentData();\n            let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);\n            let eventConfigBase = {\n                \"\": {\n                    display: \"\",\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: \"\",\n                    borderColor: \"\",\n                    textColor: \"\",\n                    classNames: []\n                }\n            };\n            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);\n            let oldEvent = new EventImpl(context, def, instance); // snapshot\n            this._def = relevantEvents.defs[def.defId];\n            this._instance = relevantEvents.instances[instance.instanceId];\n            context.dispatch({\n                type: \"MERGE_EVENTS\",\n                eventStore: relevantEvents\n            });\n            context.emitter.trigger(\"eventChange\", {\n                oldEvent,\n                event: this,\n                relatedEvents: buildEventApis(relevantEvents, context, instance),\n                revert () {\n                    context.dispatch({\n                        type: \"RESET_EVENTS\",\n                        eventStore\n                    });\n                }\n            });\n        }\n    }\n    remove() {\n        let context = this._context;\n        let asStore = eventApiToStore(this);\n        context.dispatch({\n            type: \"REMOVE_EVENTS\",\n            eventStore: asStore\n        });\n        context.emitter.trigger(\"eventRemove\", {\n            event: this,\n            relatedEvents: [],\n            revert () {\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: asStore\n                });\n            }\n        });\n    }\n    get source() {\n        let { sourceId } = this._def;\n        if (sourceId) {\n            return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);\n        }\n        return null;\n    }\n    get start() {\n        return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    }\n    get end() {\n        return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    }\n    get startStr() {\n        let instance = this._instance;\n        if (instance) {\n            return this._context.dateEnv.formatIso(instance.range.start, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedStartTzo\n            });\n        }\n        return \"\";\n    }\n    get endStr() {\n        let instance = this._instance;\n        if (instance && this._def.hasEnd) {\n            return this._context.dateEnv.formatIso(instance.range.end, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedEndTzo\n            });\n        }\n        return \"\";\n    }\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get id() {\n        return this._def.publicId;\n    }\n    get groupId() {\n        return this._def.groupId;\n    }\n    get allDay() {\n        return this._def.allDay;\n    }\n    get title() {\n        return this._def.title;\n    }\n    get url() {\n        return this._def.url;\n    }\n    get display() {\n        return this._def.ui.display || \"auto\";\n    }\n    get startEditable() {\n        return this._def.ui.startEditable;\n    }\n    get durationEditable() {\n        return this._def.ui.durationEditable;\n    }\n    get constraint() {\n        return this._def.ui.constraints[0] || null;\n    }\n    get overlap() {\n        return this._def.ui.overlap;\n    }\n    get allow() {\n        return this._def.ui.allows[0] || null;\n    }\n    get backgroundColor() {\n        return this._def.ui.backgroundColor;\n    }\n    get borderColor() {\n        return this._def.ui.borderColor;\n    }\n    get textColor() {\n        return this._def.ui.textColor;\n    }\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get classNames() {\n        return this._def.ui.classNames;\n    }\n    get extendedProps() {\n        return this._def.extendedProps;\n    }\n    toPlainObject(settings = {}) {\n        let def = this._def;\n        let { ui } = def;\n        let { startStr, endStr } = this;\n        let res = {\n            allDay: def.allDay\n        };\n        if (def.title) {\n            res.title = def.title;\n        }\n        if (startStr) {\n            res.start = startStr;\n        }\n        if (endStr) {\n            res.end = endStr;\n        }\n        if (def.publicId) {\n            res.id = def.publicId;\n        }\n        if (def.groupId) {\n            res.groupId = def.groupId;\n        }\n        if (def.url) {\n            res.url = def.url;\n        }\n        if (ui.display && ui.display !== \"auto\") {\n            res.display = ui.display;\n        }\n        // TODO: what about recurring-event properties???\n        // TODO: include startEditable/durationEditable/constraint/overlap/allow\n        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n            res.color = ui.backgroundColor;\n        } else {\n            if (ui.backgroundColor) {\n                res.backgroundColor = ui.backgroundColor;\n            }\n            if (ui.borderColor) {\n                res.borderColor = ui.borderColor;\n            }\n        }\n        if (ui.textColor) {\n            res.textColor = ui.textColor;\n        }\n        if (ui.classNames.length) {\n            res.classNames = ui.classNames;\n        }\n        if (Object.keys(def.extendedProps).length) {\n            if (settings.collapseExtendedProps) {\n                Object.assign(res, def.extendedProps);\n            } else {\n                res.extendedProps = def.extendedProps;\n            }\n        }\n        return res;\n    }\n    toJSON() {\n        return this.toPlainObject();\n    }\n}\nfunction eventApiToStore(eventApi) {\n    let def = eventApi._def;\n    let instance = eventApi._instance;\n    return {\n        defs: {\n            [def.defId]: def\n        },\n        instances: instance ? {\n            [instance.instanceId]: instance\n        } : {}\n    };\n}\nfunction buildEventApis(eventStore, context, excludeInstance) {\n    let { defs, instances } = eventStore;\n    let eventApis = [];\n    let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : \"\";\n    for(let id in instances){\n        let instance = instances[id];\n        let def = defs[instance.defId];\n        if (instance.instanceId !== excludeInstanceId) {\n            eventApis.push(new EventImpl(context, def, instance));\n        }\n    }\n    return eventApis;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n    let inverseBgByGroupId = {};\n    let inverseBgByDefId = {};\n    let defByGroupId = {};\n    let bgRanges = [];\n    let fgRanges = [];\n    let eventUis = compileEventUis(eventStore.defs, eventUiBases);\n    for(let defId in eventStore.defs){\n        let def = eventStore.defs[defId];\n        let ui = eventUis[def.defId];\n        if (ui.display === \"inverse-background\") {\n            if (def.groupId) {\n                inverseBgByGroupId[def.groupId] = [];\n                if (!defByGroupId[def.groupId]) {\n                    defByGroupId[def.groupId] = def;\n                }\n            } else {\n                inverseBgByDefId[defId] = [];\n            }\n        }\n    }\n    for(let instanceId in eventStore.instances){\n        let instance = eventStore.instances[instanceId];\n        let def = eventStore.defs[instance.defId];\n        let ui = eventUis[def.defId];\n        let origRange = instance.range;\n        let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n        let slicedRange = intersectRanges(normalRange, framingRange);\n        if (slicedRange) {\n            if (ui.display === \"inverse-background\") {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId].push(slicedRange);\n                } else {\n                    inverseBgByDefId[instance.defId].push(slicedRange);\n                }\n            } else if (ui.display !== \"none\") {\n                (ui.display === \"background\" ? bgRanges : fgRanges).push({\n                    def,\n                    ui,\n                    instance,\n                    range: slicedRange,\n                    isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                    isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                });\n            }\n        }\n    }\n    for(let groupId in inverseBgByGroupId){\n        let ranges = inverseBgByGroupId[groupId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges){\n            let def = defByGroupId[groupId];\n            let ui = eventUis[def.defId];\n            bgRanges.push({\n                def,\n                ui,\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    for(let defId in inverseBgByDefId){\n        let ranges = inverseBgByDefId[defId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges){\n            bgRanges.push({\n                def: eventStore.defs[defId],\n                ui: eventUis[defId],\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    return {\n        bg: bgRanges,\n        fg: fgRanges\n    };\n}\nfunction hasBgRendering(def) {\n    return def.ui.display === \"background\" || def.ui.display === \"inverse-background\";\n}\nfunction setElSeg(el, seg) {\n    el.fcSeg = seg;\n}\nfunction getElSeg(el) {\n    return el.fcSeg || el.parentNode.fcSeg || // for the harness\n    null;\n}\n// event ui computation\nfunction compileEventUis(eventDefs, eventUiBases) {\n    return mapHash(eventDefs, (eventDef)=>compileEventUi(eventDef, eventUiBases));\n}\nfunction compileEventUi(eventDef, eventUiBases) {\n    let uis = [];\n    if (eventUiBases[\"\"]) {\n        uis.push(eventUiBases[\"\"]);\n    }\n    if (eventUiBases[eventDef.defId]) {\n        uis.push(eventUiBases[eventDef.defId]);\n    }\n    uis.push(eventDef.ui);\n    return combineEventUis(uis);\n}\nfunction sortEventSegs(segs, eventOrderSpecs) {\n    let objs = segs.map(buildSegCompareObj);\n    objs.sort((obj0, obj1)=>compareByFieldSpecs(obj0, obj1, eventOrderSpecs));\n    return objs.map((c)=>c._seg);\n}\n// returns a object with all primitive props that can be compared\nfunction buildSegCompareObj(seg) {\n    let { eventRange } = seg;\n    let eventDef = eventRange.def;\n    let range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n    let start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n    let end = range.end ? range.end.valueOf() : 0; // \"\n    return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {\n        id: eventDef.publicId,\n        start,\n        end,\n        duration: end - start,\n        allDay: Number(eventDef.allDay),\n        _seg: seg\n    });\n}\nfunction computeSegDraggable(seg, context) {\n    let { pluginHooks } = context;\n    let transformers = pluginHooks.isDraggableTransformers;\n    let { def, ui } = seg.eventRange;\n    let val = ui.startEditable;\n    for (let transformer of transformers){\n        val = transformer(val, def, ui, context);\n    }\n    return val;\n}\nfunction computeSegStartResizable(seg, context) {\n    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\nfunction computeSegEndResizable(seg, context) {\n    return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n    let { dateEnv, options } = context;\n    let { displayEventTime, displayEventEnd } = options;\n    let eventDef = seg.eventRange.def;\n    let eventInstance = seg.eventRange.instance;\n    if (displayEventTime == null) {\n        displayEventTime = defaultDisplayEventTime !== false;\n    }\n    if (displayEventEnd == null) {\n        displayEventEnd = defaultDisplayEventEnd !== false;\n    }\n    let wholeEventStart = eventInstance.range.start;\n    let wholeEventEnd = eventInstance.range.end;\n    let segStart = startOverride || seg.start || seg.eventRange.range.start;\n    let segEnd = endOverride || seg.end || seg.eventRange.range.end;\n    let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n    let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n        segStart = isStartDay ? wholeEventStart : segStart;\n        segEnd = isEndDay ? wholeEventEnd : segEnd;\n        if (displayEventEnd && eventDef.hasEnd) {\n            return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(segStart, timeFormat, {\n            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n        });\n    }\n    return \"\";\n}\nfunction getSegMeta(seg, todayRange, nowDate) {\n    let segRange = seg.eventRange.range;\n    return {\n        isPast: segRange.end <= (nowDate || todayRange.start),\n        isFuture: segRange.start >= (nowDate || todayRange.end),\n        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n    };\n}\nfunction getEventClassNames(props) {\n    let classNames = [\n        \"fc-event\"\n    ];\n    if (props.isMirror) {\n        classNames.push(\"fc-event-mirror\");\n    }\n    if (props.isDraggable) {\n        classNames.push(\"fc-event-draggable\");\n    }\n    if (props.isStartResizable || props.isEndResizable) {\n        classNames.push(\"fc-event-resizable\");\n    }\n    if (props.isDragging) {\n        classNames.push(\"fc-event-dragging\");\n    }\n    if (props.isResizing) {\n        classNames.push(\"fc-event-resizing\");\n    }\n    if (props.isSelected) {\n        classNames.push(\"fc-event-selected\");\n    }\n    if (props.isStart) {\n        classNames.push(\"fc-event-start\");\n    }\n    if (props.isEnd) {\n        classNames.push(\"fc-event-end\");\n    }\n    if (props.isPast) {\n        classNames.push(\"fc-event-past\");\n    }\n    if (props.isToday) {\n        classNames.push(\"fc-event-today\");\n    }\n    if (props.isFuture) {\n        classNames.push(\"fc-event-future\");\n    }\n    return classNames;\n}\nfunction buildEventRangeKey(eventRange) {\n    return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;\n// inverse-background events don't have specific instances. TODO: better solution\n}\nfunction getSegAnchorAttrs(seg, context) {\n    let { def, instance } = seg.eventRange;\n    let { url } = def;\n    if (url) {\n        return {\n            href: url\n        };\n    }\n    let { emitter, options } = context;\n    let { eventInteractive } = options;\n    if (eventInteractive == null) {\n        eventInteractive = def.interactive;\n        if (eventInteractive == null) {\n            eventInteractive = Boolean(emitter.hasHandlers(\"eventClick\"));\n        }\n    }\n    // mock what happens in EventClicking\n    if (eventInteractive) {\n        // only attach keyboard-related handlers because click handler is already done in EventClicking\n        return createAriaKeyboardAttrs((ev)=>{\n            emitter.trigger(\"eventClick\", {\n                el: ev.target,\n                event: new EventImpl(context, def, instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        });\n    }\n    return {};\n}\nconst STANDARD_PROPS = {\n    start: identity,\n    end: identity,\n    allDay: Boolean\n};\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n    let span = parseOpenDateSpan(raw, dateEnv);\n    let { range } = span;\n    if (!range.start) {\n        return null;\n    }\n    if (!range.end) {\n        if (defaultDuration == null) {\n            return null;\n        }\n        range.end = dateEnv.add(range.start, defaultDuration);\n    }\n    return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/ function parseOpenDateSpan(raw, dateEnv) {\n    let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);\n    let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n    let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n    let { allDay } = standardProps;\n    if (allDay == null) {\n        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n    }\n    return Object.assign({\n        range: {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null\n        },\n        allDay\n    }, extra);\n}\nfunction isDateSpansEqual(span0, span1) {\n    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n}\n// the NON-DATE-RELATED props\nfunction isSpanPropsEqual(span0, span1) {\n    for(let propName in span1){\n        if (propName !== \"range\" && propName !== \"allDay\") {\n            if (span0[propName] !== span1[propName]) {\n                return false;\n            }\n        }\n    }\n    // are there any props that span0 has that span1 DOESN'T have?\n    // both have range/allDay, so no need to special-case.\n    for(let propName in span0){\n        if (!(propName in span1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildDateSpanApi(span, dateEnv) {\n    return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n        allDay: span.allDay\n    });\n}\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n    return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n        timeZone: dateEnv.timeZone\n    });\n}\nfunction buildRangeApi(range, dateEnv, omitTime) {\n    return {\n        start: dateEnv.toDate(range.start),\n        end: dateEnv.toDate(range.end),\n        startStr: dateEnv.formatIso(range.start, {\n            omitTime\n        }),\n        endStr: dateEnv.formatIso(range.end, {\n            omitTime\n        })\n    };\n}\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n    let res = refineEventDef({\n        editable: false\n    }, context);\n    let def = parseEventDef(res.refined, res.extra, \"\", dateSpan.allDay, true, context);\n    return {\n        def,\n        ui: compileEventUi(def, eventUiBases),\n        instance: createEventInstance(def.defId, dateSpan.range),\n        range: dateSpan.range,\n        isStart: true,\n        isEnd: true\n    };\n}\n/*\ngiven a function that resolves a result asynchronously.\nthe function can either call passed-in success and failure callbacks,\nor it can return a promise.\nif you need to pass additional params to func, bind them first.\n*/ function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {\n    // guard against success/failure callbacks being called more than once\n    // and guard against a promise AND callback being used together.\n    let isResolved = false;\n    let wrappedSuccess = function(res) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedSuccessCallback(res);\n        }\n    };\n    let wrappedFailure = function(error) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedFailureCallback(error);\n        }\n    };\n    let res = func(wrappedSuccess, wrappedFailure);\n    if (res && typeof res.then === \"function\") {\n        res.then(wrappedSuccess, wrappedFailure);\n    }\n}\nclass JsonRequestError extends Error {\n    constructor(message, response){\n        super(message);\n        this.response = response;\n    }\n}\nfunction requestJson(method, url, params) {\n    method = method.toUpperCase();\n    const fetchOptions = {\n        method\n    };\n    if (method === \"GET\") {\n        url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + new URLSearchParams(params);\n    } else {\n        fetchOptions.body = new URLSearchParams(params);\n        fetchOptions.headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n    }\n    return fetch(url, fetchOptions).then((fetchRes)=>{\n        if (fetchRes.ok) {\n            return fetchRes.json().then((parsedResponse)=>{\n                return [\n                    parsedResponse,\n                    fetchRes\n                ];\n            }, ()=>{\n                throw new JsonRequestError(\"Failure parsing JSON\", fetchRes);\n            });\n        } else {\n            throw new JsonRequestError(\"Request failed\", fetchRes);\n        }\n    });\n}\nlet canVGrowWithinCell;\nfunction getCanVGrowWithinCell() {\n    if (canVGrowWithinCell == null) {\n        canVGrowWithinCell = computeCanVGrowWithinCell();\n    }\n    return canVGrowWithinCell;\n}\nfunction computeCanVGrowWithinCell() {\n    // for SSR, because this function is call immediately at top-level\n    // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    let el = document.createElement(\"div\");\n    el.style.position = \"absolute\";\n    el.style.top = \"0px\";\n    el.style.left = \"0px\";\n    el.innerHTML = \"<table><tr><td><div></div></td></tr></table>\";\n    el.querySelector(\"table\").style.height = \"100px\";\n    el.querySelector(\"div\").style.height = \"100%\";\n    document.body.appendChild(el);\n    let div = el.querySelector(\"div\");\n    let possible = div.offsetHeight > 0;\n    document.body.removeChild(el);\n    return possible;\n}\nclass CalendarRoot extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            forPrint: false\n        };\n        this.handleBeforePrint = ()=>{\n            flushSync(()=>{\n                this.setState({\n                    forPrint: true\n                });\n            });\n        };\n        this.handleAfterPrint = ()=>{\n            flushSync(()=>{\n                this.setState({\n                    forPrint: false\n                });\n            });\n        };\n    }\n    render() {\n        let { props } = this;\n        let { options } = props;\n        let { forPrint } = this.state;\n        let isHeightAuto = forPrint || options.height === \"auto\" || options.contentHeight === \"auto\";\n        let height = !isHeightAuto && options.height != null ? options.height : \"\";\n        let classNames = [\n            \"fc\",\n            forPrint ? \"fc-media-print\" : \"fc-media-screen\",\n            `fc-direction-${options.direction}`,\n            props.theme.getClass(\"root\")\n        ];\n        if (!getCanVGrowWithinCell()) {\n            classNames.push(\"fc-liquid-hack\");\n        }\n        return props.children(classNames, height, isHeightAuto, forPrint);\n    }\n    componentDidMount() {\n        let { emitter } = this.props;\n        emitter.on(\"_beforeprint\", this.handleBeforePrint);\n        emitter.on(\"_afterprint\", this.handleAfterPrint);\n    }\n    componentWillUnmount() {\n        let { emitter } = this.props;\n        emitter.off(\"_beforeprint\", this.handleBeforePrint);\n        emitter.off(\"_afterprint\", this.handleAfterPrint);\n    }\n}\nclass Interaction {\n    constructor(settings){\n        this.component = settings.component;\n        this.isHitComboAllowed = settings.isHitComboAllowed || null;\n    }\n    destroy() {}\n}\nfunction parseInteractionSettings(component, input) {\n    return {\n        component,\n        el: input.el,\n        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        isHitComboAllowed: input.isHitComboAllowed || null\n    };\n}\nfunction interactionSettingsToStore(settings) {\n    return {\n        [settings.component.uid]: settings\n    };\n}\n// global state\nconst interactionSettingsStore = {};\nclass NowTimer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props, context){\n        super(props, context);\n        this.handleRefresh = ()=>{\n            let timing = this.computeTiming();\n            if (timing.state.nowDate.valueOf() !== this.state.nowDate.valueOf()) {\n                this.setState(timing.state);\n            }\n            this.clearTimeout();\n            this.setTimeout(timing.waitMs);\n        };\n        this.handleVisibilityChange = ()=>{\n            if (!document.hidden) {\n                this.handleRefresh();\n            }\n        };\n        this.state = this.computeTiming().state;\n    }\n    render() {\n        let { props, state } = this;\n        return props.children(state.nowDate, state.todayRange);\n    }\n    componentDidMount() {\n        this.setTimeout();\n        this.context.nowManager.addResetListener(this.handleRefresh);\n        // fired tab becomes visible after being hidden\n        document.addEventListener(\"visibilitychange\", this.handleVisibilityChange);\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.unit !== this.props.unit) {\n            this.clearTimeout();\n            this.setTimeout();\n        }\n    }\n    componentWillUnmount() {\n        this.clearTimeout();\n        this.context.nowManager.removeResetListener(this.handleRefresh);\n        document.removeEventListener(\"visibilitychange\", this.handleVisibilityChange);\n    }\n    computeTiming() {\n        let { props, context } = this;\n        let unroundedNow = context.nowManager.getDateMarker();\n        let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n        let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n        let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n        // ensure no longer than a day\n        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n        return {\n            state: {\n                nowDate: currentUnitStart,\n                todayRange: buildDayRange(currentUnitStart)\n            },\n            waitMs\n        };\n    }\n    setTimeout(waitMs = this.computeTiming().waitMs) {\n        // NOTE: timeout could take longer than expected if tab sleeps,\n        // which is why we listen to 'visibilitychange'\n        this.timeoutId = setTimeout(()=>{\n            // NOTE: timeout could also return *earlier* than expected, and we need to wait 2 ms more\n            // This is why use use same waitMs from computeTiming, so we don't skip an interval while\n            // .setState() is executing\n            const timing = this.computeTiming();\n            this.setState(timing.state, ()=>{\n                this.setTimeout(timing.waitMs);\n            });\n        }, waitMs);\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n    }\n}\nNowTimer.contextType = ViewContextType;\nfunction buildDayRange(date) {\n    let start = startOfDay(date);\n    let end = addDays(start, 1);\n    return {\n        start,\n        end\n    };\n}\nclass CalendarImpl {\n    getCurrentData() {\n        return this.currentDataManager.getCurrentData();\n    }\n    dispatch(action) {\n        this.currentDataManager.dispatch(action);\n    }\n    get view() {\n        return this.getCurrentData().viewApi;\n    }\n    batchRendering(callback) {\n        callback();\n    }\n    updateSize() {\n        this.trigger(\"_resize\", true);\n    }\n    // Options\n    // -----------------------------------------------------------------------------------------------------------------\n    setOption(name, val) {\n        this.dispatch({\n            type: \"SET_OPTION\",\n            optionName: name,\n            rawOptionValue: val\n        });\n    }\n    getOption(name) {\n        return this.currentDataManager.currentCalendarOptionsInput[name];\n    }\n    getAvailableLocaleCodes() {\n        return Object.keys(this.getCurrentData().availableRawLocales);\n    }\n    // Trigger\n    // -----------------------------------------------------------------------------------------------------------------\n    on(handlerName, handler) {\n        let { currentDataManager } = this;\n        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n            currentDataManager.emitter.on(handlerName, handler);\n        } else {\n            console.warn(`Unknown listener name '${handlerName}'`);\n        }\n    }\n    off(handlerName, handler) {\n        this.currentDataManager.emitter.off(handlerName, handler);\n    }\n    // not meant for public use\n    trigger(handlerName, ...args) {\n        this.currentDataManager.emitter.trigger(handlerName, ...args);\n    }\n    // View\n    // -----------------------------------------------------------------------------------------------------------------\n    changeView(viewType, dateOrRange) {\n        this.batchRendering(()=>{\n            this.unselect();\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) {\n                    this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType\n                    });\n                    this.dispatch({\n                        type: \"SET_OPTION\",\n                        optionName: \"visibleRange\",\n                        rawOptionValue: dateOrRange\n                    });\n                } else {\n                    let { dateEnv } = this.getCurrentData();\n                    this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType,\n                        dateMarker: dateEnv.createMarker(dateOrRange)\n                    });\n                }\n            } else {\n                this.dispatch({\n                    type: \"CHANGE_VIEW_TYPE\",\n                    viewType\n                });\n            }\n        });\n    }\n    // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n    // needs to change\n    zoomTo(dateMarker, viewType) {\n        let state = this.getCurrentData();\n        let spec;\n        viewType = viewType || \"day\"; // day is default zoom\n        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n        this.unselect();\n        if (spec) {\n            this.dispatch({\n                type: \"CHANGE_VIEW_TYPE\",\n                viewType: spec.type,\n                dateMarker\n            });\n        } else {\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker\n            });\n        }\n    }\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    getUnitViewSpec(unit) {\n        let { viewSpecs, toolbarConfig } = this.getCurrentData();\n        let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n        let i;\n        let spec;\n        for(let viewType in viewSpecs){\n            viewTypes.push(viewType);\n        }\n        for(i = 0; i < viewTypes.length; i += 1){\n            spec = viewSpecs[viewTypes[i]];\n            if (spec) {\n                if (spec.singleUnit === unit) {\n                    return spec;\n                }\n            }\n        }\n        return null;\n    }\n    // Current Date\n    // -----------------------------------------------------------------------------------------------------------------\n    prev() {\n        this.unselect();\n        this.dispatch({\n            type: \"PREV\"\n        });\n    }\n    next() {\n        this.unselect();\n        this.dispatch({\n            type: \"NEXT\"\n        });\n    }\n    prevYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n        });\n    }\n    nextYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n        });\n    }\n    today() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.nowManager.getDateMarker()\n        });\n    }\n    gotoDate(zonedDateInput) {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.createMarker(zonedDateInput)\n        });\n    }\n    incrementDate(deltaInput) {\n        let state = this.getCurrentData();\n        let delta = createDuration(deltaInput);\n        if (delta) {\n            this.unselect();\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: state.dateEnv.add(state.currentDate, delta)\n            });\n        }\n    }\n    getDate() {\n        let state = this.getCurrentData();\n        return state.dateEnv.toDate(state.currentDate);\n    }\n    // Date Formatting Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    formatDate(d, formatter) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n    }\n    // `settings` is for formatter AND isEndExclusive\n    formatRange(d0, d1, settings) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n    }\n    formatIso(d, omitTime) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatIso(dateEnv.createMarker(d), {\n            omitTime\n        });\n    }\n    // Date Selection / Event Selection / DayClick\n    // -----------------------------------------------------------------------------------------------------------------\n    select(dateOrObj, endDate) {\n        let selectionInput;\n        if (endDate == null) {\n            if (dateOrObj.start != null) {\n                selectionInput = dateOrObj;\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: null\n                };\n            }\n        } else {\n            selectionInput = {\n                start: dateOrObj,\n                end: endDate\n            };\n        }\n        let state = this.getCurrentData();\n        let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n            days: 1\n        }));\n        if (selection) {\n            this.dispatch({\n                type: \"SELECT_DATES\",\n                selection\n            });\n            triggerDateSelect(selection, null, state);\n        }\n    }\n    unselect(pev) {\n        let state = this.getCurrentData();\n        if (state.dateSelection) {\n            this.dispatch({\n                type: \"UNSELECT_DATES\"\n            });\n            triggerDateUnselect(pev, state);\n        }\n    }\n    // Public Events API\n    // -----------------------------------------------------------------------------------------------------------------\n    addEvent(eventInput, sourceInput) {\n        if (eventInput instanceof EventImpl) {\n            let def = eventInput._def;\n            let instance = eventInput._instance;\n            let currentData = this.getCurrentData();\n            // not already present? don't want to add an old snapshot\n            if (!currentData.eventStore.defs[def.defId]) {\n                this.dispatch({\n                    type: \"ADD_EVENTS\",\n                    eventStore: eventTupleToStore({\n                        def,\n                        instance\n                    })\n                });\n                this.triggerEventAdd(eventInput);\n            }\n            return eventInput;\n        }\n        let state = this.getCurrentData();\n        let eventSource;\n        if (sourceInput instanceof EventSourceImpl) {\n            eventSource = sourceInput.internalEventSource;\n        } else if (typeof sourceInput === \"boolean\") {\n            if (sourceInput) {\n                [eventSource] = hashValuesToArray(state.eventSources);\n            }\n        } else if (sourceInput != null) {\n            let sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n            if (!sourceApi) {\n                console.warn(`Could not find an event source with ID \"${sourceInput}\"`); // TODO: test\n                return null;\n            }\n            eventSource = sourceApi.internalEventSource;\n        }\n        let tuple = parseEvent(eventInput, eventSource, state, false);\n        if (tuple) {\n            let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            this.dispatch({\n                type: \"ADD_EVENTS\",\n                eventStore: eventTupleToStore(tuple)\n            });\n            this.triggerEventAdd(newEventApi);\n            return newEventApi;\n        }\n        return null;\n    }\n    triggerEventAdd(eventApi) {\n        let { emitter } = this.getCurrentData();\n        emitter.trigger(\"eventAdd\", {\n            event: eventApi,\n            relatedEvents: [],\n            revert: ()=>{\n                this.dispatch({\n                    type: \"REMOVE_EVENTS\",\n                    eventStore: eventApiToStore(eventApi)\n                });\n            }\n        });\n    }\n    // TODO: optimize\n    getEventById(id) {\n        let state = this.getCurrentData();\n        let { defs, instances } = state.eventStore;\n        id = String(id);\n        for(let defId in defs){\n            let def = defs[defId];\n            if (def.publicId === id) {\n                if (def.recurringDef) {\n                    return new EventImpl(state, def, null);\n                }\n                for(let instanceId in instances){\n                    let instance = instances[instanceId];\n                    if (instance.defId === def.defId) {\n                        return new EventImpl(state, def, instance);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    getEvents() {\n        let currentData = this.getCurrentData();\n        return buildEventApis(currentData.eventStore, currentData);\n    }\n    removeAllEvents() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENTS\"\n        });\n    }\n    // Public Event Sources API\n    // -----------------------------------------------------------------------------------------------------------------\n    getEventSources() {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        let sourceApis = [];\n        for(let internalId in sourceHash){\n            sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));\n        }\n        return sourceApis;\n    }\n    getEventSourceById(id) {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        id = String(id);\n        for(let sourceId in sourceHash){\n            if (sourceHash[sourceId].publicId === id) {\n                return new EventSourceImpl(state, sourceHash[sourceId]);\n            }\n        }\n        return null;\n    }\n    addEventSource(sourceInput) {\n        let state = this.getCurrentData();\n        if (sourceInput instanceof EventSourceImpl) {\n            // not already present? don't want to add an old snapshot\n            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                this.dispatch({\n                    type: \"ADD_EVENT_SOURCES\",\n                    sources: [\n                        sourceInput.internalEventSource\n                    ]\n                });\n            }\n            return sourceInput;\n        }\n        let eventSource = parseEventSource(sourceInput, state);\n        if (eventSource) {\n            this.dispatch({\n                type: \"ADD_EVENT_SOURCES\",\n                sources: [\n                    eventSource\n                ]\n            });\n            return new EventSourceImpl(state, eventSource);\n        }\n        return null;\n    }\n    removeAllEventSources() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENT_SOURCES\"\n        });\n    }\n    refetchEvents() {\n        this.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            isRefetch: true\n        });\n    }\n    // Scroll\n    // -----------------------------------------------------------------------------------------------------------------\n    scrollToTime(timeInput) {\n        let time = createDuration(timeInput);\n        if (time) {\n            this.trigger(\"_scrollRequest\", {\n                time\n            });\n        }\n    }\n}\nfunction pointInsideRect(point, rect) {\n    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n}\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n    let res = {\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n    if (res.left < res.right && res.top < res.bottom) {\n        return res;\n    }\n    return false;\n}\nfunction translateRect(rect, deltaX, deltaY) {\n    return {\n        left: rect.left + deltaX,\n        right: rect.right + deltaX,\n        top: rect.top + deltaY,\n        bottom: rect.bottom + deltaY\n    };\n}\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n    return {\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n    };\n}\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n    return {\n        left: (rect.left + rect.right) / 2,\n        top: (rect.top + rect.bottom) / 2\n    };\n}\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n    return {\n        left: point1.left - point2.left,\n        top: point1.top - point2.top\n    };\n}\nconst EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\nclass Splitter {\n    constructor(){\n        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n        this.splitDateSelection = memoize(this._splitDateSpan);\n        this.splitEventStore = memoize(this._splitEventStore);\n        this.splitIndividualUi = memoize(this._splitIndividualUi);\n        this.splitEventDrag = memoize(this._splitInteraction);\n        this.splitEventResize = memoize(this._splitInteraction);\n        this.eventUiBuilders = {}; // TODO: typescript protection\n    }\n    splitProps(props) {\n        let keyInfos = this.getKeyInfo(props);\n        let defKeys = this.getKeysForEventDefs(props.eventStore);\n        let dateSelections = this.splitDateSelection(props.dateSelection);\n        let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n        let eventStores = this.splitEventStore(props.eventStore, defKeys);\n        let eventDrags = this.splitEventDrag(props.eventDrag);\n        let eventResizes = this.splitEventResize(props.eventResize);\n        let splitProps = {};\n        this.eventUiBuilders = mapHash(keyInfos, (info, key)=>this.eventUiBuilders[key] || memoize(buildEventUiForKey));\n        for(let key in keyInfos){\n            let keyInfo = keyInfos[key];\n            let eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n            let buildEventUi = this.eventUiBuilders[key];\n            splitProps[key] = {\n                businessHours: keyInfo.businessHours || props.businessHours,\n                dateSelection: dateSelections[key] || null,\n                eventStore,\n                eventUiBases: buildEventUi(props.eventUiBases[\"\"], keyInfo.ui, individualUi[key]),\n                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : \"\",\n                eventDrag: eventDrags[key] || null,\n                eventResize: eventResizes[key] || null\n            };\n        }\n        return splitProps;\n    }\n    _splitDateSpan(dateSpan) {\n        let dateSpans = {};\n        if (dateSpan) {\n            let keys = this.getKeysForDateSpan(dateSpan);\n            for (let key of keys){\n                dateSpans[key] = dateSpan;\n            }\n        }\n        return dateSpans;\n    }\n    _getKeysForEventDefs(eventStore) {\n        return mapHash(eventStore.defs, (eventDef)=>this.getKeysForEventDef(eventDef));\n    }\n    _splitEventStore(eventStore, defKeys) {\n        let { defs, instances } = eventStore;\n        let splitStores = {};\n        for(let defId in defs){\n            for (let key of defKeys[defId]){\n                if (!splitStores[key]) {\n                    splitStores[key] = createEmptyEventStore();\n                }\n                splitStores[key].defs[defId] = defs[defId];\n            }\n        }\n        for(let instanceId in instances){\n            let instance = instances[instanceId];\n            for (let key of defKeys[instance.defId]){\n                if (splitStores[key]) {\n                    splitStores[key].instances[instanceId] = instance;\n                }\n            }\n        }\n        return splitStores;\n    }\n    _splitIndividualUi(eventUiBases, defKeys) {\n        let splitHashes = {};\n        for(let defId in eventUiBases){\n            if (defId) {\n                for (let key of defKeys[defId]){\n                    if (!splitHashes[key]) {\n                        splitHashes[key] = {};\n                    }\n                    splitHashes[key][defId] = eventUiBases[defId];\n                }\n            }\n        }\n        return splitHashes;\n    }\n    _splitInteraction(interaction) {\n        let splitStates = {};\n        if (interaction) {\n            let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n            // can't rely on defKeys because event data is mutated\n            let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n            let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n            let populate = (key)=>{\n                if (!splitStates[key]) {\n                    splitStates[key] = {\n                        affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,\n                        mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,\n                        isEvent: interaction.isEvent\n                    };\n                }\n            };\n            for(let key in affectedStores){\n                populate(key);\n            }\n            for(let key in mutatedStores){\n                populate(key);\n            }\n        }\n        return splitStates;\n    }\n}\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n    let baseParts = [];\n    if (allUi) {\n        baseParts.push(allUi);\n    }\n    if (eventUiForKey) {\n        baseParts.push(eventUiForKey);\n    }\n    let stuff = {\n        \"\": combineEventUis(baseParts)\n    };\n    if (individualUi) {\n        Object.assign(stuff, individualUi);\n    }\n    return stuff;\n}\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n    return {\n        dow: date.getUTCDay(),\n        isDisabled: Boolean(dateProfile && (!dateProfile.activeRange || !rangeContainsMarker(dateProfile.activeRange, date))),\n        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n    };\n}\nfunction getDayClassNames(meta, theme) {\n    let classNames = [\n        \"fc-day\",\n        `fc-day-${DAY_IDS[meta.dow]}`\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-day-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-day-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-day-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-day-future\");\n        }\n        if (meta.isOther) {\n            classNames.push(\"fc-day-other\");\n        }\n    }\n    return classNames;\n}\nfunction getSlotClassNames(meta, theme) {\n    let classNames = [\n        \"fc-slot\",\n        `fc-slot-${DAY_IDS[meta.dow]}`\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-slot-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-slot-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-slot-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-slot-future\");\n        }\n    }\n    return classNames;\n}\nconst DAY_FORMAT = createFormatter({\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\"\n});\nconst WEEK_FORMAT = createFormatter({\n    week: \"long\"\n});\nfunction buildNavLinkAttrs(context, dateMarker, viewType = \"day\", isTabbable = true) {\n    const { dateEnv, options, calendarApi } = context;\n    let dateStr = dateEnv.format(dateMarker, viewType === \"week\" ? WEEK_FORMAT : DAY_FORMAT);\n    if (options.navLinks) {\n        let zonedDate = dateEnv.toDate(dateMarker);\n        const handleInteraction = (ev)=>{\n            let customAction = viewType === \"day\" ? options.navLinkDayClick : viewType === \"week\" ? options.navLinkWeekClick : null;\n            if (typeof customAction === \"function\") {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            } else {\n                if (typeof customAction === \"string\") {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        return Object.assign({\n            title: formatWithOrdinals(options.navLinkHint, [\n                dateStr,\n                zonedDate\n            ], dateStr),\n            \"data-navlink\": \"\"\n        }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n            onClick: handleInteraction\n        });\n    }\n    return {\n        \"aria-label\": dateStr\n    };\n}\nlet _isRtlScrollbarOnLeft = null;\nfunction getIsRtlScrollbarOnLeft() {\n    if (_isRtlScrollbarOnLeft === null) {\n        _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n    }\n    return _isRtlScrollbarOnLeft;\n}\nfunction computeIsRtlScrollbarOnLeft() {\n    let outerEl = document.createElement(\"div\");\n    applyStyle(outerEl, {\n        position: \"absolute\",\n        top: -1000,\n        left: 0,\n        border: 0,\n        padding: 0,\n        overflow: \"scroll\",\n        direction: \"rtl\"\n    });\n    outerEl.innerHTML = \"<div></div>\";\n    document.body.appendChild(outerEl);\n    let innerEl = outerEl.firstChild;\n    let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n    removeElement(outerEl);\n    return res;\n}\nlet _scrollbarWidths;\nfunction getScrollbarWidths() {\n    if (!_scrollbarWidths) {\n        _scrollbarWidths = computeScrollbarWidths();\n    }\n    return _scrollbarWidths;\n}\nfunction computeScrollbarWidths() {\n    let el = document.createElement(\"div\");\n    el.style.overflow = \"scroll\";\n    el.style.position = \"absolute\";\n    el.style.top = \"-9999px\";\n    el.style.left = \"-9999px\";\n    document.body.appendChild(el);\n    let res = computeScrollbarWidthsForEl(el);\n    document.body.removeChild(el);\n    return res;\n}\n// WARNING: will include border\nfunction computeScrollbarWidthsForEl(el) {\n    return {\n        x: el.offsetHeight - el.clientHeight,\n        y: el.offsetWidth - el.clientWidth\n    };\n}\nfunction computeEdges(el, getPadding = false) {\n    let computedStyle = window.getComputedStyle(el);\n    let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n    let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n    let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n    let badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n    let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n    let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n    let res = {\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        scrollbarBottom,\n        scrollbarLeft: 0,\n        scrollbarRight: 0\n    };\n    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === \"rtl\") {\n        res.scrollbarLeft = scrollbarLeftRight;\n    } else {\n        res.scrollbarRight = scrollbarLeftRight;\n    }\n    if (getPadding) {\n        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n    }\n    return res;\n}\nfunction computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {\n    let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n    let edges = computeEdges(el, goWithinPadding);\n    let res = {\n        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n        right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n        top: outerRect.top + edges.borderTop,\n        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n    };\n    if (goWithinPadding) {\n        res.left += edges.paddingLeft;\n        res.right -= edges.paddingRight;\n        res.top += edges.paddingTop;\n        res.bottom -= edges.paddingBottom;\n    }\n    return res;\n}\nfunction computeRect(el) {\n    let rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + window.scrollX,\n        top: rect.top + window.scrollY,\n        right: rect.right + window.scrollX,\n        bottom: rect.bottom + window.scrollY\n    };\n}\nfunction computeClippedClientRect(el) {\n    let clippingParents = getClippingParents(el);\n    let rect = el.getBoundingClientRect();\n    for (let clippingParent of clippingParents){\n        let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n        if (intersection) {\n            rect = intersection;\n        } else {\n            return null;\n        }\n    }\n    return rect;\n}\n// does not return window\nfunction getClippingParents(el) {\n    let parents = [];\n    while(el instanceof HTMLElement){\n        let computedStyle = window.getComputedStyle(el);\n        if (computedStyle.position === \"fixed\") {\n            break;\n        }\n        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n            parents.push(el);\n        }\n        el = el.parentNode;\n    }\n    return parents;\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/ class PositionCache {\n    constructor(originEl, els, isHorizontal, isVertical){\n        this.els = els;\n        let originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n        if (isHorizontal) {\n            this.buildElHorizontals(originClientRect.left);\n        }\n        if (isVertical) {\n            this.buildElVerticals(originClientRect.top);\n        }\n    }\n    // Populates the left/right internal coordinate arrays\n    buildElHorizontals(originClientLeft) {\n        let lefts = [];\n        let rights = [];\n        for (let el of this.els){\n            let rect = el.getBoundingClientRect();\n            lefts.push(rect.left - originClientLeft);\n            rights.push(rect.right - originClientLeft);\n        }\n        this.lefts = lefts;\n        this.rights = rights;\n    }\n    // Populates the top/bottom internal coordinate arrays\n    buildElVerticals(originClientTop) {\n        let tops = [];\n        let bottoms = [];\n        for (let el of this.els){\n            let rect = el.getBoundingClientRect();\n            tops.push(rect.top - originClientTop);\n            bottoms.push(rect.bottom - originClientTop);\n        }\n        this.tops = tops;\n        this.bottoms = bottoms;\n    }\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, returns undefined.\n    leftToIndex(leftPosition) {\n        let { lefts, rights } = this;\n        let len = lefts.length;\n        let i;\n        for(i = 0; i < len; i += 1){\n            if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, returns undefined.\n    topToIndex(topPosition) {\n        let { tops, bottoms } = this;\n        let len = tops.length;\n        let i;\n        for(i = 0; i < len; i += 1){\n            if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Gets the width of the element at the given index\n    getWidth(leftIndex) {\n        return this.rights[leftIndex] - this.lefts[leftIndex];\n    }\n    // Gets the height of the element at the given index\n    getHeight(topIndex) {\n        return this.bottoms[topIndex] - this.tops[topIndex];\n    }\n    similarTo(otherCache) {\n        return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);\n    }\n}\nfunction similarNumArrays(a, b) {\n    const len = a.length;\n    if (len !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < len; i++){\n        if (Math.round(a[i]) !== Math.round(b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/* eslint max-classes-per-file: \"off\" */ /*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/ class ScrollController {\n    getMaxScrollTop() {\n        return this.getScrollHeight() - this.getClientHeight();\n    }\n    getMaxScrollLeft() {\n        return this.getScrollWidth() - this.getClientWidth();\n    }\n    canScrollVertically() {\n        return this.getMaxScrollTop() > 0;\n    }\n    canScrollHorizontally() {\n        return this.getMaxScrollLeft() > 0;\n    }\n    canScrollUp() {\n        return this.getScrollTop() > 0;\n    }\n    canScrollDown() {\n        return this.getScrollTop() < this.getMaxScrollTop();\n    }\n    canScrollLeft() {\n        return this.getScrollLeft() > 0;\n    }\n    canScrollRight() {\n        return this.getScrollLeft() < this.getMaxScrollLeft();\n    }\n}\nclass ElementScrollController extends ScrollController {\n    constructor(el){\n        super();\n        this.el = el;\n    }\n    getScrollTop() {\n        return this.el.scrollTop;\n    }\n    getScrollLeft() {\n        return this.el.scrollLeft;\n    }\n    setScrollTop(top) {\n        this.el.scrollTop = top;\n    }\n    setScrollLeft(left) {\n        this.el.scrollLeft = left;\n    }\n    getScrollWidth() {\n        return this.el.scrollWidth;\n    }\n    getScrollHeight() {\n        return this.el.scrollHeight;\n    }\n    getClientHeight() {\n        return this.el.clientHeight;\n    }\n    getClientWidth() {\n        return this.el.clientWidth;\n    }\n}\nclass WindowScrollController extends ScrollController {\n    getScrollTop() {\n        return window.scrollY;\n    }\n    getScrollLeft() {\n        return window.scrollX;\n    }\n    setScrollTop(n) {\n        window.scroll(window.scrollX, n);\n    }\n    setScrollLeft(n) {\n        window.scroll(n, window.scrollY);\n    }\n    getScrollWidth() {\n        return document.documentElement.scrollWidth;\n    }\n    getScrollHeight() {\n        return document.documentElement.scrollHeight;\n    }\n    getClientHeight() {\n        return document.documentElement.clientHeight;\n    }\n    getClientWidth() {\n        return document.documentElement.clientWidth;\n    }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/ class DateComponent extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.uid = guid();\n    }\n    // Hit System\n    // -----------------------------------------------------------------------------------------------------------------\n    prepareHits() {}\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        return null; // this should be abstract\n    }\n    // Pointer Interaction Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    isValidSegDownEl(el) {\n        return !this.props.eventDrag && // HACK\n        !this.props.eventResize && // HACK\n        !elementClosest(el, \".fc-event-mirror\");\n    }\n    isValidDateDownEl(el) {\n        return !elementClosest(el, \".fc-event:not(.fc-bg-event)\") && !elementClosest(el, \".fc-more-link\") && // a \"more..\" link\n        !elementClosest(el, \"a[data-navlink]\") && // a clickable nav link\n        !elementClosest(el, \".fc-popover\"); // hack\n    }\n}\nclass NamedTimeZoneImpl {\n    constructor(timeZoneName){\n        this.timeZoneName = timeZoneName;\n    }\n}\nclass SegHierarchy {\n    constructor(getEntryThickness = (entry)=>{\n        // if no thickness known, assume 1 (if 0, so small it always fits)\n        return entry.thickness || 1;\n    }){\n        this.getEntryThickness = getEntryThickness;\n        // settings\n        this.strictOrder = false;\n        this.allowReslicing = false;\n        this.maxCoord = -1; // -1 means no max\n        this.maxStackCnt = -1; // -1 means no max\n        this.levelCoords = []; // ordered\n        this.entriesByLevel = []; // parallel with levelCoords\n        this.stackCnts = {}; // TODO: use better technique!?\n    }\n    addSegs(inputs) {\n        let hiddenEntries = [];\n        for (let input of inputs){\n            this.insertEntry(input, hiddenEntries);\n        }\n        return hiddenEntries;\n    }\n    insertEntry(entry, hiddenEntries) {\n        let insertion = this.findInsertion(entry);\n        if (this.isInsertionValid(insertion, entry)) {\n            this.insertEntryAt(entry, insertion);\n        } else {\n            this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n        }\n    }\n    isInsertionValid(insertion, entry) {\n        return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n    }\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        if (this.allowReslicing && insertion.touchingEntry) {\n            const hiddenEntry = Object.assign(Object.assign({}, entry), {\n                span: intersectSpans(entry.span, insertion.touchingEntry.span)\n            });\n            hiddenEntries.push(hiddenEntry);\n            this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n        } else {\n            hiddenEntries.push(entry);\n        }\n    }\n    /*\n    Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.\n    */ splitEntry(entry, barrier, hiddenEntries) {\n        let entrySpan = entry.span;\n        let barrierSpan = barrier.span;\n        if (entrySpan.start < barrierSpan.start) {\n            this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: entrySpan.start,\n                    end: barrierSpan.start\n                }\n            }, hiddenEntries);\n        }\n        if (entrySpan.end > barrierSpan.end) {\n            this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: barrierSpan.end,\n                    end: entrySpan.end\n                }\n            }, hiddenEntries);\n        }\n    }\n    insertEntryAt(entry, insertion) {\n        let { entriesByLevel, levelCoords } = this;\n        if (insertion.lateral === -1) {\n            // create a new level\n            insertAt(levelCoords, insertion.level, insertion.levelCoord);\n            insertAt(entriesByLevel, insertion.level, [\n                entry\n            ]);\n        } else {\n            // insert into existing level\n            insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n        }\n        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n    }\n    /*\n    does not care about limits\n    */ findInsertion(newEntry) {\n        let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;\n        let levelCnt = levelCoords.length;\n        let candidateCoord = 0;\n        let touchingLevel = -1;\n        let touchingLateral = -1;\n        let touchingEntry = null;\n        let stackCnt = 0;\n        for(let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n            const trackingCoord = levelCoords[trackingLevel];\n            // if the current level is past the placed entry, we have found a good empty space and can stop.\n            // if strictOrder, keep finding more lateral intersections.\n            if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {\n                break;\n            }\n            let trackingEntries = entriesByLevel[trackingLevel];\n            let trackingEntry;\n            let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n            let lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n            while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n            trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n            ){\n                let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);\n                // intersects into the top of the candidate?\n                if (trackingEntryBottom > candidateCoord) {\n                    candidateCoord = trackingEntryBottom;\n                    touchingEntry = trackingEntry;\n                    touchingLevel = trackingLevel;\n                    touchingLateral = lateralIndex;\n                }\n                // butts up against top of candidate? (will happen if just intersected as well)\n                if (trackingEntryBottom === candidateCoord) {\n                    // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                    stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                }\n                lateralIndex += 1;\n            }\n        }\n        // the destination level will be after touchingEntry's level. find it\n        let destLevel = 0;\n        if (touchingEntry) {\n            destLevel = touchingLevel + 1;\n            while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                destLevel += 1;\n            }\n        }\n        // if adding to an existing level, find where to insert\n        let destLateral = -1;\n        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n            destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n        }\n        return {\n            touchingLevel,\n            touchingLateral,\n            touchingEntry,\n            stackCnt,\n            levelCoord: candidateCoord,\n            level: destLevel,\n            lateral: destLateral\n        };\n    }\n    // sorted by levelCoord (lowest to highest)\n    toRects() {\n        let { entriesByLevel, levelCoords } = this;\n        let levelCnt = entriesByLevel.length;\n        let rects = [];\n        for(let level = 0; level < levelCnt; level += 1){\n            let entries = entriesByLevel[level];\n            let levelCoord = levelCoords[level];\n            for (let entry of entries){\n                rects.push(Object.assign(Object.assign({}, entry), {\n                    thickness: this.getEntryThickness(entry),\n                    levelCoord\n                }));\n            }\n        }\n        return rects;\n    }\n}\nfunction getEntrySpanEnd(entry) {\n    return entry.span.end;\n}\nfunction buildEntryKey(entry) {\n    return entry.index + \":\" + entry.span.start;\n}\n// returns groups with entries sorted by input order\nfunction groupIntersectingEntries(entries) {\n    let merges = [];\n    for (let entry of entries){\n        let filteredMerges = [];\n        let hungryMerge = {\n            span: entry.span,\n            entries: [\n                entry\n            ]\n        };\n        for (let merge of merges){\n            if (intersectSpans(merge.span, hungryMerge.span)) {\n                hungryMerge = {\n                    entries: merge.entries.concat(hungryMerge.entries),\n                    span: joinSpans(merge.span, hungryMerge.span)\n                };\n            } else {\n                filteredMerges.push(merge);\n            }\n        }\n        filteredMerges.push(hungryMerge);\n        merges = filteredMerges;\n    }\n    return merges;\n}\nfunction joinSpans(span0, span1) {\n    return {\n        start: Math.min(span0.start, span1.start),\n        end: Math.max(span0.end, span1.end)\n    };\n}\nfunction intersectSpans(span0, span1) {\n    let start = Math.max(span0.start, span1.start);\n    let end = Math.min(span0.end, span1.end);\n    if (start < end) {\n        return {\n            start,\n            end\n        };\n    }\n    return null;\n}\n// general util\n// ---------------------------------------------------------------------------------------------------------------------\nfunction insertAt(arr, index, item) {\n    arr.splice(index, 0, item);\n}\nfunction binarySearch(a, searchVal, getItemVal) {\n    let startIndex = 0;\n    let endIndex = a.length; // exclusive\n    if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n        return [\n            0,\n            0\n        ];\n    }\n    if (searchVal > getItemVal(a[endIndex - 1])) {\n        return [\n            endIndex,\n            0\n        ];\n    }\n    while(startIndex < endIndex){\n        let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n        let middleVal = getItemVal(a[middleIndex]);\n        if (searchVal < middleVal) {\n            endIndex = middleIndex;\n        } else if (searchVal > middleVal) {\n            startIndex = middleIndex + 1;\n        } else {\n            return [\n                middleIndex,\n                1\n            ];\n        }\n    }\n    return [\n        startIndex,\n        0\n    ];\n}\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/ class ElementDragging {\n    constructor(el, selector){\n        this.emitter = new Emitter();\n    }\n    destroy() {}\n    setMirrorIsVisible(bool) {\n    // optional if subclass doesn't want to support a mirror\n    }\n    setMirrorNeedsRevert(bool) {\n    // optional if subclass doesn't want to support a mirror\n    }\n    setAutoScrollEnabled(bool) {\n    // optional\n    }\n}\n// TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\nconst config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/ const DRAG_META_REFINERS = {\n    startTime: createDuration,\n    duration: createDuration,\n    create: Boolean,\n    sourceId: String\n};\nfunction parseDragMeta(raw) {\n    let { refined, extra } = refineProps(raw, DRAG_META_REFINERS);\n    return {\n        startTime: refined.startTime || null,\n        duration: refined.duration || null,\n        create: refined.create != null ? refined.create : true,\n        sourceId: refined.sourceId,\n        leftoverProps: extra\n    };\n}\n// Computes a default column header formatting string if `colFormat` is not explicitly defined\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n    // if more than one week row, or if there are a lot of columns with not much space,\n    // put just the day numbers will be in each cell\n    if (!datesRepDistinctDays || dayCnt > 10) {\n        return createFormatter({\n            weekday: \"short\"\n        }); // \"Sat\"\n    }\n    if (dayCnt > 1) {\n        return createFormatter({\n            weekday: \"short\",\n            month: \"numeric\",\n            day: \"numeric\",\n            omitCommas: true\n        }); // \"Sat 11/12\"\n    }\n    return createFormatter({\n        weekday: \"long\"\n    }); // \"Saturday\"\n}\nconst CLASS_NAME = \"fc-col-header-cell\"; // do the cushion too? no\nfunction renderInner$1(renderProps) {\n    return renderProps.text;\n}\n// BAD name for this class now. used in the Header\nclass TableDateCell extends BaseComponent {\n    render() {\n        let { dateEnv, options, theme, viewApi } = this.context;\n        let { props } = this;\n        let { date, dateProfile } = props;\n        let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n        let classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dayMeta, theme));\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        // if colCnt is 1, we are already in a day-view and don't need a navlink\n        let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n        let publicDate = dateEnv.toDate(date);\n        // workaround for Luxon (and maybe moment) returning prior-days when start-of-day\n        // in DST gap: https://github.com/fullcalendar/fullcalendar/issues/7633\n        if (dateEnv.namedTimeZoneImpl) {\n            publicDate = addMs(publicDate, 3600000); // add an hour\n        }\n        let renderProps = Object.assign(Object.assign(Object.assign({\n            date: publicDate,\n            view: viewApi\n        }, props.extraRenderProps), {\n            text\n        }), dayMeta);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n            elTag: \"th\",\n            elClasses: classNames,\n            elAttrs: Object.assign({\n                role: \"columnheader\",\n                colSpan: props.colSpan,\n                \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined\n            }, props.extraDataAttrs),\n            renderProps: renderProps,\n            generatorName: \"dayHeaderContent\",\n            customGenerator: options.dayHeaderContent,\n            defaultGenerator: renderInner$1,\n            classNameGenerator: options.dayHeaderClassNames,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, (InnerContainer)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, !dayMeta.isDisabled && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContainer, {\n                elTag: \"a\",\n                elAttrs: navLinkAttrs,\n                elClasses: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky && \"fc-sticky\"\n                ]\n            })));\n    }\n}\nconst WEEKDAY_FORMAT = createFormatter({\n    weekday: \"long\"\n});\nclass TableDowCell extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { dateEnv, theme, viewApi, options } = this.context;\n        let date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n        let dateMeta = {\n            dow: props.dow,\n            isDisabled: false,\n            isFuture: false,\n            isPast: false,\n            isToday: false,\n            isOther: false\n        };\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({\n            date\n        }, dateMeta), {\n            view: viewApi\n        }), props.extraRenderProps), {\n            text\n        });\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n            elTag: \"th\",\n            elClasses: [\n                CLASS_NAME,\n                ...getDayClassNames(dateMeta, theme),\n                ...props.extraClassNames || []\n            ],\n            elAttrs: Object.assign({\n                role: \"columnheader\",\n                colSpan: props.colSpan\n            }, props.extraDataAttrs),\n            renderProps: renderProps,\n            generatorName: \"dayHeaderContent\",\n            customGenerator: options.dayHeaderContent,\n            defaultGenerator: renderInner$1,\n            classNameGenerator: options.dayHeaderClassNames,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, (InnerContent)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky && \"fc-sticky\"\n                ],\n                elAttrs: {\n                    \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT)\n                }\n            })));\n    }\n}\nclass DayHeader extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    }\n    render() {\n        let { context } = this;\n        let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;\n        let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(NowTimer, {\n            unit: \"day\"\n        }, (nowDate, todayRange)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n                role: \"row\"\n            }, renderIntro && renderIntro(\"day\"), dates.map((date)=>datesRepDistinctDays ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDateCell, {\n                    key: date.toISOString(),\n                    date: date,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    colCnt: dates.length,\n                    dayHeaderFormat: dayHeaderFormat\n                }) : (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDowCell, {\n                    key: date.getUTCDay(),\n                    dow: date.getUTCDay(),\n                    dayHeaderFormat: dayHeaderFormat\n                }))));\n    }\n}\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\nclass DaySeriesModel {\n    constructor(range, dateProfileGenerator){\n        let date = range.start;\n        let { end } = range;\n        let indices = [];\n        let dates = [];\n        let dayIndex = -1;\n        while(date < end){\n            if (dateProfileGenerator.isHiddenDay(date)) {\n                indices.push(dayIndex + 0.5); // mark that it's between indices\n            } else {\n                dayIndex += 1;\n                indices.push(dayIndex);\n                dates.push(date);\n            }\n            date = addDays(date, 1);\n        }\n        this.dates = dates;\n        this.indices = indices;\n        this.cnt = dates.length;\n    }\n    sliceRange(range) {\n        let firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n        let lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n        let clippedFirstIndex = Math.max(0, firstIndex);\n        let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n        // deal with in-between indices\n        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n        if (clippedFirstIndex <= clippedLastIndex) {\n            return {\n                firstIndex: clippedFirstIndex,\n                lastIndex: clippedLastIndex,\n                isStart: firstIndex === clippedFirstIndex,\n                isEnd: lastIndex === clippedLastIndex\n            };\n        }\n        return null;\n    }\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    getDateDayIndex(date) {\n        let { indices } = this;\n        let dayOffset = Math.floor(diffDays(this.dates[0], date));\n        if (dayOffset < 0) {\n            return indices[0] - 1;\n        }\n        if (dayOffset >= indices.length) {\n            return indices[indices.length - 1] + 1;\n        }\n        return indices[dayOffset];\n    }\n}\nclass DayTableModel {\n    constructor(daySeries, breakOnWeeks){\n        let { dates } = daySeries;\n        let daysPerRow;\n        let firstDay;\n        let rowCnt;\n        if (breakOnWeeks) {\n            // count columns until the day-of-week repeats\n            firstDay = dates[0].getUTCDay();\n            for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                if (dates[daysPerRow].getUTCDay() === firstDay) {\n                    break;\n                }\n            }\n            rowCnt = Math.ceil(dates.length / daysPerRow);\n        } else {\n            rowCnt = 1;\n            daysPerRow = dates.length;\n        }\n        this.rowCnt = rowCnt;\n        this.colCnt = daysPerRow;\n        this.daySeries = daySeries;\n        this.cells = this.buildCells();\n        this.headerDates = this.buildHeaderDates();\n    }\n    buildCells() {\n        let rows = [];\n        for(let row = 0; row < this.rowCnt; row += 1){\n            let cells = [];\n            for(let col = 0; col < this.colCnt; col += 1){\n                cells.push(this.buildCell(row, col));\n            }\n            rows.push(cells);\n        }\n        return rows;\n    }\n    buildCell(row, col) {\n        let date = this.daySeries.dates[row * this.colCnt + col];\n        return {\n            key: date.toISOString(),\n            date\n        };\n    }\n    buildHeaderDates() {\n        let dates = [];\n        for(let col = 0; col < this.colCnt; col += 1){\n            dates.push(this.cells[0][col].date);\n        }\n        return dates;\n    }\n    sliceRange(range) {\n        let { colCnt } = this;\n        let seriesSeg = this.daySeries.sliceRange(range);\n        let segs = [];\n        if (seriesSeg) {\n            let { firstIndex, lastIndex } = seriesSeg;\n            let index = firstIndex;\n            while(index <= lastIndex){\n                let row = Math.floor(index / colCnt);\n                let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                segs.push({\n                    row,\n                    firstCol: index % colCnt,\n                    lastCol: (nextIndex - 1) % colCnt,\n                    isStart: seriesSeg.isStart && index === firstIndex,\n                    isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                });\n                index = nextIndex;\n            }\n        }\n        return segs;\n    }\n}\nclass Slicer {\n    constructor(){\n        this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n        this.sliceDateSelection = memoize(this._sliceDateSpan);\n        this.sliceEventStore = memoize(this._sliceEventStore);\n        this.sliceEventDrag = memoize(this._sliceInteraction);\n        this.sliceEventResize = memoize(this._sliceInteraction);\n        this.forceDayIfListItem = false; // hack\n    }\n    sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        let { eventUiBases } = props;\n        let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);\n        return {\n            dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),\n            businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),\n            fgEventSegs: eventSegs.fg,\n            bgEventSegs: eventSegs.bg,\n            eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventSelection: props.eventSelection\n        }; // TODO: give interactionSegs?\n    }\n    sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        return this._sliceDateSpan({\n            range: {\n                start: date,\n                end: addMs(date, 1)\n            },\n            allDay: false\n        }, dateProfile, nextDayThreshold, {}, context, ...extraArgs);\n    }\n    _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        if (!businessHours) {\n            return [];\n        }\n        return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;\n    }\n    _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (eventStore) {\n            let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n            };\n        }\n        return {\n            bg: [],\n            fg: []\n        };\n    }\n    _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (!interaction) {\n            return null;\n        }\n        let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n        return {\n            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            affectedInstances: interaction.affectedEvents.instances,\n            isEvent: interaction.isEvent\n        };\n    }\n    _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {\n        if (!dateSpan) {\n            return [];\n        }\n        let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));\n        let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);\n        if (activeDateSpanRange) {\n            dateSpan = Object.assign(Object.assign({}, dateSpan), {\n                range: activeDateSpanRange\n            });\n            let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n            let segs = this.sliceRange(dateSpan.range, ...extraArgs);\n            for (let seg of segs){\n                seg.eventRange = eventRange;\n            }\n            return segs;\n        }\n        return [];\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ sliceEventRanges(eventRanges, extraArgs) {\n        let segs = [];\n        for (let eventRange of eventRanges){\n            segs.push(...this.sliceEventRange(eventRange, extraArgs));\n        }\n        return segs;\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ sliceEventRange(eventRange, extraArgs) {\n        let dateRange = eventRange.range;\n        // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n        if (this.forceDayIfListItem && eventRange.ui.display === \"list-item\") {\n            dateRange = {\n                start: dateRange.start,\n                end: addDays(dateRange.start, 1)\n            };\n        }\n        let segs = this.sliceRange(dateRange, ...extraArgs);\n        for (let seg of segs){\n            seg.eventRange = eventRange;\n            seg.isStart = eventRange.isStart && seg.isStart;\n            seg.isEnd = eventRange.isEnd && seg.isEnd;\n        }\n        return segs;\n    }\n}\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/ function computeActiveRange(dateProfile, isComponentAllDay) {\n    let range = dateProfile.activeRange;\n    if (isComponentAllDay) {\n        return range;\n    }\n    return {\n        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n    };\n}\n// high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionValid(interaction, dateProfile, context) {\n    let { instances } = interaction.mutatedEvents;\n    for(let instanceId in instances){\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n            return false;\n        }\n    }\n    return isNewPropsValid({\n        eventDrag: interaction\n    }, context); // HACK: the eventDrag props is used for ALL interactions\n}\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n        return false;\n    }\n    return isNewPropsValid({\n        dateSelection\n    }, context);\n}\nfunction isNewPropsValid(newProps, context) {\n    let calendarState = context.getCurrentData();\n    let props = Object.assign({\n        businessHours: calendarState.businessHours,\n        dateSelection: \"\",\n        eventStore: calendarState.eventStore,\n        eventUiBases: calendarState.eventUiBases,\n        eventSelection: \"\",\n        eventDrag: null,\n        eventResize: null\n    }, newProps);\n    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\nfunction isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {\n    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    return true;\n}\n// Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let currentState = context.getCurrentData();\n    let interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n    let subjectEventStore = interaction.mutatedEvents;\n    let subjectDefs = subjectEventStore.defs;\n    let subjectInstances = subjectEventStore.instances;\n    let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n        \"\": currentState.selectionConfig\n    });\n    if (filterConfig) {\n        subjectConfigs = mapHash(subjectConfigs, filterConfig);\n    }\n    // exclude the subject events. TODO: exclude defs too?\n    let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n    let otherDefs = otherEventStore.defs;\n    let otherInstances = otherEventStore.instances;\n    let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n    for(let subjectInstanceId in subjectInstances){\n        let subjectInstance = subjectInstances[subjectInstanceId];\n        let subjectRange = subjectInstance.range;\n        let subjectConfig = subjectConfigs[subjectInstance.defId];\n        let subjectDef = subjectDefs[subjectInstance.defId];\n        // constraint\n        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        let { eventOverlap } = context.options;\n        let eventOverlapFunc = typeof eventOverlap === \"function\" ? eventOverlap : null;\n        for(let otherInstanceId in otherInstances){\n            let otherInstance = otherInstances[otherInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(subjectRange, otherInstance.range)) {\n                let otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                if (otherOverlap === false && interaction.isEvent) {\n                    return false;\n                }\n                if (subjectConfig.overlap === false) {\n                    return false;\n                }\n                if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), new EventImpl(context, subjectDef, subjectInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        let calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n        for (let subjectAllow of subjectConfig.allows){\n            let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), {\n                range: subjectInstance.range,\n                allDay: subjectDef.allDay\n            });\n            let origDef = calendarEventStore.defs[subjectDef.defId];\n            let origInstance = calendarEventStore.instances[subjectInstanceId];\n            let eventApi;\n            if (origDef) {\n                eventApi = new EventImpl(context, origDef, origInstance);\n            } else {\n                eventApi = new EventImpl(context, subjectDef); // no instance, because had no dates\n            }\n            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let relevantEventStore = state.eventStore;\n    let relevantDefs = relevantEventStore.defs;\n    let relevantInstances = relevantEventStore.instances;\n    let selection = state.dateSelection;\n    let selectionRange = selection.range;\n    let { selectionConfig } = context.getCurrentData();\n    if (filterConfig) {\n        selectionConfig = filterConfig(selectionConfig);\n    }\n    // constraint\n    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n        return false;\n    }\n    // overlap\n    let { selectOverlap } = context.options;\n    let selectOverlapFunc = typeof selectOverlap === \"function\" ? selectOverlap : null;\n    for(let relevantInstanceId in relevantInstances){\n        let relevantInstance = relevantInstances[relevantInstanceId];\n        // intersect! evaluate\n        if (rangesIntersect(selectionRange, relevantInstance.range)) {\n            if (selectionConfig.overlap === false) {\n                return false;\n            }\n            if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                return false;\n            }\n        }\n    }\n    // allow (a function)\n    for (let selectionAllow of selectionConfig.allows){\n        let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);\n        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    for (let constraint of constraints){\n        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    if (constraint === \"businessHours\") {\n        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n    }\n    if (typeof constraint === \"string\") {\n        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef)=>eventDef.groupId === constraint));\n    }\n    if (typeof constraint === \"object\" && constraint) {\n        return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n    }\n    return []; // if it's false\n}\n// TODO: move to event-store file?\nfunction eventStoreToRanges(eventStore) {\n    let { instances } = eventStore;\n    let ranges = [];\n    for(let instanceId in instances){\n        ranges.push(instances[instanceId].range);\n    }\n    return ranges;\n}\n// TODO: move to geom file?\nfunction anyRangesContainRange(outerRanges, innerRange) {\n    for (let outerRange of outerRanges){\n        if (rangeContainsRange(outerRange, innerRange)) {\n            return true;\n        }\n    }\n    return false;\n}\nconst VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\nclass Scroller extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.handleEl = (el)=>{\n            this.el = el;\n            setRef(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { props } = this;\n        let { liquid, liquidIsAbsolute } = props;\n        let isAbsolute = liquid && liquidIsAbsolute;\n        let className = [\n            \"fc-scroller\"\n        ];\n        if (liquid) {\n            if (liquidIsAbsolute) {\n                className.push(\"fc-scroller-liquid-absolute\");\n            } else {\n                className.push(\"fc-scroller-liquid\");\n            }\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            ref: this.handleEl,\n            className: className.join(\" \"),\n            style: {\n                overflowX: props.overflowX,\n                overflowY: props.overflowY,\n                left: isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                right: isAbsolute && -(props.overcomeRight || 0) || \"\",\n                bottom: isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                marginRight: !isAbsolute && -(props.overcomeRight || 0) || \"\",\n                marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                maxHeight: props.maxHeight || \"\"\n            }\n        }, props.children);\n    }\n    needsXScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return false;\n        }\n        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n        let { children } = el;\n        for(let i = 0; i < children.length; i += 1){\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().width > realClientWidth) {\n                return true;\n            }\n        }\n        return false;\n    }\n    needsYScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return false;\n        }\n        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n        let { children } = el;\n        for(let i = 0; i < children.length; i += 1){\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().height > realClientHeight) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getXScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return 0;\n        }\n        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n    getYScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return 0;\n        }\n        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n}\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/ class RefMap {\n    constructor(masterCallback){\n        this.masterCallback = masterCallback;\n        this.currentMap = {};\n        this.depths = {};\n        this.callbackMap = {};\n        this.handleValue = (val, key)=>{\n            let { depths, currentMap } = this;\n            let removed = false;\n            let added = false;\n            if (val !== null) {\n                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                removed = key in currentMap;\n                currentMap[key] = val;\n                depths[key] = (depths[key] || 0) + 1;\n                added = true;\n            } else {\n                depths[key] -= 1;\n                if (!depths[key]) {\n                    delete currentMap[key];\n                    delete this.callbackMap[key];\n                    removed = true;\n                }\n            }\n            if (this.masterCallback) {\n                if (removed) {\n                    this.masterCallback(null, String(key));\n                }\n                if (added) {\n                    this.masterCallback(val, String(key));\n                }\n            }\n        };\n    }\n    createRef(key) {\n        let refCallback = this.callbackMap[key];\n        if (!refCallback) {\n            refCallback = this.callbackMap[key] = (val)=>{\n                this.handleValue(val, String(key));\n            };\n        }\n        return refCallback;\n    }\n    // TODO: check callers that don't care about order. should use getAll instead\n    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n    collect(startIndex, endIndex, step) {\n        return collectFromHash(this.currentMap, startIndex, endIndex, step);\n    }\n    getAll() {\n        return hashValuesToArray(this.currentMap);\n    }\n}\nfunction computeShrinkWidth(chunkEls) {\n    let shrinkCells = findElements(chunkEls, \".fc-scrollgrid-shrink\");\n    let largestWidth = 0;\n    for (let shrinkCell of shrinkCells){\n        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n    }\n    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\nfunction getAllowYScrolling(props, sectionConfig) {\n    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n    getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n}\n// TODO: ONLY use `arg`. force out internal function to use same API\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n    let { expandRows } = arg;\n    let content = typeof chunkConfig.content === \"function\" ? chunkConfig.content(arg) : (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n        role: \"presentation\",\n        className: [\n            chunkConfig.tableClassName,\n            sectionConfig.syncRowHeights ? \"fc-scrollgrid-sync-table\" : \"\"\n        ].join(\" \"),\n        style: {\n            minWidth: arg.tableMinWidth,\n            width: arg.clientWidth,\n            height: expandRows ? arg.clientHeight : \"\"\n        }\n    }, arg.tableColGroupNode, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? \"thead\" : \"tbody\", {\n        role: \"presentation\"\n    }, typeof chunkConfig.rowContent === \"function\" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n    return content;\n}\nfunction isColPropsEqual(cols0, cols1) {\n    return isArraysEqual(cols0, cols1, isPropsEqual);\n}\nfunction renderMicroColGroup(cols, shrinkWidth) {\n    let colNodes = [];\n    /*\n    for ColProps with spans, it would have been great to make a single <col span=\"\">\n    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n    SOLUTION: making individual <col> elements makes Chrome behave.\n    */ for (let colProps of cols){\n        let span = colProps.span || 1;\n        for(let i = 0; i < span; i += 1){\n            colNodes.push((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"col\", {\n                style: {\n                    width: colProps.width === \"shrink\" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || \"\",\n                    minWidth: colProps.minWidth || \"\"\n                }\n            }));\n        }\n    }\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"colgroup\", {}, ...colNodes);\n}\nfunction sanitizeShrinkWidth(shrinkWidth) {\n    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n    4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n}\nfunction hasShrinkWidth(cols) {\n    for (let col of cols){\n        if (col.width === \"shrink\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScrollGridClassNames(liquid, context) {\n    let classNames = [\n        \"fc-scrollgrid\",\n        context.theme.getClass(\"table\")\n    ];\n    if (liquid) {\n        classNames.push(\"fc-scrollgrid-liquid\");\n    }\n    return classNames;\n}\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n    let classNames = [\n        \"fc-scrollgrid-section\",\n        `fc-scrollgrid-section-${sectionConfig.type}`,\n        sectionConfig.className\n    ];\n    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n        classNames.push(\"fc-scrollgrid-section-liquid\");\n    }\n    if (sectionConfig.isSticky) {\n        classNames.push(\"fc-scrollgrid-section-sticky\");\n    }\n    return classNames;\n}\nfunction renderScrollShim(arg) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sticky-shim\",\n        style: {\n            width: arg.clientWidth,\n            minWidth: arg.tableMinWidth\n        }\n    });\n}\nfunction getStickyHeaderDates(options) {\n    let { stickyHeaderDates } = options;\n    if (stickyHeaderDates == null || stickyHeaderDates === \"auto\") {\n        stickyHeaderDates = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyHeaderDates;\n}\nfunction getStickyFooterScrollbar(options) {\n    let { stickyFooterScrollbar } = options;\n    if (stickyFooterScrollbar == null || stickyFooterScrollbar === \"auto\") {\n        stickyFooterScrollbar = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyFooterScrollbar;\n}\nclass SimpleScrollGrid extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.processCols = memoize((a)=>a, isColPropsEqual); // so we get same `cols` props every time\n        // yucky to memoize VNodes, but much more efficient for consumers\n        this.renderMicroColGroup = memoize(renderMicroColGroup);\n        this.scrollerRefs = new RefMap();\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.state = {\n            shrinkWidth: null,\n            forceYScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {}\n        };\n        // TODO: can do a really simple print-view. dont need to join rows\n        this.handleSizing = ()=>{\n            this.safeSetState(Object.assign({\n                shrinkWidth: this.computeShrinkWidth()\n            }, this.computeScrollerDims()));\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let sectionConfigs = props.sections || [];\n        let cols = this.processCols(props.cols);\n        let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        if (props.collapsibleWidth) {\n            classNames.push(\"fc-scrollgrid-collapsible\");\n        }\n        // TODO: make DRY\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"header\"){\n            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"body\"){\n            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"footer\"){\n            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        // firefox bug: when setting height on table and there is a thead or tfoot,\n        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n        // if so, use a simpler dom structure, jam everything into a lone tbody.\n        let isBuggy = !getCanVGrowWithinCell();\n        const roleAttrs = {\n            role: \"rowgroup\"\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n            role: \"grid\",\n            className: classNames.join(\" \"),\n            style: {\n                height: props.height\n            }\n        }, Boolean(!isBuggy && headSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"thead\", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tfoot\", roleAttrs, ...footSectionNodes), isBuggy && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, microColGroupNode, isHeader) {\n        if (\"outerContent\" in sectionConfig) {\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                key: sectionConfig.key\n            }, sectionConfig.outerContent);\n        }\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n            key: sectionConfig.key,\n            role: \"presentation\",\n            className: getSectionClassNames(sectionConfig, this.props.liquid).join(\" \")\n        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n    }\n    renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n        if (\"outerContent\" in chunkConfig) {\n            return chunkConfig.outerContent;\n        }\n        let { props } = this;\n        let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;\n        let needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n        let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n        // for `!props.liquid` - is WHOLE scrollgrid natural height?\n        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n        let overflowY = !props.liquid ? \"visible\" : forceYScrollbars ? \"scroll\" : !needsYScrolling ? \"hidden\" : \"auto\";\n        let sectionKey = sectionConfig.key;\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth: \"\",\n            clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n            expandRows: sectionConfig.expandRows,\n            syncRowHeights: false,\n            rowSyncHeights: [],\n            reportRowHeightChange: ()=>{}\n        }, isHeader);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? \"th\" : \"td\", {\n            ref: chunkConfig.elRef,\n            role: \"presentation\"\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: `fc-scroller-harness${isLiquid ? \" fc-scroller-harness-liquid\" : \"\"}`\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Scroller, {\n            ref: this.scrollerRefs.createRef(sectionKey),\n            elRef: this.scrollerElRefs.createRef(sectionKey),\n            overflowY: overflowY,\n            overflowX: !props.liquid ? \"visible\" : \"hidden\" /* natural height? */ ,\n            maxHeight: sectionConfig.maxHeight,\n            liquid: isLiquid,\n            liquidIsAbsolute: true\n        }, content)));\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let section = getSectionByKey(this.props.sections, key);\n        if (section) {\n            setRef(section.chunk.scrollerElRef, scrollerEl);\n        }\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate() {\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing();\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    computeShrinkWidth() {\n        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let { scrollerRefs, scrollerElRefs } = this;\n        let forceYScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for(let sectionKey in scrollerRefs.currentMap){\n            let scroller = scrollerRefs.currentMap[sectionKey];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let section of this.props.sections){\n            let sectionKey = section.key;\n            let scrollerEl = scrollerElRefs.currentMap[sectionKey];\n            if (scrollerEl) {\n                let harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                 : 0));\n                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n            }\n        }\n        return {\n            forceYScrollbars,\n            scrollerClientWidths,\n            scrollerClientHeights\n        };\n    }\n}\nSimpleScrollGrid.addStateEquality({\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual\n});\nfunction getSectionByKey(sections, key) {\n    for (let section of sections){\n        if (section.key === key) {\n            return section;\n        }\n    }\n    return null;\n}\nclass EventContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.handleEl = (el)=>{\n            this.el = el;\n            if (el) {\n                setElSeg(el, this.props.seg);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { seg } = props;\n        const { eventRange } = seg;\n        const { ui } = eventRange;\n        const renderProps = {\n            event: new EventImpl(context, eventRange.def, eventRange.instance),\n            view: context.viewApi,\n            timeText: props.timeText,\n            textColor: ui.textColor,\n            backgroundColor: ui.backgroundColor,\n            borderColor: ui.borderColor,\n            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n            isStart: Boolean(seg.isStart),\n            isEnd: Boolean(seg.isEnd),\n            isPast: Boolean(props.isPast),\n            isFuture: Boolean(props.isFuture),\n            isToday: Boolean(props.isToday),\n            isSelected: Boolean(props.isSelected),\n            isDragging: Boolean(props.isDragging),\n            isResizing: Boolean(props.isResizing)\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* contains children */ , {\n            elRef: this.handleEl,\n            elClasses: [\n                ...getEventClassNames(renderProps),\n                ...seg.eventRange.ui.classNames,\n                ...props.elClasses || []\n            ],\n            renderProps: renderProps,\n            generatorName: \"eventContent\",\n            customGenerator: options.eventContent,\n            defaultGenerator: props.defaultGenerator,\n            classNameGenerator: options.eventClassNames,\n            didMount: options.eventDidMount,\n            willUnmount: options.eventWillUnmount\n        }));\n    }\n    componentDidUpdate(prevProps) {\n        if (this.el && this.props.seg !== prevProps.seg) {\n            setElSeg(this.el, this.props.seg);\n        }\n    }\n}\n// should not be a purecomponent\nclass StandardEvent extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let { ui } = seg.eventRange;\n        let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;\n        let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, Object.assign({}, props /* includes elRef */ , {\n            elTag: \"a\",\n            elStyle: {\n                borderColor: ui.borderColor,\n                backgroundColor: ui.backgroundColor\n            },\n            elAttrs: getSegAnchorAttrs(seg, context),\n            defaultGenerator: renderInnerContent$1,\n            timeText: timeText\n        }), (InnerContent, eventContentArg)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-event-main\"\n                ],\n                elStyle: {\n                    color: eventContentArg.textColor\n                }\n            }), Boolean(eventContentArg.isStartResizable) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-start\"\n            }), Boolean(eventContentArg.isEndResizable) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-end\"\n            })));\n    }\n}\nfunction renderInnerContent$1(innerProps) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-main-frame\"\n    }, innerProps.timeText && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title-container\"\n    }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title fc-sticky\"\n    }, innerProps.event.title || (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"\\xa0\"))));\n}\nconst NowIndicatorContainer = (props)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n        let { options } = context;\n        let renderProps = {\n            isAxis: props.isAxis,\n            date: context.dateEnv.toDate(props.date),\n            view: context.viewApi\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */ , {\n            elTag: props.elTag || \"div\",\n            renderProps: renderProps,\n            generatorName: \"nowIndicatorContent\",\n            customGenerator: options.nowIndicatorContent,\n            classNameGenerator: options.nowIndicatorClassNames,\n            didMount: options.nowIndicatorDidMount,\n            willUnmount: options.nowIndicatorWillUnmount\n        }));\n    });\nconst DAY_NUM_FORMAT = createFormatter({\n    day: \"numeric\"\n});\nclass DayCellContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\n    }\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = this.refineRenderProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            isMonthStart: props.isMonthStart || false,\n            showDayNumber: props.showDayNumber,\n            extraRenderProps: props.extraRenderProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv,\n            monthStartFormat: options.monthStartFormat\n        });\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */ , {\n            elClasses: [\n                ...getDayClassNames(renderProps, context.theme),\n                ...props.elClasses || []\n            ],\n            elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : {\n                \"data-date\": formatDayString(props.date)\n            }),\n            renderProps: renderProps,\n            generatorName: \"dayCellContent\",\n            customGenerator: options.dayCellContent,\n            defaultGenerator: props.defaultGenerator,\n            classNameGenerator: // don't use custom classNames if disabled\n            renderProps.isDisabled ? undefined : options.dayCellClassNames,\n            didMount: options.dayCellDidMount,\n            willUnmount: options.dayCellWillUnmount\n        }));\n    }\n}\nfunction hasCustomDayCellContent(options) {\n    return Boolean(options.dayCellContent || hasCustomRenderingHandler(\"dayCellContent\", options));\n}\nfunction refineRenderProps(raw) {\n    let { date, dateEnv, dateProfile, isMonthStart } = raw;\n    let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);\n    let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : \"\";\n    return Object.assign(Object.assign(Object.assign({\n        date: dateEnv.toDate(date),\n        view: raw.viewApi\n    }, dayMeta), {\n        isMonthStart,\n        dayNumberText\n    }), raw.extraRenderProps);\n}\nclass BgEvent extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { seg } = props;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, {\n            elTag: \"div\",\n            elClasses: [\n                \"fc-bg-event\"\n            ],\n            elStyle: {\n                backgroundColor: seg.eventRange.ui.backgroundColor\n            },\n            defaultGenerator: renderInnerContent,\n            seg: seg,\n            timeText: \"\",\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: false,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday,\n            disableDragging: true,\n            disableResizing: true\n        });\n    }\n}\nfunction renderInnerContent(props) {\n    let { title } = props.event;\n    return title && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, props.event.title);\n}\nfunction renderFill(fillType) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: `fc-${fillType}`\n    });\n}\nconst WeekNumberContainer = (props)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n        let { dateEnv, options } = context;\n        let { date } = props;\n        let format = options.weekNumberFormat || props.defaultFormat;\n        let num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n        let text = dateEnv.format(date, format);\n        let renderProps = {\n            num,\n            text,\n            date\n        };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer // why isn't WeekNumberContentArg being auto-detected?\n        , Object.assign({}, props /* includes children */ , {\n            renderProps: renderProps,\n            generatorName: \"weekNumberContent\",\n            customGenerator: options.weekNumberContent,\n            defaultGenerator: renderInner,\n            classNameGenerator: options.weekNumberClassNames,\n            didMount: options.weekNumberDidMount,\n            willUnmount: options.weekNumberWillUnmount\n        }));\n    });\nfunction renderInner(innerProps) {\n    return innerProps.text;\n}\nconst PADDING_FROM_VIEWPORT = 10;\nclass Popover extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            titleId: getUniqueDomId()\n        };\n        this.handleRootEl = (el)=>{\n            this.rootEl = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        this.handleDocumentMouseDown = (ev)=>{\n            // only hide the popover if the click happened outside the popover\n            const target = getEventTargetViaRoot(ev);\n            if (!this.rootEl.contains(target)) {\n                this.handleCloseClick();\n            }\n        };\n        this.handleDocumentKeyDown = (ev)=>{\n            if (ev.key === \"Escape\") {\n                this.handleCloseClick();\n            }\n        };\n        this.handleCloseClick = ()=>{\n            let { onClose } = this.props;\n            if (onClose) {\n                onClose();\n            }\n        };\n    }\n    render() {\n        let { theme, options } = this.context;\n        let { props, state } = this;\n        let classNames = [\n            \"fc-popover\",\n            theme.getClass(\"popover\")\n        ].concat(props.extraClassNames || []);\n        return (0,preact_compat__WEBPACK_IMPORTED_MODULE_1__.createPortal)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({}, props.extraAttrs, {\n            id: props.id,\n            className: classNames.join(\" \"),\n            \"aria-labelledby\": state.titleId,\n            ref: this.handleRootEl\n        }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-popover-header \" + theme.getClass(\"popoverHeader\")\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n            className: \"fc-popover-title\",\n            id: state.titleId\n        }, props.title), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n            className: \"fc-popover-close \" + theme.getIconClass(\"close\"),\n            title: options.closeHint,\n            onClick: this.handleCloseClick\n        })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-popover-body \" + theme.getClass(\"popoverContent\")\n        }, props.children)), props.parentEl);\n    }\n    componentDidMount() {\n        document.addEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.addEventListener(\"keydown\", this.handleDocumentKeyDown);\n        this.updateSize();\n    }\n    componentWillUnmount() {\n        document.removeEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.removeEventListener(\"keydown\", this.handleDocumentKeyDown);\n    }\n    updateSize() {\n        let { isRtl } = this.context;\n        let { alignmentEl, alignGridTop } = this.props;\n        let { rootEl } = this;\n        let alignmentRect = computeClippedClientRect(alignmentEl);\n        if (alignmentRect) {\n            let popoverDims = rootEl.getBoundingClientRect();\n            // position relative to viewport\n            let popoverTop = alignGridTop ? elementClosest(alignmentEl, \".fc-scrollgrid\").getBoundingClientRect().top : alignmentRect.top;\n            let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n            // constrain\n            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n            let origin = rootEl.offsetParent.getBoundingClientRect();\n            applyStyle(rootEl, {\n                top: popoverTop - origin.top,\n                left: popoverLeft - origin.left\n            });\n        }\n    }\n}\nclass MorePopover extends DateComponent {\n    constructor(){\n        super(...arguments);\n        this.handleRootEl = (rootEl)=>{\n            this.rootEl = rootEl;\n            if (rootEl) {\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    useEventCenter: false\n                });\n            } else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n    }\n    render() {\n        let { options, dateEnv } = this.context;\n        let { props } = this;\n        let { startDate, todayRange, dateProfile } = props;\n        let title = dateEnv.format(startDate, options.dayPopoverFormat);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayCellContainer, {\n            elRef: this.handleRootEl,\n            date: startDate,\n            dateProfile: dateProfile,\n            todayRange: todayRange\n        }, (InnerContent, renderProps, elAttrs)=>(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Popover, {\n                elRef: elAttrs.ref,\n                id: props.id,\n                title: title,\n                extraClassNames: [\n                    \"fc-more-popover\"\n                ].concat(elAttrs.className || []),\n                extraAttrs: elAttrs /* TODO: make these time-based when not whole-day? */ ,\n                parentEl: props.parentEl,\n                alignmentEl: props.alignmentEl,\n                alignGridTop: props.alignGridTop,\n                onClose: props.onClose\n            }, hasCustomDayCellContent(options) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, {\n                elTag: \"div\",\n                elClasses: [\n                    \"fc-more-popover-misc\"\n                ]\n            }), props.children));\n    }\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        let { rootEl, props } = this;\n        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n            return {\n                dateProfile: props.dateProfile,\n                dateSpan: Object.assign({\n                    allDay: !props.forceTimed,\n                    range: {\n                        start: props.startDate,\n                        end: props.endDate\n                    }\n                }, props.extraDateSpan),\n                dayEl: rootEl,\n                rect: {\n                    left: 0,\n                    top: 0,\n                    right: elWidth,\n                    bottom: elHeight\n                },\n                layer: 1\n            };\n        }\n        return null;\n    }\n}\nclass MoreLinkContainer extends BaseComponent {\n    constructor(){\n        super(...arguments);\n        this.state = {\n            isPopoverOpen: false,\n            popoverId: getUniqueDomId()\n        };\n        this.handleLinkEl = (linkEl)=>{\n            this.linkEl = linkEl;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, linkEl);\n            }\n        };\n        this.handleClick = (ev)=>{\n            let { props, context } = this;\n            let { moreLinkClick } = context.options;\n            let date = computeRange(props).start;\n            function buildPublicSeg(seg) {\n                let { def, instance, range } = seg.eventRange;\n                return {\n                    event: new EventImpl(context, def, instance),\n                    start: context.dateEnv.toDate(range.start),\n                    end: context.dateEnv.toDate(range.end),\n                    isStart: seg.isStart,\n                    isEnd: seg.isEnd\n                };\n            }\n            if (typeof moreLinkClick === \"function\") {\n                moreLinkClick = moreLinkClick({\n                    date,\n                    allDay: Boolean(props.allDayDate),\n                    allSegs: props.allSegs.map(buildPublicSeg),\n                    hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n            if (!moreLinkClick || moreLinkClick === \"popover\") {\n                this.setState({\n                    isPopoverOpen: true\n                });\n            } else if (typeof moreLinkClick === \"string\") {\n                context.calendarApi.zoomTo(date, moreLinkClick);\n            }\n        };\n        this.handlePopoverClose = ()=>{\n            this.setState({\n                isPopoverOpen: false\n            });\n        };\n    }\n    render() {\n        let { props, state } = this;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context)=>{\n            let { viewApi, options, calendarApi } = context;\n            let { moreLinkText } = options;\n            let { moreCnt } = props;\n            let range = computeRange(props);\n            let text = typeof moreLinkText === \"function\" // TODO: eventually use formatWithOrdinals\n             ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;\n            let hint = formatWithOrdinals(options.moreLinkHint, [\n                moreCnt\n            ], text);\n            let renderProps = {\n                num: moreCnt,\n                shortText: `+${moreCnt}`,\n                text,\n                view: viewApi\n            };\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Boolean(props.moreCnt) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, {\n                elTag: props.elTag || \"a\",\n                elRef: this.handleLinkEl,\n                elClasses: [\n                    ...props.elClasses || [],\n                    \"fc-more-link\"\n                ],\n                elStyle: props.elStyle,\n                elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), {\n                    title: hint,\n                    \"aria-expanded\": state.isPopoverOpen,\n                    \"aria-controls\": state.isPopoverOpen ? state.popoverId : \"\"\n                }),\n                renderProps: renderProps,\n                generatorName: \"moreLinkContent\",\n                customGenerator: options.moreLinkContent,\n                defaultGenerator: props.defaultGenerator || renderMoreLinkInner,\n                classNameGenerator: options.moreLinkClassNames,\n                didMount: options.moreLinkDidMount,\n                willUnmount: options.moreLinkWillUnmount\n            }, props.children), state.isPopoverOpen && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(MorePopover, {\n                id: state.popoverId,\n                startDate: range.start,\n                endDate: range.end,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraDateSpan: props.extraDateSpan,\n                parentEl: this.parentEl,\n                alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl,\n                alignGridTop: props.alignGridTop,\n                forceTimed: props.forceTimed,\n                onClose: this.handlePopoverClose\n            }, props.popoverContent()));\n        });\n    }\n    componentDidMount() {\n        this.updateParentEl();\n    }\n    componentDidUpdate() {\n        this.updateParentEl();\n    }\n    updateParentEl() {\n        if (this.linkEl) {\n            this.parentEl = elementClosest(this.linkEl, \".fc-view-harness\");\n        }\n    }\n}\nfunction renderMoreLinkInner(props) {\n    return props.text;\n}\nfunction computeRange(props) {\n    if (props.allDayDate) {\n        return {\n            start: props.allDayDate,\n            end: addDays(props.allDayDate, 1)\n        };\n    }\n    let { hiddenSegs } = props;\n    return {\n        start: computeEarliestSegStart(hiddenSegs),\n        end: computeLatestSegEnd(hiddenSegs)\n    };\n}\nfunction computeEarliestSegStart(segs) {\n    return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\nfunction pickEarliestStart(seg0, seg1) {\n    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\nfunction computeLatestSegEnd(segs) {\n    return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\nfunction pickLatestEnd(seg0, seg1) {\n    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n}\nclass Store {\n    constructor(){\n        this.handlers = [];\n    }\n    set(value) {\n        this.currentValue = value;\n        for (let handler of this.handlers){\n            handler(value);\n        }\n    }\n    subscribe(handler) {\n        this.handlers.push(handler);\n        if (this.currentValue !== undefined) {\n            handler(this.currentValue);\n        }\n    }\n}\n/*\nSubscribers will get a LIST of CustomRenderings\n*/ class CustomRenderingStore extends Store {\n    constructor(){\n        super(...arguments);\n        this.map = new Map();\n    }\n    // for consistent order\n    handle(customRendering) {\n        const { map } = this;\n        let updated = false;\n        if (customRendering.isActive) {\n            map.set(customRendering.id, customRendering);\n            updated = true;\n        } else if (map.has(customRendering.id)) {\n            map.delete(customRendering.id);\n            updated = true;\n        }\n        if (updated) {\n            this.set(map);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLWNvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDMkM7QUFDL0I7QUFFN0MsTUFBTU0sYUFBYSxFQUFFO0FBQ3JCLE1BQU1DLFdBQVcsSUFBSUM7QUFDckIsU0FBU0MsYUFBYUMsU0FBUztJQUMzQkosV0FBV0ssSUFBSSxDQUFDRDtJQUNoQkgsU0FBU0ssT0FBTyxDQUFDLENBQUNDO1FBQ2RDLGVBQWVELFNBQVNIO0lBQzVCO0FBQ0o7QUFDQSxTQUFTSyxrQkFBa0JDLEVBQUU7SUFDekIsSUFBSUEsR0FBR0MsV0FBVyxJQUFJLDZDQUE2QztJQUMvREQsR0FBR0UsV0FBVyxDQUFDLGtEQUFrRDtNQUNuRTtRQUNFQyxtQkFBbUJILEdBQUdFLFdBQVc7SUFDckM7QUFDSjtBQUNBLFNBQVNDLG1CQUFtQkMsUUFBUTtJQUNoQyxJQUFJUCxVQUFVTixTQUFTYyxHQUFHLENBQUNEO0lBQzNCLElBQUksQ0FBQ1AsV0FBVyxDQUFDQSxRQUFRSSxXQUFXLEVBQUU7UUFDbENKLFVBQVVPLFNBQVNFLGFBQWEsQ0FBQztRQUNqQyxJQUFJLENBQUNULFNBQVM7WUFDVkEsVUFBVVUsU0FBU3JCLGFBQWEsQ0FBQztZQUNqQ1csUUFBUVcsWUFBWSxDQUFDLHFCQUFxQjtZQUMxQyxNQUFNQyxRQUFRQztZQUNkLElBQUlELE9BQU87Z0JBQ1BaLFFBQVFZLEtBQUssR0FBR0E7WUFDcEI7WUFDQSxNQUFNRSxX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LEVBQUU7UUFDZixJQUFJLENBQUNzL0IsUUFBUSxDQUFDcG1DLElBQUksQ0FBQzhHO1FBQ25CLElBQUksSUFBSSxDQUFDODBELFlBQVksS0FBSzU1RCxXQUFXO1lBQ2pDOEUsUUFBUSxJQUFJLENBQUM4MEQsWUFBWTtRQUM3QjtJQUNKO0FBQ0o7QUFFQTs7QUFFQSxHQUNBLE1BQU1FLDZCQUE2Qkg7SUFDL0JuNUQsYUFBYztRQUNWLEtBQUssSUFBSWl2QjtRQUNULElBQUksQ0FBQ3NOLEdBQUcsR0FBRyxJQUFJbC9CO0lBQ25CO0lBQ0EsdUJBQXVCO0lBQ3ZCazhELE9BQU9DLGVBQWUsRUFBRTtRQUNwQixNQUFNLEVBQUVqOUIsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNwQixJQUFJazlCLFVBQVU7UUFDZCxJQUFJRCxnQkFBZ0JobEMsUUFBUSxFQUFFO1lBQzFCK0gsSUFBSTM5QixHQUFHLENBQUM0NkQsZ0JBQWdCM21DLEVBQUUsRUFBRTJtQztZQUM1QkMsVUFBVTtRQUNkLE9BQ0ssSUFBSWw5QixJQUFJbTlCLEdBQUcsQ0FBQ0YsZ0JBQWdCM21DLEVBQUUsR0FBRztZQUNsQzBKLElBQUlvOUIsTUFBTSxDQUFDSCxnQkFBZ0IzbUMsRUFBRTtZQUM3QjRtQyxVQUFVO1FBQ2Q7UUFDQSxJQUFJQSxTQUFTO1lBQ1QsSUFBSSxDQUFDNzZELEdBQUcsQ0FBQzI5QjtRQUNiO0lBQ0o7QUFDSjtBQUVtdkoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGFuZXIvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLWNvbW1vbi5qcz81NTlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHByZWFjdCBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncHJlYWN0L2NvbXBhdCc7XG5cbmNvbnN0IHN0eWxlVGV4dHMgPSBbXTtcbmNvbnN0IHN0eWxlRWxzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gaW5qZWN0U3R5bGVzKHN0eWxlVGV4dCkge1xuICAgIHN0eWxlVGV4dHMucHVzaChzdHlsZVRleHQpO1xuICAgIHN0eWxlRWxzLmZvckVhY2goKHN0eWxlRWwpID0+IHtcbiAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVsSGFzU3R5bGVzKGVsKSB7XG4gICAgaWYgKGVsLmlzQ29ubmVjdGVkICYmIC8vIHNvbWV0aW1lcyB0cnVlIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICAgICBlbC5nZXRSb290Tm9kZSAvLyBzb21ldGltZXMgdW5kZWZpbmVkIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICkge1xuICAgICAgICByZWdpc3RlclN0eWxlc1Jvb3QoZWwuZ2V0Um9vdE5vZGUoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXNSb290KHJvb3ROb2RlKSB7XG4gICAgbGV0IHN0eWxlRWwgPSBzdHlsZUVscy5nZXQocm9vdE5vZGUpO1xuICAgIGlmICghc3R5bGVFbCB8fCAhc3R5bGVFbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBzdHlsZUVsID0gcm9vdE5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1mdWxsY2FsZW5kYXJdJyk7XG4gICAgICAgIGlmICghc3R5bGVFbCkge1xuICAgICAgICAgICAgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzdHlsZUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1mdWxsY2FsZW5kYXInLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdldE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlRWwubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsID0gcm9vdE5vZGUgPT09IGRvY3VtZW50ID8gZG9jdW1lbnQuaGVhZCA6IHJvb3ROb2RlO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gcm9vdE5vZGUgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgPyBwYXJlbnRFbC5xdWVyeVNlbGVjdG9yKCdzY3JpcHQsbGlua1tyZWw9c3R5bGVzaGVldF0sbGlua1thcz1zdHlsZV0sc3R5bGUnKVxuICAgICAgICAgICAgICAgIDogcGFyZW50RWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShzdHlsZUVsLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWxzLnNldChyb290Tm9kZSwgc3R5bGVFbCk7XG4gICAgICAgIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpIHtcbiAgICBmb3IgKGNvbnN0IHN0eWxlVGV4dCBvZiBzdHlsZVRleHRzKSB7XG4gICAgICAgIGFwcGVuZFN0eWxlc1RvKHN0eWxlRWwsIHN0eWxlVGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KSB7XG4gICAgY29uc3QgeyBzaGVldCB9ID0gc3R5bGVFbDtcbiAgICBjb25zdCBydWxlQ250ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgIHN0eWxlVGV4dC5zcGxpdCgnfScpLmZvckVhY2goKHN0eWxlU3RyLCBpKSA9PiB7XG4gICAgICAgIHN0eWxlU3RyID0gc3R5bGVTdHIudHJpbSgpO1xuICAgICAgICBpZiAoc3R5bGVTdHIpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoc3R5bGVTdHIgKyAnfScsIHJ1bGVDbnQgKyBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gbm9uY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCBxdWVyaWVkTm9uY2VWYWx1ZTtcbmZ1bmN0aW9uIGdldE5vbmNlVmFsdWUoKSB7XG4gICAgaWYgKHF1ZXJpZWROb25jZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVlcmllZE5vbmNlVmFsdWUgPSBxdWVyeU5vbmNlVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJpZWROb25jZVZhbHVlO1xufVxuLypcblRPRE86IGRpc2NvdXJhZ2UgbWV0YSB0YWcgYW5kIGluc3RlYWQgcHV0IG5vbmNlIGF0dHJpYnV0ZSBvbiBwbGFjZWhvbGRlciA8c3R5bGU+IHRhZ1xuKi9cbmZ1bmN0aW9uIHF1ZXJ5Tm9uY2VWYWx1ZSgpIHtcbiAgICBjb25zdCBtZXRhV2l0aE5vbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NwLW5vbmNlXCJdJyk7XG4gICAgaWYgKG1ldGFXaXRoTm9uY2UgJiYgbWV0YVdpdGhOb25jZS5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICByZXR1cm4gbWV0YVdpdGhOb25jZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcbiAgICB9XG4gICAgY29uc3QgZWxXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbbm9uY2VdJyk7XG4gICAgaWYgKGVsV2l0aE5vbmNlKSB7XG4gICAgICAgIHJldHVybiBlbFdpdGhOb25jZS5ub25jZSB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLy8gbWFpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZWdpc3RlclN0eWxlc1Jvb3QoZG9jdW1lbnQpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtc21hbGwtZm9udC1zaXplOi44NWVtOy0tZmMtcGFnZS1iZy1jb2xvcjojZmZmOy0tZmMtbmV1dHJhbC1iZy1jb2xvcjpoc2xhKDAsMCUsODIlLC4zKTstLWZjLW5ldXRyYWwtdGV4dC1jb2xvcjpncmV5Oy0tZmMtYm9yZGVyLWNvbG9yOiNkZGQ7LS1mYy1idXR0b24tdGV4dC1jb2xvcjojZmZmOy0tZmMtYnV0dG9uLWJnLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24tYm9yZGVyLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24taG92ZXItYmctY29sb3I6IzFlMmIzNzstLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yOiMxNTFlMjc7LS1mYy1ldmVudC1iZy1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC10ZXh0LWNvbG9yOiNmZmY7LS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yOnJnYmEoMCwwLDAsLjI1KTstLWZjLW1vcmUtbGluay1iZy1jb2xvcjojZDBkMGQwOy0tZmMtbW9yZS1saW5rLXRleHQtY29sb3I6aW5oZXJpdDstLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aDoxcHg7LS1mYy1ub24tYnVzaW5lc3MtY29sb3I6aHNsYSgwLDAlLDg0JSwuMyk7LS1mYy1iZy1ldmVudC1jb2xvcjojOGZkZjgyOy0tZmMtYmctZXZlbnQtb3BhY2l0eTowLjM7LS1mYy1oaWdobGlnaHQtY29sb3I6cmdiYSgxODgsMjMyLDI0MSwuMyk7LS1mYy10b2RheS1iZy1jb2xvcjpyZ2JhKDI1NSwyMjAsNDAsLjE1KTstLWZjLW5vdy1pbmRpY2F0b3ItY29sb3I6cmVkfS5mYy1ub3QtYWxsb3dlZCwuZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50e2N1cnNvcjpub3QtYWxsb3dlZH0uZmN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LXNpemU6MWVtfS5mYywuZmMgKiwuZmMgOmFmdGVyLC5mYyA6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmMgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Zm9udC1zaXplOjFlbX0uZmMgdGh7dGV4dC1hbGlnbjpjZW50ZXJ9LmZjIHRkLC5mYyB0aHtwYWRkaW5nOjA7dmVydGljYWwtYWxpZ246dG9wfS5mYyBhW2RhdGEtbmF2bGlua117Y3Vyc29yOnBvaW50ZXJ9LmZjIGFbZGF0YS1uYXZsaW5rXTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5mYy1kaXJlY3Rpb24tbHRye2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpsZWZ0fS5mYy1kaXJlY3Rpb24tcnRse2RpcmVjdGlvbjpydGw7dGV4dC1hbGlnbjpyaWdodH0uZmMtdGhlbWUtc3RhbmRhcmQgdGQsLmZjLXRoZW1lLXN0YW5kYXJkIHRoe2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMtbGlxdWlkLWhhY2sgdGQsLmZjLWxpcXVpZC1oYWNrIHRoe3Bvc2l0aW9uOnJlbGF0aXZlfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6ZmNpY29ucztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7c3JjOnVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9LmZjLWljb257c3BlYWs6bm9uZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpmY2ljb25zIWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtoZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7d2lkdGg6MWVtfS5mYy1pY29uLWNoZXZyb24tbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDBcXFwifS5mYy1pY29uLWNoZXZyb24tcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAxXFxcIn0uZmMtaWNvbi1jaGV2cm9ucy1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMlxcXCJ9LmZjLWljb24tY2hldnJvbnMtcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAzXFxcIn0uZmMtaWNvbi1taW51cy1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA0XFxcIn0uZmMtaWNvbi1wbHVzLXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDVcXFwifS5mYy1pY29uLXg6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA2XFxcIn0uZmMgLmZjLWJ1dHRvbntib3JkZXItcmFkaXVzOjA7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O21hcmdpbjowO292ZXJmbG93OnZpc2libGU7dGV4dC10cmFuc2Zvcm06bm9uZX0uZmMgLmZjLWJ1dHRvbjpmb2N1c3tvdXRsaW5lOjFweCBkb3R0ZWQ7b3V0bGluZTo1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3J9LmZjIC5mYy1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbn0uZmMgLmZjLWJ1dHRvbjpub3QoOmRpc2FibGVkKXtjdXJzb3I6cG9pbnRlcn0uZmMgLmZjLWJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czouMjVlbTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6MWVtO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoxLjU7cGFkZGluZzouNGVtIC42NWVtO3RleHQtYWxpZ246Y2VudGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b246aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDQ0LDYyLDgwLC4yNSk7b3V0bGluZTowfS5mYyAuZmMtYnV0dG9uOmRpc2FibGVke29wYWNpdHk6LjY1fS5mYyAuZmMtYnV0dG9uLXByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24tYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDc2LDkxLDEwNiwuNSl9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWFjdGl2ZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlOmZvY3VzLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uIC5mYy1pY29ue2ZvbnQtc2l6ZToxLjVlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXB7ZGlzcGxheTppbmxpbmUtZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbntmbGV4OjEgMSBhdXRvO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b24uZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmZvY3VzLC5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246aG92ZXJ7ei1pbmRleDoxfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO21hcmdpbi1sZWZ0Oi0xcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7bWFyZ2luLXJpZ2h0Oi0xcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMgLmZjLXRvb2xiYXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0uZmMgLmZjLXRvb2xiYXIuZmMtaGVhZGVyLXRvb2xiYXJ7bWFyZ2luLWJvdHRvbToxLjVlbX0uZmMgLmZjLXRvb2xiYXIuZmMtZm9vdGVyLXRvb2xiYXJ7bWFyZ2luLXRvcDoxLjVlbX0uZmMgLmZjLXRvb2xiYXItdGl0bGV7Zm9udC1zaXplOjEuNzVlbTttYXJnaW46MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDouNzVlbX0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXItbHRye2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtc2Nyb2xsZXJ7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGV7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1zY3JvbGxlci1oYXJuZXNze2RpcmVjdGlvbjpsdHI7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXNjcm9sbGVyLWhhcm5lc3M+LmZjLXNjcm9sbGVye2RpcmVjdGlvbjpydGx9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1zY3JvbGxncmlke2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMgLmZjLXNjcm9sbGdyaWQsLmZjIC5mYy1zY3JvbGxncmlkIHRhYmxle3RhYmxlLWxheW91dDpmaXhlZDt3aWR0aDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXtib3JkZXItbGVmdC1zdHlsZTpoaWRkZW47Ym9yZGVyLXJpZ2h0LXN0eWxlOmhpZGRlbjtib3JkZXItdG9wLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWR7Ym9yZGVyLWJvdHRvbS13aWR0aDowO2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZTtib3JkZXItcmlnaHQtd2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uIHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPnRke2hlaWdodDoxcHh9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkPnRke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPip7Ym9yZGVyLWxlZnQtd2lkdGg6MDtib3JkZXItdG9wLXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyPiosLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyPip7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWJvZHkgdGFibGUsLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyIHRhYmxle2JvcmRlci1ib3R0b20tc3R5bGU6aGlkZGVufS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7cG9zaXRpb246c3RpY2t5O3otaW5kZXg6M30uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1oZWFkZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe3RvcDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlci5mYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Pip7Ym90dG9tOjB9LmZjIC5mYy1zY3JvbGxncmlkLXN0aWNreS1zaGlte2hlaWdodDoxcHg7bWFyZ2luLWJvdHRvbTotMXB4fS5mYy1zdGlja3l7cG9zaXRpb246c3RpY2t5fS5mYyAuZmMtdmlldy1oYXJuZXNze2ZsZXgtZ3JvdzoxO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdmlldy1oYXJuZXNzLWFjdGl2ZT4uZmMtdmlld3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDRweH0uZmMgLmZjLWJnLWV2ZW50LC5mYyAuZmMtaGlnaGxpZ2h0LC5mYyAuZmMtbm9uLWJ1c2luZXNze2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtbm9uLWJ1c2luZXNze2JhY2tncm91bmQ6dmFyKC0tZmMtbm9uLWJ1c2luZXNzLWNvbG9yKX0uZmMgLmZjLWJnLWV2ZW50e2JhY2tncm91bmQ6dmFyKC0tZmMtYmctZXZlbnQtY29sb3IpO29wYWNpdHk6dmFyKC0tZmMtYmctZXZlbnQtb3BhY2l0eSl9LmZjIC5mYy1iZy1ldmVudCAuZmMtZXZlbnQtdGl0bGV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7Zm9udC1zdHlsZTppdGFsaWM7bWFyZ2luOi41ZW19LmZjIC5mYy1oaWdobGlnaHR7YmFja2dyb3VuZDp2YXIoLS1mYy1oaWdobGlnaHQtY29sb3IpfS5mYyAuZmMtY2VsbC1zaGFkZWQsLmZjIC5mYy1kYXktZGlzYWJsZWR7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1hLmZjLWV2ZW50LGEuZmMtZXZlbnQ6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjLWV2ZW50LmZjLWV2ZW50LWRyYWdnYWJsZSwuZmMtZXZlbnRbaHJlZl17Y3Vyc29yOnBvaW50ZXJ9LmZjLWV2ZW50IC5mYy1ldmVudC1tYWlue3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6Mn0uZmMtZXZlbnQtZHJhZ2dpbmc6bm90KC5mYy1ldmVudC1zZWxlY3RlZCl7b3BhY2l0eTouNzV9LmZjLWV2ZW50LWRyYWdnaW5nLmZjLWV2ZW50LXNlbGVjdGVke2JveC1zaGFkb3c6MCAycHggN3B4IHJnYmEoMCwwLDAsLjMpfS5mYy1ldmVudCAuZmMtZXZlbnQtcmVzaXplcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplciwuZmMtZXZlbnQ6aG92ZXIgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpibG9ja30uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXItY29sb3I6aW5oZXJpdDtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLzIpO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtYm9yZGVyLXdpZHRoKTtoZWlnaHQ6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKX0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXI6YmVmb3Jle2JvdHRvbTotMjBweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTIwcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTIwcHg7dG9wOi0yMHB4fS5mYy1ldmVudC1zZWxlY3RlZCwuZmMtZXZlbnQ6Zm9jdXN7Ym94LXNoYWRvdzowIDJweCA1cHggcmdiYSgwLDAsMCwuMil9LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZSwuZmMtZXZlbnQ6Zm9jdXM6YmVmb3Jle2JvdHRvbTowO2NvbnRlbnQ6XFxcIlxcXCI7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjA7ei1pbmRleDozfS5mYy1ldmVudC1zZWxlY3RlZDphZnRlciwuZmMtZXZlbnQ6Zm9jdXM6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yKTtib3R0b206LTFweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTFweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMXB4O3RvcDotMXB4O3otaW5kZXg6MX0uZmMtaC1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKX0uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXh9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4td2lkdGg6MH0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGVmdDowO21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtyaWdodDowO3ZlcnRpY2FsLWFsaWduOnRvcH0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7Ym90dG9tOjA7dG9wOjA7d2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6dy1yZXNpemU7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtjdXJzb3I6ZS1yZXNpemU7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcnttYXJnaW4tdG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpKi0uNSk7dG9wOjUwJX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtyaWdodDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYyAuZmMtcG9wb3Zlcntib3gtc2hhZG93OjAgMnB4IDZweCByZ2JhKDAsMCwwLC4xNSk7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYyAuZmMtcG9wb3Zlci1oZWFkZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47cGFkZGluZzozcHggNHB4fS5mYyAuZmMtcG9wb3Zlci10aXRsZXttYXJnaW46MCAycHh9LmZjIC5mYy1wb3BvdmVyLWNsb3Nle2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjFlbTtvcGFjaXR5Oi42NX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLXBvcG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVyLWhlYWRlcntiYWNrZ3JvdW5kOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpfVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuY2xhc3MgRGVsYXllZFJ1bm5lciB7XG4gICAgY29uc3RydWN0b3IoZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgfVxuICAgIHJlcXVlc3QoZGVsYXkpIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgvLyBOT1QgT1BUSU1BTCEgVE9ETzogbG9vayBhdCBkZWJvdW5jZVxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4uYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKHNjb3BlID0gJycpIHtcbiAgICAgICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXM7XG4gICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSA9IChwYXVzZURlcHRoc1tzY29wZV0gfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH1cbiAgICByZXN1bWUoc2NvcGUgPSAnJywgZm9yY2UpIHtcbiAgICAgICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzY29wZSBpbiBwYXVzZURlcHRocykge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSAtPSAxO1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aCA9IHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF1c2VEZXB0aHNbc2NvcGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGF1c2VEZXB0aHMpLmxlbmd0aDtcbiAgICB9XG4gICAgdHJ5RHJhaW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5lZCgpOyAvLyBtaWdodCBzZXQgaXNEaXJ0eSB0byB0cnVlIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbmVkKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH1cbn1cbi8vIFF1ZXJ5aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBlbGVtZW50Q2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoZWwuY2xvc2VzdCkge1xuICAgICAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgIC8vIHJlYWxseSBiYWQgZmFsbGJhY2sgZm9yIElFXG4gICAgICAgIC8vIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdFxuICAgIH1cbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgICAgaWYgKGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IChlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGUpO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICAgIGxldCBtZXRob2QgPSBlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvcjtcbiAgICByZXR1cm4gbWV0aG9kLmNhbGwoZWwsIHNlbGVjdG9yKTtcbn1cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIHJldHVybnMgYSByZWFsIGFycmF5LiBnb29kIGZvciBtZXRob2RzIGxpa2UgZm9yRWFjaFxuLy8gVE9ETzogYWNjZXB0IHRoZSBkb2N1bWVudFxuZnVuY3Rpb24gZmluZEVsZW1lbnRzKGNvbnRhaW5lciwgc2VsZWN0b3IpIHtcbiAgICBsZXQgY29udGFpbmVycyA9IGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW2NvbnRhaW5lcl0gOiBjb250YWluZXI7XG4gICAgbGV0IGFsbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBjb250YWluZXJzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChtYXRjaGVzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsTWF0Y2hlcztcbn1cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIG9ubHkgcXVlcmllcyBkaXJlY3QgY2hpbGQgZWxlbWVudHMgLy8gVE9ETzogcmVuYW1lIHRvIGZpbmREaXJlY3RDaGlsZHJlbiFcbmZ1bmN0aW9uIGZpbmREaXJlY3RDaGlsZHJlbihwYXJlbnQsIHNlbGVjdG9yKSB7XG4gICAgbGV0IHBhcmVudHMgPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtwYXJlbnRdIDogcGFyZW50O1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gcGFyZW50c1tpXS5jaGlsZHJlbjsgLy8gb25seSBldmVyIGVsZW1lbnRzXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbal07XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IGVsZW1lbnRNYXRjaGVzKGNoaWxkTm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBTdHlsZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IGAke3ZhbH1weGA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbDtcbiAgICB9XG59XG4vLyBFdmVudCBIYW5kbGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gaWYgaW50ZXJjZXB0aW5nIGJ1YmJsZWQgZXZlbnRzIGF0IHRoZSBkb2N1bWVudC93aW5kb3cvYm9keSBsZXZlbCxcbi8vIGFuZCB3YW50IHRvIHNlZSBvcmlnaW5hdGluZyBlbGVtZW50ICh0aGUgJ3RhcmdldCcpLCB1c2UgdGhpcyB1dGlsIGluc3RlYWRcbi8vIG9mIGBldi50YXJnZXRgIGJlY2F1c2UgaXQgZ29lcyB3aXRoaW4gd2ViLWNvbXBvbmVudCBib3VuZGFyaWVzLlxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZXYuY29tcG9zZWRQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChldilbMF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV2LnRhcmdldDtcbn1cbi8vIFVuaXF1ZSBJRCBmb3IgRE9NIGF0dHJpYnV0ZVxubGV0IGd1aWQkMSA9IDA7XG5mdW5jdGlvbiBnZXRVbmlxdWVEb21JZCgpIHtcbiAgICBndWlkJDEgKz0gMTtcbiAgICByZXR1cm4gJ2ZjLWRvbS0nICsgZ3VpZCQxO1xufVxuXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbn1cbi8vIEV2ZW50IERlbGVnYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gKGV2KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsIGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICBsZXQgYXR0YWNoZWRIYW5kbGVyID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcik7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IoY29udGFpbmVyLCBzZWxlY3Rvciwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUpIHtcbiAgICBsZXQgY3VycmVudE1hdGNoZWRDaGlsZDtcbiAgICByZXR1cm4gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsICdtb3VzZW92ZXInLCBzZWxlY3RvciwgKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCAhPT0gY3VycmVudE1hdGNoZWRDaGlsZCkge1xuICAgICAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG1hdGNoZWRDaGlsZDtcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcihtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgICAgIGxldCByZWFsT25Nb3VzZUxlYXZlID0gKG1vdXNlTGVhdmVFdikgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZShtb3VzZUxlYXZlRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIEFuaW1hdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbmVuZCcsXG5dO1xuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlYWxDYWxsYmFjayA9IChldikgPT4ge1xuICAgICAgICBjYWxsYmFjayhldik7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIH0pO1xufVxuLy8gQVJJQSB3b3JrYXJvdW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgb25DbGljazogaGFuZGxlciB9LCBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIG9uS2V5RG93bihldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxubGV0IGd1aWROdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBndWlkTnVtYmVyICs9IDE7XG4gICAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKTtcbn1cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICdub25lJztcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XG4gICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgIGxldCBzcGVjcyA9IFtdO1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgdG9rZW47XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwZWNzO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGNtcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjc1tpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjKSB7XG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuLyogU3RyaW5nIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikge1xuICAgIGxldCBzID0gU3RyaW5nKHZhbCk7XG4gICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2l0aE9yZGluYWxzKGZvcm1hdHRlciwgYXJncywgZmFsbGJhY2tUZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlciguLi5hcmdzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIG5vbi1ibGFuayBzdHJpbmdcbiAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKChzdHIsIGFyZywgaW5kZXgpID0+IChzdHIucmVwbGFjZSgnJCcgKyBpbmRleCwgYXJnIHx8ICcnKSksIGZvcm1hdHRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG4vKiBOdW1iZXIgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5mdW5jdGlvbiBpc0ludChuKSB7XG4gICAgcmV0dXJuIG4gJSAxID09PSAwO1xufVxuLyogRkMtc3BlY2lmaWMgRE9NIGRpbWVuc2lvbiBzdHVmZlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgoY2VsbEVsKSB7XG4gICAgbGV0IGFsbFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyk7XG4gICAgbGV0IGNvbnRlbnRXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyk7XG4gICAgaWYgKCFhbGxXaWR0aEVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZHMgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUgY2xhc3NOYW1lJyk7IC8vIFRPRE86IHVzZSBjb25zdFxuICAgIH1cbiAgICBpZiAoIWNvbnRlbnRXaWR0aEVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZHMgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbiBjbGFzc05hbWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIGFsbFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyAvLyB0aGUgY2VsbCBwYWRkaW5nK2JvcmRlclxuICAgICAgICBjb250ZW50V2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbn1cblxuY29uc3QgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddO1xuY29uc3QgUEFSU0VfUkUgPSAvXigtPykoPzooXFxkKylcXC4pPyhcXGQrKTooXFxkXFxkKSg/OjooXFxkXFxkKSg/OlxcLihcXGRcXGRcXGQpKT8pPy87XG4vLyBQYXJzaW5nIGFuZCBDcmVhdGlvblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHVuaXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KHsgW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddOiBpbnB1dCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzKSB7XG4gICAgbGV0IG0gPSBQQVJTRV9SRS5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICAgIGxldCBzaWduID0gbVsxXSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiAwLFxuICAgICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgICAgZGF5czogc2lnbiAqIChtWzJdID8gcGFyc2VJbnQobVsyXSwgMTApIDogMCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IHNpZ24gKiAoKG1bM10gPyBwYXJzZUludChtWzNdLCAxMCkgOiAwKSAqIDYwICogNjAgKiAxMDAwICsgLy8gaG91cnNcbiAgICAgICAgICAgICAgICAobVs0XSA/IHBhcnNlSW50KG1bNF0sIDEwKSA6IDApICogNjAgKiAxMDAwICsgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgIChtWzVdID8gcGFyc2VJbnQobVs1XSwgMTApIDogMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIChtWzZdID8gcGFyc2VJbnQobVs2XSwgMTApIDogMCkgLy8gbXNcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qob2JqKSB7XG4gICAgbGV0IGR1cmF0aW9uID0ge1xuICAgICAgICB5ZWFyczogb2JqLnllYXJzIHx8IG9iai55ZWFyIHx8IDAsXG4gICAgICAgIG1vbnRoczogb2JqLm1vbnRocyB8fCBvYmoubW9udGggfHwgMCxcbiAgICAgICAgZGF5czogb2JqLmRheXMgfHwgb2JqLmRheSB8fCAwLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChvYmouaG91cnMgfHwgb2JqLmhvdXIgfHwgMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAob2JqLm1pbnV0ZXMgfHwgb2JqLm1pbnV0ZSB8fCAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIChvYmouc2Vjb25kcyB8fCBvYmouc2Vjb25kIHx8IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgIChvYmoubWlsbGlzZWNvbmRzIHx8IG9iai5taWxsaXNlY29uZCB8fCBvYmoubXMgfHwgMCksIC8vIG1zXG4gICAgfTtcbiAgICBsZXQgd2Vla3MgPSBvYmoud2Vla3MgfHwgb2JqLndlZWs7XG4gICAgaWYgKHdlZWtzKSB7XG4gICAgICAgIGR1cmF0aW9uLmRheXMgKz0gd2Vla3MgKiA3O1xuICAgICAgICBkdXJhdGlvbi5zcGVjaWZpZWRXZWVrcyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbn1cbi8vIEVxdWFsaXR5XG5mdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMCwgZDEpIHtcbiAgICByZXR1cm4gZDAueWVhcnMgPT09IGQxLnllYXJzICYmXG4gICAgICAgIGQwLm1vbnRocyA9PT0gZDEubW9udGhzICYmXG4gICAgICAgIGQwLmRheXMgPT09IGQxLmRheXMgJiZcbiAgICAgICAgZDAubWlsbGlzZWNvbmRzID09PSBkMS5taWxsaXNlY29uZHM7XG59XG5mdW5jdGlvbiBhc0NsZWFuRGF5cyhkdXIpIHtcbiAgICBpZiAoIWR1ci55ZWFycyAmJiAhZHVyLm1vbnRocyAmJiAhZHVyLm1pbGxpc2Vjb25kcykge1xuICAgICAgICByZXR1cm4gZHVyLmRheXM7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLy8gU2ltcGxlIE1hdGhcbmZ1bmN0aW9uIGFkZER1cmF0aW9ucyhkMCwgZDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZDAueWVhcnMgKyBkMS55ZWFycyxcbiAgICAgICAgbW9udGhzOiBkMC5tb250aHMgKyBkMS5tb250aHMsXG4gICAgICAgIGRheXM6IGQwLmRheXMgKyBkMS5kYXlzLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQwLm1pbGxpc2Vjb25kcyArIGQxLm1pbGxpc2Vjb25kcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDEsIGQwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQxLnllYXJzIC0gZDAueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDEubW9udGhzIC0gZDAubW9udGhzLFxuICAgICAgICBkYXlzOiBkMS5kYXlzIC0gZDAuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMS5taWxsaXNlY29uZHMgLSBkMC5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZCwgbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkLnllYXJzICogbixcbiAgICAgICAgbW9udGhzOiBkLm1vbnRocyAqIG4sXG4gICAgICAgIGRheXM6IGQuZGF5cyAqIG4sXG4gICAgICAgIG1pbGxpc2Vjb25kczogZC5taWxsaXNlY29uZHMgKiBuLFxuICAgIH07XG59XG4vLyBDb252ZXJzaW9uc1xuLy8gXCJSb3VnaFwiIGJlY2F1c2UgdGhleSBhcmUgYmFzZWQgb24gYXZlcmFnZS1jYXNlIEdyZWdvcmlhbiBtb250aHMveWVhcnNcbmZ1bmN0aW9uIGFzUm91Z2hZZWFycyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaERheXMoZHVyKSAvIDM2NTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNb250aHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hEYXlzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDg2NGU1O1xufVxuZnVuY3Rpb24gYXNSb3VnaE1pbnV0ZXMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBhc1JvdWdoU2Vjb25kcyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAxMDAwO1xufVxuZnVuY3Rpb24gYXNSb3VnaE1zKGR1cikge1xuICAgIHJldHVybiBkdXIueWVhcnMgKiAoMzY1ICogODY0ZTUpICtcbiAgICAgICAgZHVyLm1vbnRocyAqICgzMCAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5kYXlzICogODY0ZTUgK1xuICAgICAgICBkdXIubWlsbGlzZWNvbmRzO1xufVxuLy8gQWR2YW5jZWQgTWF0aFxuZnVuY3Rpb24gd2hvbGVEaXZpZGVEdXJhdGlvbnMobnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSU5URVJOQUxfVU5JVFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHVuaXQgPSBJTlRFUk5BTF9VTklUU1tpXTtcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yW3VuaXRdKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxSZXMgPSBudW1lcmF0b3JbdW5pdF0gLyBkZW5vbWluYXRvclt1bml0XTtcbiAgICAgICAgICAgIGlmICghaXNJbnQobG9jYWxSZXMpIHx8IChyZXMgIT09IG51bGwgJiYgcmVzICE9PSBsb2NhbFJlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IGxvY2FsUmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bWVyYXRvclt1bml0XSkge1xuICAgICAgICAgICAgLy8gbmVlZHMgdG8gZGl2aWRlIGJ5IHNvbWV0aGluZyBidXQgY2FuJ3QhXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cikge1xuICAgIGxldCBtcyA9IGR1ci5taWxsaXNlY29uZHM7XG4gICAgaWYgKG1zKSB7XG4gICAgICAgIGlmIChtcyAlIDEwMDAgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG1zIC8gMTAwMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjAgKiA2MCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwICogNjApIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR1ci5kYXlzKSB7XG4gICAgICAgIGlmIChkdXIuc3BlY2lmaWVkV2Vla3MgJiYgZHVyLmRheXMgJSA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBkdXIuZGF5cyAvIDcgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IGR1ci5kYXlzIH07XG4gICAgfVxuICAgIGlmIChkdXIubW9udGhzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBkdXIubW9udGhzIH07XG4gICAgfVxuICAgIGlmIChkdXIueWVhcnMpIHtcbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogZHVyLnllYXJzIH07XG4gICAgfVxuICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiAwIH07XG59XG5cbi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XG4gICAgbGV0IHJlbW92ZUNudCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVDbnQ7XG59XG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jKSB7XG4gICAgaWYgKGEwID09PSBhMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGxlbiA9IGEwLmxlbmd0aDtcbiAgICBsZXQgaTtcbiAgICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghKGVxdWFsaXR5RnVuYyA/IGVxdWFsaXR5RnVuYyhhMFtpXSwgYTFbaV0pIDogYTBbaV0gPT09IGExW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBEQVlfSURTID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcbi8vIEFkZGluZ1xuZnVuY3Rpb24gYWRkV2Vla3MobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVsyXSArPSBuICogNztcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGREYXlzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbjtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGRNcyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzZdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuLy8gRGlmZmluZyAoYWxsIHJldHVybiBmbG9hdHMpXG4vLyBUT0RPOiB3aHkgbm90IHVzZSByYW5nZXM/XG5mdW5jdGlvbiBkaWZmV2Vla3MobTAsIG0xKSB7XG4gICAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3O1xufVxuZnVuY3Rpb24gZGlmZkRheXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xufVxuZnVuY3Rpb24gZGlmZkhvdXJzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmTWludXRlcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKTtcbn1cbmZ1bmN0aW9uIGRpZmZTZWNvbmRzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDA7XG59XG5mdW5jdGlvbiBkaWZmRGF5QW5kVGltZShtMCwgbTEpIHtcbiAgICBsZXQgbTBkYXkgPSBzdGFydE9mRGF5KG0wKTtcbiAgICBsZXQgbTFkYXkgPSBzdGFydE9mRGF5KG0xKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICBkYXlzOiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wZGF5LCBtMWRheSkpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChtMS52YWx1ZU9mKCkgLSBtMWRheS52YWx1ZU9mKCkpIC0gKG0wLnZhbHVlT2YoKSAtIG0wZGF5LnZhbHVlT2YoKSksXG4gICAgfTtcbn1cbi8vIERpZmZpbmcgV2hvbGUgVW5pdHNcbmZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wLCBtMSkge1xuICAgIGxldCBkID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkIC8gNztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkaWZmV2hvbGVEYXlzKG0wLCBtMSkge1xuICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBTdGFydC1PZlxuZnVuY3Rpb24gc3RhcnRPZkRheShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZkhvdXIobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZlNlY29uZChtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgICAgICBtLmdldFVUQ1NlY29uZHMoKSxcbiAgICBdKTtcbn1cbi8vIFdlZWsgQ29tcHV0YXRpb25cbmZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xuICAgIGxldCB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgbGV0IHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSk7XG4gICAgaWYgKHcgPCAxKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpO1xuICAgIH1cbiAgICBsZXQgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xuICAgIGlmIChuZXh0VyA+PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0Vyk7XG4gICAgfVxuICAgIHJldHVybiB3O1xufVxuZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcbiAgICBsZXQgZmlyc3RXZWVrU3RhcnQgPSBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSldKTtcbiAgICBsZXQgZGF5U3RhcnQgPSBzdGFydE9mRGF5KG1hcmtlcik7XG4gICAgbGV0IGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDE7IC8vIHplcm8taW5kZXhlZFxufVxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgIGxldCBmd2QgPSA3ICsgZG93IC0gZG95O1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICBsZXQgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xufVxuLy8gQXJyYXkgQ29udmVyc2lvblxuZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgIGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcbiAgICBdO1xufVxuZnVuY3Rpb24gYXJyYXlUb0xvY2FsRGF0ZShhKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFbMF0sIGFbMV0gfHwgMCwgYVsyXSA9PSBudWxsID8gMSA6IGFbMl0sIC8vIGRheSBvZiBtb250aFxuICAgIGFbM10gfHwgMCwgYVs0XSB8fCAwLCBhWzVdIHx8IDApO1xufVxuZnVuY3Rpb24gZGF0ZVRvVXRjQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNb250aCgpLFxuICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9VdGNEYXRlKGEpIHtcbiAgICAvLyBhY2NvcmRpbmcgdG8gd2ViIHN0YW5kYXJkcyAoYW5kIFNhZmFyaSksIGEgbW9udGggaW5kZXggaXMgcmVxdWlyZWQuXG4gICAgLy8gbWFzc2FnZSBpZiBvbmx5IGdpdmVuIGEgeWVhci5cbiAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYSA9IGEuY29uY2F0KFswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyguLi5hKSk7XG59XG4vLyBPdGhlciBVdGlsc1xuZnVuY3Rpb24gaXNWYWxpZERhdGUobSkge1xuICAgIHJldHVybiAhaXNOYU4obS52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gdGltZUFzTXMobSkge1xuICAgIHJldHVybiBtLmdldFVUQ0hvdXJzKCkgKiAxMDAwICogNjAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpICogMTAwMCAqIDYwICtcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcbiAgICAgICAgbS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbn1cblxuLy8gdGltZVpvbmVPZmZzZXQgaXMgaW4gbWludXRlc1xuZnVuY3Rpb24gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgc3RyaXBaZXJvVGltZSA9IGZhbHNlKSB7XG4gICAgbGV0IHMgPSBtYXJrZXIudG9JU09TdHJpbmcoKTtcbiAgICBzID0gcy5yZXBsYWNlKCcuMDAwJywgJycpO1xuICAgIGlmIChzdHJpcFplcm9UaW1lKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJ1QwMDowMDowMFonLCAnJyk7XG4gICAgfVxuICAgIGlmIChzLmxlbmd0aCA+IDEwKSB7IC8vIHRpbWUgcGFydCB3YXNuJ3Qgc3RyaXBwZWQsIGNhbiBhZGQgdGltZXpvbmUgaW5mb1xuICAgICAgICBpZiAodGltZVpvbmVPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnWicsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aW1lWm9uZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnWicsIGZvcm1hdFRpbWVab25lT2Zmc2V0KHRpbWVab25lT2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBpdHMgVVRDLTAgYW5kIHdlIHdhbnQgdG8ga2VlcCB0aGUgWlxuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbi8vIGZvcm1hdHMgdGhlIGRhdGUsIGJ1dCB3aXRoIG5vIHRpbWUgcGFydFxuLy8gVE9ETzogc29tZWhvdyBtZXJnZSB3aXRoIGJ1aWxkSXNvU3RyaW5nIGFuZCBzdHJpcFplcm9UaW1lXG4vLyBUT0RPOiByZW5hbWUuIG9taXQgXCJzdHJpbmdcIlxuZnVuY3Rpb24gZm9ybWF0RGF5U3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9ULiokLywgJycpO1xufVxuZnVuY3Rpb24gZm9ybWF0SXNvTW9udGhTdHIobWFya2VyKSB7XG4gICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLm1hdGNoKC9eXFxkezR9LVxcZHsyfS8pWzBdO1xufVxuLy8gVE9ETzogdXNlIERhdGU6OnRvSVNPU3RyaW5nIGFuZCB1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgVD9cbmZ1bmN0aW9uIGZvcm1hdElzb1RpbWVTdHJpbmcobWFya2VyKSB7XG4gICAgcmV0dXJuIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENIb3VycygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICtcbiAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ1NlY29uZHMoKSwgMik7XG59XG5mdW5jdGlvbiBmb3JtYXRUaW1lWm9uZU9mZnNldChtaW51dGVzLCBkb0lzbyA9IGZhbHNlKSB7XG4gICAgbGV0IHNpZ24gPSBtaW51dGVzIDwgMCA/ICctJyA6ICcrJztcbiAgICBsZXQgYWJzID0gTWF0aC5hYnMobWludXRlcyk7XG4gICAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihhYnMgLyA2MCk7XG4gICAgbGV0IG1pbnMgPSBNYXRoLnJvdW5kKGFicyAlIDYwKTtcbiAgICBpZiAoZG9Jc28pIHtcbiAgICAgICAgcmV0dXJuIGAke3NpZ24gKyBwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWlucywgMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBHTVQke3NpZ259JHtob3Vyc30ke21pbnMgPyBgOiR7cGFkU3RhcnQobWlucywgMil9YCA6ICcnfWA7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJncztcbiAgICBsZXQgY3VycmVudFJlcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLm5ld0FyZ3MpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJncykge1xuICAgICAgICAgICAgY3VycmVudFJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ3MsIG5ld0FyZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplT2JqQXJnKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZztcbiAgICBsZXQgY3VycmVudFJlcztcbiAgICByZXR1cm4gKG5ld0FyZykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRBcmcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmNhbGwodGhpcywgbmV3QXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNQcm9wc0VxdWFsKGN1cnJlbnRBcmcsIG5ld0FyZykpIHtcbiAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnID0gbmV3QXJnO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZSgvLyB1c2VkIGF0IGFsbD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ1NldHMgPSBbXTtcbiAgICBsZXQgY3VycmVudFJlc3VsdHMgPSBbXTtcbiAgICByZXR1cm4gKG5ld0FyZ1NldHMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRMZW4gPSBjdXJyZW50QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBuZXdMZW4gPSBuZXdBcmdTZXRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGN1cnJlbnRMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFuZXdBcmdTZXRzW2ldKSB7IC8vIG9uZSBvZiB0aGUgb2xkIHNldHMgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnU2V0c1tpXSwgbmV3QXJnU2V0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJnU2V0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ1NldHMgPSBuZXdBcmdTZXRzO1xuICAgICAgICBjdXJyZW50UmVzdWx0cy5zcGxpY2UobmV3TGVuKTsgLy8gcmVtb3ZlIGV4Y2Vzc1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc3VsdHM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVIYXNobGlrZSh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdIYXNoID0ge307XG4gICAgbGV0IGN1cnJlbnRSZXNIYXNoID0ge307XG4gICAgcmV0dXJuIChuZXdBcmdIYXNoKSA9PiB7XG4gICAgICAgIGxldCBuZXdSZXNIYXNoID0ge307XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBuZXdBcmdIYXNoKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRSZXNIYXNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnSGFzaFtrZXldLCBuZXdBcmdIYXNoW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gKHJlc0VxdWFsaXR5ICYmIHJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc0hhc2hba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFJlc0hhc2hba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IGN1cnJlbnRSZXNIYXNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ0hhc2ggPSBuZXdBcmdIYXNoO1xuICAgICAgICBjdXJyZW50UmVzSGFzaCA9IG5ld1Jlc0hhc2g7XG4gICAgICAgIHJldHVybiBuZXdSZXNIYXNoO1xuICAgIH07XG59XG5cbmNvbnN0IEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xuICAgIHdlZWs6IDMsXG4gICAgc2VwYXJhdG9yOiA5LFxuICAgIG9taXRaZXJvTWludXRlOiA5LFxuICAgIG1lcmlkaWVtOiA5LFxuICAgIG9taXRDb21tYXM6IDksXG59O1xuY29uc3QgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XG4gICAgdGltZVpvbmVOYW1lOiA3LFxuICAgIGVyYTogNixcbiAgICB5ZWFyOiA1LFxuICAgIG1vbnRoOiA0LFxuICAgIGRheTogMixcbiAgICB3ZWVrZGF5OiAyLFxuICAgIGhvdXI6IDEsXG4gICAgbWludXRlOiAxLFxuICAgIHNlY29uZDogMSxcbn07XG5jb25zdCBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXG5jb25zdCBDT01NQV9SRSA9IC8sL2c7IC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcbmNvbnN0IE1VTFRJX1NQQUNFX1JFID0gL1xccysvZztcbmNvbnN0IExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXG5jb25zdCBVVENfUkUgPSAvVVRDfEdNVC87XG5jbGFzcyBOYXRpdmVGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgIGxldCBzdGFuZGFyZERhdGVQcm9wcyA9IHt9O1xuICAgICAgICBsZXQgZXh0ZW5kZWRTZXR0aW5ncyA9IHt9O1xuICAgICAgICBsZXQgc21hbGxlc3RVbml0TnVtID0gOTsgLy8gdGhlIHNtYWxsZXN0IHVuaXQgaW4gdGhlIGZvcm1hdHRlciAoOSBpcyBhIHNlbnRpbmVsLCBiZXlvbmQgbWF4KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXZlcml0eSA9IEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChzZXZlcml0eSA8IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3RVbml0TnVtID0gTWF0aC5taW4oRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVNbbmFtZV0sIHNtYWxsZXN0VW5pdE51bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3RVbml0TnVtID0gTWF0aC5taW4oU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV0sIHNtYWxsZXN0VW5pdE51bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbmRhcmREYXRlUHJvcHMgPSBzdGFuZGFyZERhdGVQcm9wcztcbiAgICAgICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5ncztcbiAgICAgICAgdGhpcy5zbWFsbGVzdFVuaXROdW0gPSBzbWFsbGVzdFVuaXROdW07XG4gICAgICAgIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyA9IG1lbW9pemUoYnVpbGRGb3JtYXR0aW5nRnVuYyk7XG4gICAgfVxuICAgIGZvcm1hdChkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmModGhpcy5zdGFuZGFyZERhdGVQcm9wcywgdGhpcy5leHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KShkYXRlKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICBsZXQgeyBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRpZmZTZXZlcml0eSA9IGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoc3RhcnQubWFya2VyLCBlbmQubWFya2VyLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKTtcbiAgICAgICAgaWYgKCFkaWZmU2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChzdGFydCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IGRpZmZTZXZlcml0eTtcbiAgICAgICAgaWYgKGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA+IDEgJiYgLy8gdGhlIHR3byBkYXRlcyBhcmUgZGlmZmVyZW50IGluIGEgd2F5IHRoYXQncyBsYXJnZXIgc2NhbGUgdGhhbiB0aW1lXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMuZGF5ID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMuZGF5ID09PSAnMi1kaWdpdCcpKSB7XG4gICAgICAgICAgICBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSAxOyAvLyBtYWtlIGl0IGxvb2sgbGlrZSB0aGUgZGF0ZXMgYXJlIG9ubHkgZGlmZmVyZW50IGluIHRlcm1zIG9mIHRpbWVcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVsbDAgPSB0aGlzLmZvcm1hdChzdGFydCwgY29udGV4dCk7XG4gICAgICAgIGxldCBmdWxsMSA9IHRoaXMuZm9ybWF0KGVuZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChmdWxsMCA9PT0gZnVsbDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdWxsMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFydGlhbERhdGVQcm9wcyA9IGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMoc3RhbmRhcmREYXRlUHJvcHMsIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCk7XG4gICAgICAgIGxldCBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMgPSBidWlsZEZvcm1hdHRpbmdGdW5jKHBhcnRpYWxEYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgICAgICBsZXQgcGFydGlhbDAgPSBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMoc3RhcnQpO1xuICAgICAgICBsZXQgcGFydGlhbDEgPSBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMoZW5kKTtcbiAgICAgICAgbGV0IGluc2VydGlvbiA9IGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpO1xuICAgICAgICBsZXQgc2VwYXJhdG9yID0gZXh0ZW5kZWRTZXR0aW5ncy5zZXBhcmF0b3IgfHwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvciB8fCBjb250ZXh0LmRlZmF1bHRTZXBhcmF0b3IgfHwgJyc7XG4gICAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRpb24uYmVmb3JlICsgcGFydGlhbDAgKyBzZXBhcmF0b3IgKyBwYXJ0aWFsMSArIGluc2VydGlvbi5hZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVsbDAgKyBzZXBhcmF0b3IgKyBmdWxsMTtcbiAgICB9XG4gICAgZ2V0U21hbGxlc3RVbml0KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc21hbGxlc3RVbml0TnVtKSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpOyAvLyBjb3B5XG4gICAgZXh0ZW5kZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgbGV0IG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgbGV0IHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBsZXQgemVyb1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0ZSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IGRhdGU7XG4gICAgICAgIGxldCBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IGAke20xLnRvTG9jYWxlTG93ZXJDYXNlKCl9bWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCkgPT4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIGxldCByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCAoKSA9PiB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gYCAke3R6b1N0cn1gO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrVGV4dCwgd2Vla1RleHRMb25nLCBsb2NhbGUsIGRpc3BsYXkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHRMb25nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0JyB8fCBkaXNwbGF5ID09PSAnbmFycm93Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJyB8fCBkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKTtcbiAgICB9XG4gICAgcGFydHMucHVzaChsb2NhbGUuc2ltcGxlTnVtYmVyRm9ybWF0LmZvcm1hdChudW0pKTtcbiAgICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XG4gICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgICBsZXQgcGFydGlhbE9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSA8PSBiaWdnZXN0VW5pdCkge1xuICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICBsZXQgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIGxldCBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICBsZXQgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmNsYXNzIENtZEZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmNGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5jb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgZml4ZWRXZWVrQ291bnQ6IEJvb2xlYW4sXG4gICAgdmFsaWRSYW5nZTogaWRlbnRpdHksXG4gICAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSxcbiAgICB0aXRsZUZvcm1hdDogaWRlbnRpdHksXG4gICAgZXZlbnRJbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICAvLyBvbmx5IHVzZWQgYnkgbGlzdC12aWV3LCBidXQgbGFuZ3VhZ2VzIGRlZmluZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgaXQgaW4gYmFzZSBvcHRpb25zXG4gICAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG4gICAgdmlld0hpbnQ6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBjbG9zZUhpbnQ6IFN0cmluZyxcbiAgICB0aW1lSGludDogU3RyaW5nLFxuICAgIGV2ZW50SGludDogU3RyaW5nLFxuICAgIG1vcmVMaW5rQ2xpY2s6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgLy8gZm9yIGNvbm5lY3RvcnNcbiAgICAvLyAoY2FuJ3QgYmUgcGFydCBvZiBwbHVnaW4gc3lzdGVtIGIvYyBtdXN0IGJlIHByb3ZpZGVkIGF0IHJ1bnRpbWUpXG4gICAgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdNZXRhTWFwOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdSZXBsYWNlczogQm9vbGVhbixcbn07XG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5jb25zdCBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG4gICAgbW9udGhTdGFydEZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9LFxufTtcbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbmNvbnN0IENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTID0ge1xuICAgIGhlYWRlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZm9vdGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkhpbnRzOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkljb25zOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgcGx1Z2luczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50czogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50U291cmNlczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIFsncmVzb3VyY2VzJ106IGlzTWF5YmVBcnJheXNFcXVhbCxcbn07XG5mdW5jdGlvbiBpc01heWJlT2JqZWN0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIpIHsgLy8gYm90aCBub24tbnVsbCBvYmplY3RzXG4gICAgICAgIHJldHVybiBpc1Byb3BzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gaXNNYXliZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBWSUVXX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29tcG9uZW50OiBpZGVudGl0eSxcbiAgICBidXR0b25UZXh0OiBTdHJpbmcsXG4gICAgYnV0dG9uVGV4dEtleTogU3RyaW5nLFxuICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IGlkZW50aXR5LFxuICAgIHVzZXNNaW5NYXhUaW1lOiBCb29sZWFuLFxuICAgIGNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3aWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gdXRpbCBmdW5jc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gbWVyZ2VSYXdPcHRpb25zKG9wdGlvblNldHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25TZXRzLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyk7XG59XG5mdW5jdGlvbiByZWZpbmVQcm9wcyhpbnB1dCwgcmVmaW5lcnMpIHtcbiAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgIGxldCBleHRyYSA9IHt9O1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHJlZmluZXJzKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcmVmaW5lZFtwcm9wTmFtZV0gPSByZWZpbmVyc1twcm9wTmFtZV0oaW5wdXRbcHJvcE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiByZWZpbmVycykpIHtcbiAgICAgICAgICAgIGV4dHJhW3Byb3BOYW1lXSA9IGlucHV0W3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZpbmVkLCBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXApIHtcbiAgICBsZXQgZGVzdCA9IHt9O1xuICAgIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV4UHJvcHNNYXBbbmFtZV0gPT09IGlzTWF5YmVPYmplY3RzRXF1YWwpIHsgLy8gaW1wbGllcyB0aGF0IGl0J3Mgb2JqZWN0LW1lcmdlYWJsZVxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHByb3BPYmpzW2ldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gZmlsdGVySGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIG1hcEhhc2goaGFzaCwgZnVuYykge1xuICAgIGxldCBuZXdIYXNoID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdIYXNoO1xufVxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYSkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgaXRlbSBvZiBhKSB7XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIFRPRE86IHJlYXNzZXNzIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPW9iamVjdC52YWx1ZXNcbmZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikge1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBhLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIQU5ETEVSX1JFID0gL15vbltBLVpdLztcbmZ1bmN0aW9uIGlzTm9uSGFuZGxlclByb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGNvbnN0IGtleXMgPSBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFIQU5ETEVSX1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzID0ge30pIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCwgc3RlcCA9IDEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICBsZXQgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5sZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbmNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcbiAgICBnZXRNYXJrZXJZZWFyKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0TWFya2VyTW9udGgoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJEYXkoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfVxuICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH1cbiAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcbiAgICB9XG59XG5yZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xuXG5jb25zdCBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBsZXQgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKGAwLiR7bVsxMl19YCkgKiAxMDAwIDogMCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtWzEzXSkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gKG1bMTVdID09PSAnLScgPyAtMSA6IDEpICogKE51bWJlcihtWzE2XSB8fCAwKSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1bMThdIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIERhdGVFbnYge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIGNyZWF0ZU1hcmtlcihpbnB1dCkge1xuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfVxuICAgIGNyZWF0ZU5vd01hcmtlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wVG9NYXJrZXIobmV3IERhdGUoKS52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgdGhlIGN1cnJlbnQgZGF0ZSB2YWwgZm9yIGEgdGltZXpvbmUsXG4gICAgICAgIC8vIGJldHRlciB0byBnaXZlIHRoZSBjdXJyZW50IGxvY2FsIGRhdGUgdmFscyB0aGFuIFVUQ1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9O1xuICAgIH1cbiAgICBwYXJzZShzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gcGFydHM7XG4gICAgICAgIGxldCBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBwYXJ0cy5pc1RpbWVVbnNwZWNpZmllZCwgZm9yY2VkVHpvIH07XG4gICAgfVxuICAgIC8vIEFjY2Vzc29yc1xuICAgIGdldFllYXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0TW9udGgobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfVxuICAgIGdldERheShtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgYWRkKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgc3VidHJhY3QobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSAtPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gLT0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSAtPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSAtPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRZZWFycyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRNb250aHMobWFya2VyLCBuKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgLy8gRGlmZmluZyBXaG9sZSBVbml0c1xuICAgIGRpZmZXaG9sZVllYXJzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRpZmZXaG9sZU1vbnRocyhtMCwgbTEpIHtcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmFuZ2UgLyBEdXJhdGlvblxuICAgIGdyZWF0ZXN0V2hvbGVVbml0KG0wLCBtMSkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZVdlZWtzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZNaW51dGVzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9O1xuICAgIH1cbiAgICBjb3VudER1cmF0aW9uc0JldHdlZW4obTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgbGV0IGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfVxuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIHN0YXJ0T2YobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRPZlllYXIobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZNb250aChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZXZWVrKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gV2VlayBOdW1iZXJcbiAgICBjb21wdXRlV2Vla051bWJlcihtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXJGdW5jKHRoaXMudG9EYXRlKG1hcmtlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1hcmtlciwgdGhpcy53ZWVrRG93LCB0aGlzLndlZWtEb3kpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBmb3JtYXQobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlciksXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBmb3JtYXRJc28obWFya2VyLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfVxuICAgIC8vIFRpbWVab25lXG4gICAgdGltZXN0YW1wVG9NYXJrZXIobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfVxuICAgIG9mZnNldEZvck1hcmtlcihtKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gLWFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7IC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb252ZXJzaW9uXG4gICAgdG9EYXRlKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH1cbn1cblxuY2xhc3MgVGhlbWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEljb25PdmVycmlkZShpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIGxldCBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIGxldCBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcbiAgICAgICAgICAgIGZvciAoYnV0dG9uTmFtZSBpbiBpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGdldENsYXNzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfVxuICAgIGdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lO1xuICAgICAgICBpZiAoaXNSdGwgJiYgdGhpcy5ydGxJY29uQ2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5ydGxJY29uQ2xhc3Nlc1tidXR0b25OYW1lXSB8fCB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7dGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJyc7XG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XG5cbi8qXG5OT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXG5TZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXG4qL1xuZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XG4gICAgcnVuQmVmb3JlRmx1c2goKTtcbiAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIGxldCBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbmNsYXNzIEZha2VDb21wb25lbnQgZXh0ZW5kcyBwcmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7IHJldHVybiBwcmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30pOyB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7IHRoaXMuc2V0U3RhdGUoe30pOyB9XG59XG4vLyBUT0RPOiB1c2UgcHJlYWN0L2NvbXBhdCBpbnN0ZWFkP1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgQ29udGV4dFR5cGUgPSBwcmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcbiAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cblxuY2xhc3MgU2Nyb2xsUmVzcG9uZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9O1xuICAgICAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIHVwZGF0ZShpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVmlld0NvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIG5vd01hbmFnZXIsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudixcbiAgICAgICAgbm93TWFuYWdlcixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYyxcbiAgICAgICAgdmlld0FwaSxcbiAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XG4gICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xuICAgIH1cbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xuUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xufVxuQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XG4gICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50SW5qZWN0b3IgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdG9yTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdSZXBsYWNlcyB8fCAhaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxSZWYoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUmVmID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IGN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVyUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBhdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgW10sIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xuICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgY3JlYXRlRWxlbWVudCkgOlxuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gaXNWYWxpZEVsZW1lbnQoY3VzdG9tR2VuZXJhdG9yUmVzKSAvLyB2ZG9tIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW4gdmRvbVxuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XG4gICAgfVxuICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy51cGRhdGVFbFJlZiwgLy8gZnJvbnQtZW5kIGZyYW1ld29yayB0ZWxscyB1cyBhYm91dCBuZXcgY29udGFpbmVyIGVsc1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3JNZXRhIH0sIHByb3BzKSwgeyBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmZpbHRlcihpc1RydXRoeSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UXVldWV1ZERvbU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5iYXNlO1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwocXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnREb21Ob2Rlcy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Tm9kZSBvZiBxdWV1ZWREb21Ob2Rlcykge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbnRlbnRJbmplY3Rvci5hZGRQcm9wc0VxdWFsaXR5KHtcbiAgICBlbENsYXNzZXM6IGlzQXJyYXlzRXF1YWwsXG4gICAgZWxTdHlsZTogaXNQcm9wc0VxdWFsLFxuICAgIGVsQXR0cnM6IGlzTm9uSGFuZGxlclByb3BzRXF1YWwsXG4gICAgcmVuZGVyUHJvcHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuLy8gVXRpbFxuLypcbkRvZXMgVUktZnJhbWV3b3JrIHByb3ZpZGUgY3VzdG9tIHdheSBvZiByZW5kZXJpbmcgdGhhdCBkb2VzIG5vdCB1c2UgUHJlYWN0IFZET01cbkFORCBkb2VzIHRoZSBjYWxlbmRhcidzIG9wdGlvbnMgZGVmaW5lIGN1c3RvbSByZW5kZXJpbmc/XG5BS0EuIFNob3VsZCB3ZSBOT1QgcmVuZGVyIHRoZSBkZWZhdWx0IGNvbnRlbnQ/XG4qL1xuZnVuY3Rpb24gaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nICYmXG4gICAgICAgIGdlbmVyYXRvck5hbWUgJiZcbiAgICAgICAgKChfYSA9IG9wdGlvbnMuY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2dlbmVyYXRvck5hbWVdKSk7XG59XG5mdW5jdGlvbiBidWlsZEVsQXR0cnMocHJvcHMsIGV4dHJhQ2xhc3NOYW1lcywgZWxSZWYpIHtcbiAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBlbFJlZiB9KTtcbiAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xuICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbn1cblxuY29uc3QgUmVuZGVySWQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5jbGFzcyBDb250ZW50Q29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5Jbm5lckNvbnRlbnQgPSBJbm5lckNvbnRlbnRJbmplY3Rvci5iaW5kKHVuZGVmaW5lZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdGhpcy5kaWRNb3VudE1pc2ZpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMsIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xuICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmNvbmNhdChnZW5lcmF0ZWRDbGFzc05hbWVzKSwgcmVuZGVySWQ6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWRNb3VudE1pc2ZpcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgIH1cbn1cbkNvbnRlbnRDb250YWluZXIuY29udGV4dFR5cGUgPSBSZW5kZXJJZDtcbmZ1bmN0aW9uIElubmVyQ29udGVudEluamVjdG9yKGNvbnRhaW5lckNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBwYXJlbnRQcm9wcyA9IGNvbnRhaW5lckNvbXBvbmVudC5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgoQ29udGVudEluamVjdG9yKSwgT2JqZWN0LmFzc2lnbih7IHJlbmRlclByb3BzOiBwYXJlbnRQcm9wcy5yZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogcGFyZW50UHJvcHMuZ2VuZXJhdG9yTmFtZSwgY3VzdG9tR2VuZXJhdG9yOiBwYXJlbnRQcm9wcy5jdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3I6IHBhcmVudFByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlcklkOiBjb250YWluZXJDb21wb25lbnQuY29udGV4dCB9LCBwcm9wcykpO1xufVxuLy8gVXRpbHNcbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lcyhjbGFzc05hbWVHZW5lcmF0b3IsIHJlbmRlclByb3BzKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVHZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IocmVuZGVyUHJvcHMpIDpcbiAgICAgICAgY2xhc3NOYW1lR2VuZXJhdG9yIHx8IFtdO1xuICAgIHJldHVybiB0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgPyBbY2xhc3NOYW1lc10gOiBjbGFzc05hbWVzO1xufVxuXG5jbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXG4gICAgICAgICdmYy12aWV3JyxcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gW107XG4gICAgbGV0IHsgc3RhcnQgfSA9IGNvbnN0cmFpbnRSYW5nZTsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCk7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTA7XG4gICAgbGV0IG5ld1JhbmdlID0gbnVsbDtcbiAgICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSByYW5nZTEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZTEuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmFuZ2U7XG59XG5mdW5jdGlvbiByYW5nZXNFcXVhbChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgICAgIChyYW5nZTAuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5lbmQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLmVuZC52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuZW5kID09PSBudWxsIHx8IHJhbmdlMS5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTAuZW5kID4gcmFuZ2UxLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZCk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkge1xuICAgIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxuICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zTWFya2VyKHJhbmdlLCBkYXRlKSB7XG4gICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xufVxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG5mdW5jdGlvbiBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGRhdGUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XG4gICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcbiAgICBsZXQgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB2YWxpZFJhbmdlO1xuICAgICAgICBsZXQgY3VycmVudEluZm87XG4gICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZTtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XG4gICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXG4gICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFsaWRSYW5nZSxcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcbiAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxuICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG4gICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucHJvcHMuZGF0ZUVudi50b0RhdGUodGhpcy5wcm9wcy5ub3dNYW5hZ2VyLmdldERhdGVNYXJrZXIoKSkpXG4gICAgICAgICAgICA6IGlucHV0O1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVSYW5nZShzaW1wbGVJbnB1dCkgfHxcbiAgICAgICAgICAgIHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9OyAvLyBjb21wbGV0ZWx5IG9wZW4tZW5kZWRcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXG4gICAgLy8gaGlnaGxpZ2h0ZWQgYXMgYmVpbmcgdGhlIGN1cnJlbnQgbW9udGggZm9yIGV4YW1wbGUuXG4gICAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXG4gICAgLy8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxuICAgIGJ1aWxkQ3VycmVudFJhbmdlSW5mbyhkYXRlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIGxldCB1bml0ID0gbnVsbDtcbiAgICAgICAgbGV0IHJhbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGRheUNvdW50O1xuICAgICAgICBpZiAocHJvcHMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gcHJvcHMuZHVyYXRpb247XG4gICAgICAgICAgICB1bml0ID0gcHJvcHMuZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5wcm9wcy5kYXlDb3VudCkpIHtcbiAgICAgICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChyYW5nZSA9IHRoaXMuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UoZGF0ZSkpKSB7XG4gICAgICAgICAgICB1bml0ID0gcHJvcHMuZGF0ZUVudi5ncmVhdGVzdFdob2xlVW5pdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKS51bml0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcbiAgICAgICAgICAgIHVuaXQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pLnVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbiwgdW5pdCwgcmFuZ2UgfTtcbiAgICB9XG4gICAgZ2V0RmFsbGJhY2tEdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5OiAxIH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgbmV3IGFjdGl2ZVJhbmdlIHRvIGhhdmUgdGltZSB2YWx1ZXMgKHVuLWFtYmlndWF0ZSlcbiAgICAvLyBzbG90TWluVGltZSBvciBzbG90TWF4VGltZSBjYXVzZXMgdGhlIHJhbmdlIHRvIGV4cGFuZC5cbiAgICBhZGp1c3RBY3RpdmVSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCB1c2VzTWluTWF4VGltZSwgc2xvdE1pblRpbWUsIHNsb3RNYXhUaW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTtcbiAgICAgICAgaWYgKHVzZXNNaW5NYXhUaW1lKSB7XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNaW5UaW1lIGlzIG5lZ2F0aXZlICh3aHkgbm90IHdoZW4gcG9zaXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNaW5UaW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpOyAvLyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LmFkZChzdGFydCwgc2xvdE1pblRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWF4VGltZSBpcyBiZXlvbmQgb25lIGRheSAod2h5IG5vdCB3aGVuIG5lZ2F0aXZlPylcbiAgICAgICAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWF4VGltZSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpOyAvLyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIC0xKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIHNsb3RNYXhUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXG4gICAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciB1bml0IG9mIGR1cmF0aW9uLlxuICAgIGJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBkYXRlQWxpZ25tZW50IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgIGxldCBlbmQ7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxuICAgICAgICBpZiAoIWRhdGVBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoZGF0ZUluY3JlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgc21hbGxlciBvZiB0aGUgdHdvIHVuaXRzXG4gICAgICAgICAgICAgICAgaWYgKGFzUm91Z2hNcyhkYXRlSW5jcmVtZW50KSA8IGFzUm91Z2hNcyhkdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUFsaWdubWVudCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkYXRlSW5jcmVtZW50KS51bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUFsaWdubWVudCA9IHVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZUFsaWdubWVudCA9IHVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHZpZXcgZGlzcGxheXMgYSBzaW5nbGUgZGF5IG9yIHNtYWxsZXJcbiAgICAgICAgaWYgKGFzUm91Z2hEYXlzKGR1cmF0aW9uKSA8PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbkRheShzdGFydCkpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUmVzKCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2YoZGF0ZSwgZGF0ZUFsaWdubWVudCk7XG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pO1xuICAgICAgICAgICAgcmVzID0geyBzdGFydCwgZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICAvLyBpZiByYW5nZSBpcyBjb21wbGV0ZWx5IGVudmVsb3BlZCBieSBoaWRkZW4gZGF5cywgZ28gcGFzdCB0aGUgaGlkZGVuIGRheXNcbiAgICAgICAgaWYgKCF0aGlzLnRyaW1IaWRkZW5EYXlzKHJlcykpIHtcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGRhdGUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxuICAgIGJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBkYXRlQWxpZ25tZW50IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgcnVubmluZ0NvdW50ID0gMDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZGF0ZTtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKGRhdGVBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKHN0YXJ0LCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgMSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW5EYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChydW5uaW5nQ291bnQgPCBkYXlDb3VudCk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcbiAgICAvLyB3aGljaCBpcyBhIHdheSB0byBkZWZpbmUgdGhlIGN1cnJlbnRSYW5nZSBhbmQgYWN0aXZlUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cbiAgICBidWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaW5wdXQgPSBwcm9wcy52aXNpYmxlUmFuZ2VJbnB1dDtcbiAgICAgICAgbGV0IHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwocHJvcHMuY2FsZW5kYXJBcGksIHByb3BzLmRhdGVFbnYudG9EYXRlKGRhdGUpKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yZWZpbmVSYW5nZShzaW1wbGVJbnB1dCk7XG4gICAgICAgIGlmIChyYW5nZSAmJiAocmFuZ2Uuc3RhcnQgPT0gbnVsbCB8fCByYW5nZS5lbmQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHJhbmdlIHRoYXQgd2lsbCByZXByZXNlbnQgdGhlIGVsZW1lbnQvY2VsbHMgZm9yICpyZW5kZXJpbmcqLFxuICAgIC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICAgIGJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmFuZ2U7XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxuICAgIGJ1aWxkRGF0ZUluY3JlbWVudChmYWxsYmFjaykge1xuICAgICAgICBsZXQgeyBkYXRlSW5jcmVtZW50IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgY3VzdG9tQWxpZ25tZW50O1xuICAgICAgICBpZiAoZGF0ZUluY3JlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVJbmNyZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLnByb3BzLmRhdGVBbGlnbm1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oMSwgY3VzdG9tQWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pO1xuICAgIH1cbiAgICByZWZpbmVSYW5nZShyYW5nZUlucHV0KSB7XG4gICAgICAgIGlmIChyYW5nZUlucHV0KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBwYXJzZVJhbmdlKHJhbmdlSW5wdXQsIHRoaXMucHJvcHMuZGF0ZUVudik7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiBIaWRkZW4gRGF5c1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgLy8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xuICAgIGluaXRIaWRkZW5EYXlzKCkge1xuICAgICAgICBsZXQgaGlkZGVuRGF5cyA9IHRoaXMucHJvcHMuaGlkZGVuRGF5cyB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cbiAgICAgICAgbGV0IGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXG4gICAgICAgIGxldCBkYXlDbnQgPSAwO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMud2Vla2VuZHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCEoaXNIaWRkZW5EYXlIYXNoW2ldID0gaGlkZGVuRGF5cy5pbmRleE9mKGkpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBkYXlDbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRheUNudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhpZGRlbkRheXMnKTsgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGRheXMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRoYXQgYXJlIGNvbXB1dGVkIGFzIGhpZGRlbi5cbiAgICAvLyBJZiB0aGUgd2hvbGUgcmFuZ2UgaXMgdHJpbW1lZCBvZmYsIHJldHVybnMgbnVsbFxuICAgIHRyaW1IaWRkZW5EYXlzKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5za2lwSGlkZGVuRGF5cyhlbmQsIC0xLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBJcyB0aGUgY3VycmVudCBkYXkgaGlkZGVuP1xuICAgIC8vIGBkYXlgIGlzIGEgZGF5LW9mLXdlZWsgaW5kZXggKDAtNiksIG9yIGEgRGF0ZSAodXNlZCBmb3IgVVRDKVxuICAgIGlzSGlkZGVuRGF5KGRheSkge1xuICAgICAgICBpZiAoZGF5IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZGF5ID0gZGF5LmdldFVUQ0RheSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldO1xuICAgIH1cbiAgICAvLyBJbmNyZW1lbnRpbmcgdGhlIGN1cnJlbnQgZGF5IHVudGlsIGl0IGlzIG5vIGxvbmdlciBhIGhpZGRlbiBkYXksIHJldHVybmluZyBhIGNvcHkuXG4gICAgLy8gRE9FUyBOT1QgQ09OU0lERVIgdmFsaWRSYW5nZSFcbiAgICAvLyBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgZGF0ZWAgaXMgbm90IGEgaGlkZGVuIGRheSwgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgLy8gUGFzcyBgaXNFeGNsdXNpdmVgIGFzIGB0cnVlYCBpZiB5b3UgYXJlIGRlYWxpbmcgd2l0aCBhbiBlbmQgZGF0ZS5cbiAgICAvLyBgaW5jYCBkZWZhdWx0cyB0byBgMWAgKGluY3JlbWVudCBvbmUgZGF5IGZvcndhcmQgZWFjaCB0aW1lKVxuICAgIHNraXBIaWRkZW5EYXlzKGRhdGUsIGluYyA9IDEsIGlzRXhjbHVzaXZlID0gZmFsc2UpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNIaWRkZW5EYXlIYXNoWyhkYXRlLmdldFVUQ0RheSgpICsgKGlzRXhjbHVzaXZlID8gaW5jIDogMCkgKyA3KSAlIDddKSB7XG4gICAgICAgICAgICBkYXRlID0gYWRkRGF5cyhkYXRlLCBpbmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwgcmFuZ2UsIGZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnN0YW5jZUlkOiBndWlkKCksXG4gICAgICAgIGRlZklkLFxuICAgICAgICByYW5nZSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN1cnJpbmdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgcGFyc2VkID0gcmVjdXJyaW5nVHlwZXNbaV0ucGFyc2UocmVmaW5lZCwgZGF0ZUVudik7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIGxldCB7IGFsbERheSB9ID0gcmVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFsbERheSA9IGRlZmF1bHRBbGxEYXk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERheSA9IHBhcnNlZC5hbGxEYXlHdWVzcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsRGF5LFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZWQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHBhcnNlZC50eXBlRGF0YSxcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IGksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGZyYW1pbmdSYW5nZSwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIHBsdWdpbkhvb2tzLCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgcmVjdXJyaW5nIGluc3RhbmNlc1xuICAgIC8vIFRPRE86IGJhZC4gYWx3YXlzIGV4cGFuZCBldmVudHMgYXMgYSBzZWNvbmQgc3RlcFxuICAgIGluc3RhbmNlcyA9IGZpbHRlckhhc2goaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+ICFkZWZzW2luc3RhbmNlLmRlZklkXS5yZWN1cnJpbmdEZWYpO1xuICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbZGVmSWRdO1xuICAgICAgICBpZiAoZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgICAgICAgbGV0IHsgZHVyYXRpb24gfSA9IGRlZi5yZWN1cnJpbmdEZWY7XG4gICAgICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBkZWYuYWxsRGF5ID9cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydHMgPSBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZGVmLCBkdXJhdGlvbiwgZnJhbWluZ1JhbmdlLCBkYXRlRW52LCBwbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBzdGFydCBvZiBzdGFydHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbiksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG4vKlxuRXZlbnQgTVVTVCBoYXZlIGEgcmVjdXJyaW5nRGVmXG4qL1xuZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGV2ZW50RGVmLCBkdXJhdGlvbiwgZnJhbWluZ1JhbmdlLCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIGxldCB0eXBlRGVmID0gcmVjdXJyaW5nVHlwZXNbZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVJZF07XG4gICAgbGV0IG1hcmtlcnMgPSB0eXBlRGVmLmV4cGFuZChldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZURhdGEsIHtcbiAgICAgICAgc3RhcnQ6IGRhdGVFbnYuc3VidHJhY3QoZnJhbWluZ1JhbmdlLnN0YXJ0LCBkdXJhdGlvbiksXG4gICAgICAgIGVuZDogZnJhbWluZ1JhbmdlLmVuZCxcbiAgICB9LCBkYXRlRW52KTtcbiAgICAvLyB0aGUgcmVjdXJyZW5jZSBwbHVnaW5zIGRvbid0IGd1YXJhbnRlZSB0aGF0IGFsbC1kYXkgZXZlbnRzIGFyZSBzdGFydC1vZi1kYXksIHNvIHdlIGhhdmUgdG9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcChzdGFydE9mRGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlcnM7XG59XG5cbmNvbnN0IEVWRU5UX05PTl9EQVRFX1JFRklORVJTID0ge1xuICAgIGlkOiBTdHJpbmcsXG4gICAgZ3JvdXBJZDogU3RyaW5nLFxuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgaW50ZXJhY3RpdmU6IEJvb2xlYW4sXG59O1xuY29uc3QgRVZFTlRfREFURV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBkYXRlOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xuY29uc3QgRVZFTlRfUkVGSU5FUlMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpLCBFVkVOVF9EQVRFX1JFRklORVJTKSwgeyBleHRlbmRlZFByb3BzOiBpZGVudGl0eSB9KTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnQocmF3LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKTtcbiAgICBsZXQgZGVmYXVsdEFsbERheSA9IGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xuICAgIGxldCByZWN1cnJpbmdSZXMgPSBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LmRhdGVFbnYsIGNvbnRleHQucGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xuICAgIGlmIChyZWN1cnJpbmdSZXMpIHtcbiAgICAgICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgcmVjdXJyaW5nUmVzLmFsbERheSwgQm9vbGVhbihyZWN1cnJpbmdSZXMuZHVyYXRpb24pLCBjb250ZXh0LCBkZWZJZE1hcCk7XG4gICAgICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7XG4gICAgICAgICAgICB0eXBlSWQ6IHJlY3VycmluZ1Jlcy50eXBlSWQsXG4gICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxuICAgICAgICAgICAgZHVyYXRpb246IHJlY3VycmluZ1Jlcy5kdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZTogbnVsbCB9O1xuICAgIH1cbiAgICBsZXQgc2luZ2xlUmVzID0gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpO1xuICAgIGlmIChzaW5nbGVSZXMpIHtcbiAgICAgICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgc2luZ2xlUmVzLmFsbERheSwgc2luZ2xlUmVzLmhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgc2luZ2xlUmVzLnJhbmdlLCBzaW5nbGVSZXMuZm9yY2VkU3RhcnRUem8sIHNpbmdsZVJlcy5mb3JjZWRFbmRUem8pO1xuICAgICAgICBpZiAoaW5zdGFuY2VJZE1hcCAmJiBkZWYucHVibGljSWQgJiYgaW5zdGFuY2VJZE1hcFtkZWYucHVibGljSWRdKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZE1hcFtkZWYucHVibGljSWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpKSB7XG4gICAgcmV0dXJuIHJlZmluZVByb3BzKHJhdywgcmVmaW5lcnMpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfUkVGSU5FUlMpLCBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50UmVmaW5lcnMpO1xufVxuLypcbldpbGwgTk9UIHBvcHVsYXRlIGV4dGVuZGVkUHJvcHMgd2l0aCB0aGUgbGVmdG92ZXIgcHJvcGVydGllcy5cbldpbGwgTk9UIHBvcHVsYXRlIGRhdGUtcmVsYXRlZCBwcm9wcy5cbiovXG5mdW5jdGlvbiBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBzb3VyY2VJZCwgYWxsRGF5LCBoYXNFbmQsIGNvbnRleHQsIGRlZklkTWFwKSB7XG4gICAgbGV0IGRlZiA9IHtcbiAgICAgICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXG4gICAgICAgIGdyb3VwSWQ6IHJlZmluZWQuZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXG4gICAgICAgIHJlY3VycmluZ0RlZjogbnVsbCxcbiAgICAgICAgZGVmSWQ6ICgoZGVmSWRNYXAgJiYgcmVmaW5lZC5pZCkgPyBkZWZJZE1hcFtyZWZpbmVkLmlkXSA6ICcnKSB8fCBndWlkKCksXG4gICAgICAgIHNvdXJjZUlkLFxuICAgICAgICBhbGxEYXksXG4gICAgICAgIGhhc0VuZCxcbiAgICAgICAgaW50ZXJhY3RpdmU6IHJlZmluZWQuaW50ZXJhY3RpdmUsXG4gICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxuICAgICAgICBleHRlbmRlZFByb3BzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChyZWZpbmVkLmV4dGVuZGVkUHJvcHMgfHwge30pKSwgZXh0cmEpLFxuICAgIH07XG4gICAgZm9yIChsZXQgbWVtYmVyQWRkZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk1lbWJlckFkZGVycykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGRlZiwgbWVtYmVyQWRkZXIocmVmaW5lZCkpO1xuICAgIH1cbiAgICAvLyBoZWxwIG91dCBFdmVudEltcGwgZnJvbSBoYXZpbmcgdXNlciBtb2RpZnkgcHJvcHNcbiAgICBPYmplY3QuZnJlZXplKGRlZi51aS5jbGFzc05hbWVzKTtcbiAgICBPYmplY3QuZnJlZXplKGRlZi5leHRlbmRlZFByb3BzKTtcbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICBsZXQgeyBhbGxEYXkgfSA9IHJlZmluZWQ7XG4gICAgbGV0IHN0YXJ0TWV0YTtcbiAgICBsZXQgc3RhcnRNYXJrZXIgPSBudWxsO1xuICAgIGxldCBoYXNFbmQgPSBmYWxzZTtcbiAgICBsZXQgZW5kTWV0YTtcbiAgICBsZXQgZW5kTWFya2VyID0gbnVsbDtcbiAgICBsZXQgc3RhcnRJbnB1dCA9IHJlZmluZWQuc3RhcnQgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnQgOiByZWZpbmVkLmRhdGU7XG4gICAgc3RhcnRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dCk7XG4gICAgaWYgKHN0YXJ0TWV0YSkge1xuICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0TWV0YS5tYXJrZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlZmluZWQuZW5kICE9IG51bGwpIHtcbiAgICAgICAgZW5kTWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHJlZmluZWQuZW5kKTtcbiAgICB9XG4gICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChkZWZhdWx0QWxsRGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFsbERheSA9IGRlZmF1bHRBbGxEYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRhdGUgcHJvcHMgTEFTVFxuICAgICAgICAgICAgYWxsRGF5ID0gKCFzdGFydE1ldGEgfHwgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWxsRGF5ICYmIHN0YXJ0TWFya2VyKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRPZkRheShzdGFydE1hcmtlcik7XG4gICAgfVxuICAgIGlmIChlbmRNZXRhKSB7XG4gICAgICAgIGVuZE1hcmtlciA9IGVuZE1ldGEubWFya2VyO1xuICAgICAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBzdGFydE9mRGF5KGVuZE1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlciA8PSBzdGFydE1hcmtlcikge1xuICAgICAgICAgICAgZW5kTWFya2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kTWFya2VyKSB7XG4gICAgICAgIGhhc0VuZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xuICAgICAgICBoYXNFbmQgPSBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uIHx8IGZhbHNlO1xuICAgICAgICBlbmRNYXJrZXIgPSBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0TWFya2VyLCBhbGxEYXkgP1xuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsRGF5LFxuICAgICAgICBoYXNFbmQsXG4gICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBzdGFydE1hcmtlciwgZW5kOiBlbmRNYXJrZXIgfSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEgPyBlbmRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcbiAgICBsZXQgcmVzID0gbnVsbDtcbiAgICBpZiAoZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgcmVzID0gZXZlbnRTb3VyY2UuZGVmYXVsdEFsbERheTtcbiAgICB9XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlcyA9IGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUV2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApIHtcbiAgICBsZXQgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgIGxldCBldmVudFJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpO1xuICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgICAgICBsZXQgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGV2ZW50UmVmaW5lcnMsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpKSB7XG4gICAgZXZlbnRTdG9yZS5kZWZzW3R1cGxlLmRlZi5kZWZJZF0gPSB0dXBsZS5kZWY7XG4gICAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XG4gICAgICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBldmVudFN0b3JlO1xufVxuLy8gcmV0cmlldmVzIGV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgZ3JvdXBJZCBhcyB0aGUgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGBpbnN0YW5jZUlkYFxuLy8gb3IgdGhleSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluc3RhbmNlLlxuLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xuZnVuY3Rpb24gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2VJZCkge1xuICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gZ2V0IGV2ZW50cy9pbnN0YW5jZXMgd2l0aCBzYW1lIGdyb3VwXG4gICAgICAgIGxldCBuZXdTdG9yZSA9IGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChsb29rRGVmKSA9PiBpc0V2ZW50RGVmc0dyb3VwZWQoZGVmLCBsb29rRGVmKSk7XG4gICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcbiAgICAgICAgbmV3U3RvcmUuZGVmc1tkZWYuZGVmSWRdID0gZGVmO1xuICAgICAgICBuZXdTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuIG5ld1N0b3JlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG59XG5mdW5jdGlvbiBpc0V2ZW50RGVmc0dyb3VwZWQoZGVmMCwgZGVmMSkge1xuICAgIHJldHVybiBCb29sZWFuKGRlZjAuZ3JvdXBJZCAmJiBkZWYwLmdyb3VwSWQgPT09IGRlZjEuZ3JvdXBJZCk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSB7XG4gICAgcmV0dXJuIHsgZGVmczoge30sIGluc3RhbmNlczoge30gfTtcbn1cbmZ1bmN0aW9uIG1lcmdlRXZlbnRTdG9yZXMoc3RvcmUwLCBzdG9yZTEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0b3JlMC5kZWZzKSwgc3RvcmUxLmRlZnMpLFxuICAgICAgICBpbnN0YW5jZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmluc3RhbmNlcyksIHN0b3JlMS5pbnN0YW5jZXMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmaWx0ZXJGdW5jKSB7XG4gICAgbGV0IGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYyk7XG4gICAgbGV0IGluc3RhbmNlcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gKGRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIHN0aWxsIGV4aXN0cz9cbiAgICApKTtcbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVTdWJFdmVudFN0b3JlKG1hc3Rlciwgc3ViKSB7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBtYXN0ZXI7XG4gICAgbGV0IGZpbHRlcmVkRGVmcyA9IHt9O1xuICAgIGxldCBmaWx0ZXJlZEluc3RhbmNlcyA9IHt9O1xuICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZpbHRlcmVkSW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJlZEluc3RhbmNlcyxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb25zdHJhaW50KGlucHV0LCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhpbnB1dCwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhbaW5wdXRdLCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NOYW1lcyhyYXcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmF3LnNwbGl0KC9cXHMrLyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxuLy8gVE9ETzogYmV0dGVyIGNhbGxlZCBcIkV2ZW50U2V0dGluZ3NcIiBvciBcIkV2ZW50Q29uZmlnXCJcbi8vIFRPRE86IG1vdmUgdGhpcyBmaWxlIGludG8gc3RydWN0c1xuLy8gVE9ETzogc2VwYXJhdGUgY29uc3RyYWludC9vdmVybGFwL2FsbG93LCBiZWNhdXNlIHNlbGVjdGlvbiB1c2VzIG9ubHkgdGhhdCwgbm90IG90aGVyIHByb3BzXG5jb25zdCBFVkVOVF9VSV9SRUZJTkVSUyA9IHtcbiAgICBkaXNwbGF5OiBTdHJpbmcsXG4gICAgZWRpdGFibGU6IEJvb2xlYW4sXG4gICAgc3RhcnRFZGl0YWJsZTogQm9vbGVhbixcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGNvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIG92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGFsbG93OiBpZGVudGl0eSxcbiAgICBjbGFzc05hbWU6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjbGFzc05hbWVzOiBwYXJzZUNsYXNzTmFtZXMsXG4gICAgY29sb3I6IFN0cmluZyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBib3JkZXJDb2xvcjogU3RyaW5nLFxuICAgIHRleHRDb2xvcjogU3RyaW5nLFxufTtcbmNvbnN0IEVNUFRZX0VWRU5UX1VJID0ge1xuICAgIGRpc3BsYXk6IG51bGwsXG4gICAgc3RhcnRFZGl0YWJsZTogbnVsbCxcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiBudWxsLFxuICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICBvdmVybGFwOiBudWxsLFxuICAgIGFsbG93czogW10sXG4gICAgYmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICBib3JkZXJDb2xvcjogJycsXG4gICAgdGV4dENvbG9yOiAnJyxcbiAgICBjbGFzc05hbWVzOiBbXSxcbn07XG5mdW5jdGlvbiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpIHtcbiAgICBsZXQgY29uc3RyYWludCA9IG5vcm1hbGl6ZUNvbnN0cmFpbnQocmVmaW5lZC5jb25zdHJhaW50LCBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5OiByZWZpbmVkLmRpc3BsYXkgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogcmVmaW5lZC5zdGFydEVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0RWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50ICE9IG51bGwgPyBbY29uc3RyYWludF0gOiBbXSxcbiAgICAgICAgb3ZlcmxhcDogcmVmaW5lZC5vdmVybGFwICE9IG51bGwgPyByZWZpbmVkLm92ZXJsYXAgOiBudWxsLFxuICAgICAgICBhbGxvd3M6IHJlZmluZWQuYWxsb3cgIT0gbnVsbCA/IFtyZWZpbmVkLmFsbG93XSA6IFtdLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZmluZWQuYmFja2dyb3VuZENvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgICAgIGJvcmRlckNvbG9yOiByZWZpbmVkLmJvcmRlckNvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgICAgIHRleHRDb2xvcjogcmVmaW5lZC50ZXh0Q29sb3IgfHwgJycsXG4gICAgICAgIGNsYXNzTmFtZXM6IChyZWZpbmVkLmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KHJlZmluZWQuY2xhc3NOYW1lcyB8fCBbXSksIC8vIGpvaW4gc2luZ3VsYXIgYW5kIHBsdXJhbFxuICAgIH07XG59XG4vLyBUT0RPOiBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxuZnVuY3Rpb24gY29tYmluZUV2ZW50VWlzKHVpcykge1xuICAgIHJldHVybiB1aXMucmVkdWNlKGNvbWJpbmVUd29FdmVudFVpcywgRU1QVFlfRVZFTlRfVUkpO1xufVxuZnVuY3Rpb24gY29tYmluZVR3b0V2ZW50VWlzKGl0ZW0wLCBpdGVtMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IGl0ZW0xLmRpc3BsYXkgIT0gbnVsbCA/IGl0ZW0xLmRpc3BsYXkgOiBpdGVtMC5kaXNwbGF5LFxuICAgICAgICBzdGFydEVkaXRhYmxlOiBpdGVtMS5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5zdGFydEVkaXRhYmxlIDogaXRlbTAuc3RhcnRFZGl0YWJsZSxcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBpdGVtMC5jb25zdHJhaW50cy5jb25jYXQoaXRlbTEuY29uc3RyYWludHMpLFxuICAgICAgICBvdmVybGFwOiB0eXBlb2YgaXRlbTEub3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbTEub3ZlcmxhcCA6IGl0ZW0wLm92ZXJsYXAsXG4gICAgICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGl0ZW0xLmJhY2tncm91bmRDb2xvciB8fCBpdGVtMC5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGJvcmRlckNvbG9yOiBpdGVtMS5ib3JkZXJDb2xvciB8fCBpdGVtMC5ib3JkZXJDb2xvcixcbiAgICAgICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxuICAgICAgICBjbGFzc05hbWVzOiBpdGVtMC5jbGFzc05hbWVzLmNvbmNhdChpdGVtMS5jbGFzc05hbWVzKSxcbiAgICB9O1xufVxuXG5jb25zdCBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxuICAgIHVybDogU3RyaW5nLFxuICAgIGZvcm1hdDogU3RyaW5nLFxuICAgIGV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSxcbiAgICAvLyBmb3IgYW55IG5ldHdvcmstcmVsYXRlZCBzb3VyY2VzXG4gICAgc3VjY2VzczogaWRlbnRpdHksXG4gICAgZmFpbHVyZTogaWRlbnRpdHksXG59O1xuZnVuY3Rpb24gcGFyc2VFdmVudFNvdXJjZShyYXcsIGNvbnRleHQsIHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpKSB7XG4gICAgbGV0IHJhd09iajtcbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmF3T2JqID0geyB1cmw6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByYXdPYmogPSB7IGV2ZW50czogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdvYmplY3QnICYmIHJhdykgeyAvLyBub3QgbnVsbFxuICAgICAgICByYXdPYmogPSByYXc7XG4gICAgfVxuICAgIGlmIChyYXdPYmopIHtcbiAgICAgICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhd09iaiwgcmVmaW5lcnMpO1xuICAgICAgICBsZXQgbWV0YVJlcyA9IGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICBpZiAobWV0YVJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfcmF3OiByYXcsXG4gICAgICAgICAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGF0ZXN0RmV0Y2hJZDogJycsXG4gICAgICAgICAgICAgICAgZmV0Y2hSYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWxsRGF5OiByZWZpbmVkLmRlZmF1bHRBbGxEYXksXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiByZWZpbmVkLmV2ZW50RGF0YVRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZWZpbmVkLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogcmVmaW5lZC5mYWlsdXJlLFxuICAgICAgICAgICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBndWlkKCksXG4gICAgICAgICAgICAgICAgc291cmNlRGVmSWQ6IG1ldGFSZXMuc291cmNlRGVmSWQsXG4gICAgICAgICAgICAgICAgbWV0YTogbWV0YVJlcy5tZXRhLFxuICAgICAgICAgICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkUHJvcHM6IGV4dHJhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1NPVVJDRV9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VSZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlTWV0YShyYXcsIGNvbnRleHQpIHtcbiAgICBsZXQgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzO1xuICAgIGZvciAobGV0IGkgPSBkZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7IC8vIGxhdGVyLWFkZGVkIHBsdWdpbnMgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAgIGxldCBkZWYgPSBkZWZzW2ldO1xuICAgICAgICBsZXQgbWV0YSA9IGRlZi5wYXJzZU1ldGEocmF3KTtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNvdXJjZURlZklkOiBpLCBtZXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6IC8vIHJhd1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSwgYWN0aW9uLnJhd0V2ZW50cywgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX1JBV19FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIHJlc2V0UmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24ucmF3RXZlbnRzLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ0FERF9FVkVOVFMnOiAvLyBhbHJlYWR5IHBhcnNlZCwgYnV0IG5vdCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIGFkZEV2ZW50KGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlLCAvLyBuZXcgb25lc1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGwsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRVNFVF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudFN0b3JlO1xuICAgICAgICBjYXNlICdNRVJHRV9FVkVOVFMnOiAvLyBhbHJlYWR5IHBhcnNlZCBhbmQgZXhwYW5kZWRcbiAgICAgICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlKTtcbiAgICAgICAgY2FzZSAnUFJFVic6IC8vIFRPRE86IGhvdyBkbyB3ZSB0cmFjayBhbGwgYWN0aW9ucyB0aGF0IGFmZmVjdCBkYXRlUHJvZmlsZSA6KFxuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVTdWJFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgYWN0aW9uLnNvdXJjZUlkKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWYpID0+ICghZXZlbnREZWYuc291cmNlSWQgLy8gb25seSBrZWVwIGV2ZW50cyB3aXRoIG5vIHNvdXJjZSBpZFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlY2VpdmVSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2UsIGZldGNoSWQsIGZldGNoUmFuZ2UsIHJhd0V2ZW50cywgY29udGV4dCkge1xuICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQgLy8gVE9ETzogd2lzaCB0aGlzIGxvZ2ljIHdhcyBhbHdheXMgaW4gZXZlbnQtc291cmNlc1xuICAgICkge1xuICAgICAgICBsZXQgc3Vic2V0ID0gcGFyc2VFdmVudHModHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQpLCBldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgICAgIGlmIChmZXRjaFJhbmdlKSB7XG4gICAgICAgICAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBmZXRjaFJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBldmVudFNvdXJjZS5zb3VyY2VJZCksIHN1YnNldCk7XG4gICAgfVxuICAgIHJldHVybiBldmVudFN0b3JlO1xufVxuZnVuY3Rpb24gcmVzZXRSYXdFdmVudHMoZXhpc3RpbmdFdmVudFN0b3JlLCBldmVudFNvdXJjZSwgcmF3RXZlbnRzLCBhY3RpdmVSYW5nZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXAgfSA9IGJ1aWxkUHVibGljSWRNYXBzKGV4aXN0aW5nRXZlbnRTdG9yZSk7XG4gICAgbGV0IG5ld0V2ZW50U3RvcmUgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0LCBmYWxzZSwgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApO1xuICAgIHJldHVybiBleHBhbmRSZWN1cnJpbmcobmV3RXZlbnRTdG9yZSwgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcbiAgICBsZXQgY2FsRWFjaFRyYW5zZm9ybSA9IGNvbnRleHQub3B0aW9ucy5ldmVudERhdGFUcmFuc2Zvcm07XG4gICAgbGV0IHNvdXJjZUVhY2hUcmFuc2Zvcm0gPSBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLmV2ZW50RGF0YVRyYW5zZm9ybSA6IG51bGw7XG4gICAgaWYgKHNvdXJjZUVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgc291cmNlRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGlmIChjYWxFYWNoVHJhbnNmb3JtKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGNhbEVhY2hUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmF3RXZlbnRzO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgZnVuYykge1xuICAgIGxldCByZWZpbmVkRXZlbnRzO1xuICAgIGlmICghZnVuYykge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gcmF3RXZlbnRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByYXdFdmVudCBvZiByYXdFdmVudHMpIHtcbiAgICAgICAgICAgIGxldCByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmVmaW5lZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZWRFdmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmaW5lZEV2ZW50cztcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KGV2ZW50U3RvcmUsIHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBpZiAoZXhwYW5kUmFuZ2UpIHtcbiAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBzdWJzZXQpO1xufVxuZnVuY3Rpb24gcmV6b25lRXZlbnRTdG9yZURhdGVzKGV2ZW50U3RvcmUsIG9sZERhdGVFbnYsIG5ld0RhdGVFbnYpIHtcbiAgICBsZXQgeyBkZWZzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCBpbnN0YW5jZXMgPSBtYXBIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBpZiAoZGVmLmFsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlOyAvLyBpc24ndCBkZXBlbmRlbnQgb24gdGltZXpvbmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZSksIHsgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvKSksXG4gICAgICAgICAgICAgICAgZW5kOiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5lbmQsIGluc3RhbmNlLmZvcmNlZEVuZFR6bykpLFxuICAgICAgICAgICAgfSwgZm9yY2VkU3RhcnRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkRW5kVHpvIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgc291cmNlSWQpIHtcbiAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiBldmVudERlZi5zb3VyY2VJZCAhPT0gc291cmNlSWQpO1xufVxuLy8gUVVFU1RJT046IHdoeSBub3QganVzdCByZXR1cm4gaW5zdGFuY2VzPyBkbyBhIGdlbmVyYWwgb2JqZWN0LXByb3BlcnR5LWV4Y2x1c2lvbiB1dGlsXG5mdW5jdGlvbiBleGNsdWRlSW5zdGFuY2VzKGV2ZW50U3RvcmUsIHJlbW92YWxzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogZXZlbnRTdG9yZS5kZWZzLFxuICAgICAgICBpbnN0YW5jZXM6IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIXJlbW92YWxzW2luc3RhbmNlLmluc3RhbmNlSWRdKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQdWJsaWNJZE1hcHMoZXZlbnRTdG9yZSkge1xuICAgIGNvbnN0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGNvbnN0IGRlZklkTWFwID0ge307XG4gICAgY29uc3QgaW5zdGFuY2VJZE1hcCA9IHt9O1xuICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGNvbnN0IHsgcHVibGljSWQgfSA9IGRlZjtcbiAgICAgICAgaWYgKHB1YmxpY0lkKSB7XG4gICAgICAgICAgICBkZWZJZE1hcFtwdWJsaWNJZF0gPSBkZWZJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGNvbnN0IHsgcHVibGljSWQgfSA9IGRlZjtcbiAgICAgICAgaWYgKHB1YmxpY0lkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZUlkTWFwW3B1YmxpY0lkXSA9IGluc3RhbmNlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXAgfTtcbn1cblxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICAgIHNldFRoaXNDb250ZXh0KHRoaXNDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSB0aGlzQ29udGV4dDtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgYWRkVG9IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgdHJpZ2dlcih0eXBlLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBhdHRhY2hlZEhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1t0eXBlXSB8fCBbXTtcbiAgICAgICAgbGV0IG9wdGlvbkhhbmRsZXIgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdO1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSBbXS5jb25jYXQob3B0aW9uSGFuZGxlciB8fCBbXSwgYXR0YWNoZWRIYW5kbGVycyk7XG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcy50aGlzQ29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzSGFuZGxlcnModHlwZSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbigodGhpcy5oYW5kbGVyc1t0eXBlXSAmJiB0aGlzLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkVG9IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAoaGFzaFt0eXBlXSB8fCAoaGFzaFt0eXBlXSA9IFtdKSlcbiAgICAgICAgLnB1c2goaGFuZGxlcik7XG59XG5mdW5jdGlvbiByZW1vdmVGcm9tSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhc2hbdHlwZV0pIHtcbiAgICAgICAgICAgIGhhc2hbdHlwZV0gPSBoYXNoW3R5cGVdLmZpbHRlcigoZnVuYykgPT4gZnVuYyAhPT0gaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW3R5cGVdOyAvLyByZW1vdmUgYWxsIGhhbmRsZXIgZnVuY3MgZm9yIHRoaXMgdHlwZVxuICAgIH1cbn1cblxuY29uc3QgREVGX0RFRkFVTFRTID0ge1xuICAgIHN0YXJ0VGltZTogJzA5OjAwJyxcbiAgICBlbmRUaW1lOiAnMTc6MDAnLFxuICAgIGRheXNPZldlZWs6IFsxLCAyLCAzLCA0LCA1XSxcbiAgICBkaXNwbGF5OiAnaW52ZXJzZS1iYWNrZ3JvdW5kJyxcbiAgICBjbGFzc05hbWVzOiAnZmMtbm9uLWJ1c2luZXNzJyxcbiAgICBncm91cElkOiAnX2J1c2luZXNzSG91cnMnLCAvLyBzbyBtdWx0aXBsZSBkZWZzIGdldCBncm91cGVkXG59O1xuLypcblRPRE86IHBhc3MgYXJvdW5kIGFzIEV2ZW50RGVmSGFzaCEhIVxuKi9cbmZ1bmN0aW9uIHBhcnNlQnVzaW5lc3NIb3VycyhpbnB1dCwgY29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUV2ZW50cyhyZWZpbmVJbnB1dHMoaW5wdXQpLCBudWxsLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZmluZUlucHV0cyhpbnB1dCkge1xuICAgIGxldCByYXdEZWZzO1xuICAgIGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuICAgICAgICByYXdEZWZzID0gW3t9XTsgLy8gd2lsbCBnZXQgREVGX0RFRkFVTFRTIHZlcmJhdGltXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIC8vIGlmIHNwZWNpZnlpbmcgYW4gYXJyYXksIGV2ZXJ5IHN1Yi1kZWZpbml0aW9uIE5FRURTIGEgZGF5LW9mLXdlZWtcbiAgICAgICAgcmF3RGVmcyA9IGlucHV0LmZpbHRlcigocmF3RGVmKSA9PiByYXdEZWYuZGF5c09mV2Vlayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJhd0RlZnMgPSBbaW5wdXRdO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gaXMgcHJvYmFibHkgZmFsc2VcbiAgICAgICAgcmF3RGVmcyA9IFtdO1xuICAgIH1cbiAgICByYXdEZWZzID0gcmF3RGVmcy5tYXAoKHJhd0RlZikgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGX0RFRkFVTFRTKSwgcmF3RGVmKSkpO1xuICAgIHJldHVybiByYXdEZWZzO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24sIHBldiwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdzZWxlY3QnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzZWxlY3Rpb24sIGNvbnRleHQpKSwgeyBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KSk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCd1bnNlbGVjdCcsIHtcbiAgICAgICAganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZGF0ZVNwYW4sIGNvbnRleHQpIHtcbiAgICBsZXQgcHJvcHMgPSB7fTtcbiAgICBmb3IgKGxldCB0cmFuc2Zvcm0gb2YgY29udGV4dC5wbHVnaW5Ib29rcy5kYXRlU3BhblRyYW5zZm9ybXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVNwYW5BcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbi8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cbi8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXG5mdW5jdGlvbiBnZXREZWZhdWx0RXZlbnRFbmQoYWxsRGF5LCBtYXJrZXIsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCBlbmQgPSBtYXJrZXI7XG4gICAgaWYgKGFsbERheSkge1xuICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIGFwcGxpZXMgdGhlIG11dGF0aW9uIHRvIEFMTCBkZWZzL2luc3RhbmNlcyB3aXRoaW4gdGhlIGV2ZW50IHN0b3JlXG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50Q29uZmlnQmFzZSwgbXV0YXRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgZXZlbnRDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRDb25maWdCYXNlKTtcbiAgICBsZXQgZGVzdCA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2RlZklkXTtcbiAgICAgICAgZGVzdC5kZWZzW2RlZklkXSA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmKGRlZiwgZXZlbnRDb25maWdzW2RlZklkXSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBsZXQgZGVmID0gZGVzdC5kZWZzW2luc3RhbmNlLmRlZklkXTsgLy8gaW1wb3J0YW50IHRvIGdyYWIgdGhlIG5ld2x5IG1vZGlmaWVkIGRlZlxuICAgICAgICBkZXN0Lmluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UoaW5zdGFuY2UsIGRlZiwgZXZlbnRDb25maWdzW2luc3RhbmNlLmRlZklkXSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmKGV2ZW50RGVmLCBldmVudENvbmZpZywgbXV0YXRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgfHwge307XG4gICAgLy8gaWYgaGFzRW5kIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQsIGd1ZXNzIGEgZ29vZCB2YWx1ZSBiYXNlZCBvbiBkZWx0YXMuXG4gICAgLy8gaWYgZHVyYXRpb24gd2lsbCBjaGFuZ2UsIHRoZXJlJ3Mgbm8gd2F5IHRoZSBkZWZhdWx0IGR1cmF0aW9uIHdpbGwgcGVyc2lzdCxcbiAgICAvLyBhbmQgdGh1cywgd2UgbmVlZCB0byBtYXJrIHRoZSBldmVudCBhcyBoYXZpbmcgYSByZWFsIGVuZFxuICAgIGlmIChzdGFuZGFyZFByb3BzLmhhc0VuZCA9PSBudWxsICYmXG4gICAgICAgIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUgJiZcbiAgICAgICAgKG11dGF0aW9uLnN0YXJ0RGVsdGEgfHwgbXV0YXRpb24uZW5kRGVsdGEpKSB7XG4gICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gdHJ1ZTsgLy8gVE9ETzogaXMgdGhpcyBtdXRhdGlvbiBva2F5P1xuICAgIH1cbiAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudERlZiksIHN0YW5kYXJkUHJvcHMpLCB7IHVpOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmLnVpKSwgc3RhbmRhcmRQcm9wcy51aSkgfSk7XG4gICAgaWYgKG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgY29weS5leHRlbmRlZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb3B5LmV4dGVuZGVkUHJvcHMpLCBtdXRhdGlvbi5leHRlbmRlZFByb3BzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgYXBwbGllciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycykge1xuICAgICAgICBhcHBsaWVyKGNvcHksIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKCFjb3B5Lmhhc0VuZCAmJiBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uKSB7XG4gICAgICAgIGNvcHkuaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UsIGV2ZW50RGVmLCAvLyBtdXN0IGZpcnN0IGJlIG1vZGlmaWVkIGJ5IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmXG5ldmVudENvbmZpZywgbXV0YXRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSBjb250ZXh0O1xuICAgIGxldCBmb3JjZUFsbERheSA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5hbGxEYXkgPT09IHRydWU7XG4gICAgbGV0IGNsZWFyRW5kID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmhhc0VuZCA9PT0gZmFsc2U7XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudEluc3RhbmNlKTtcbiAgICBpZiAoZm9yY2VBbGxEYXkpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoY29weS5yYW5nZSk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5kYXRlc0RlbHRhICYmIGV2ZW50Q29uZmlnLnN0YXJ0RWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uc3RhcnREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uc3RhcnREZWx0YSksXG4gICAgICAgICAgICBlbmQ6IGNvcHkucmFuZ2UuZW5kLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uZW5kRGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5lbmREZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjbGVhckVuZCkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBpbiBjYXNlIGV2ZW50IHdhcyBhbGwtZGF5IGJ1dCB0aGUgc3VwcGxpZWQgZGVsdGFzIHdlcmUgbm90XG4gICAgLy8gYmV0dGVyIHV0aWwgZm9yIHRoaXM/XG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5zdGFydCksXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5lbmQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBoYW5kbGUgaW52YWxpZCBkdXJhdGlvbnNcbiAgICBpZiAoY29weS5yYW5nZS5lbmQgPCBjb3B5LnJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIGNvcHkucmFuZ2UuZW5kID0gZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuXG5jbGFzcyBFdmVudFNvdXJjZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmV0Y2goKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdLFxuICAgICAgICAgICAgaXNSZWZldGNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnB1YmxpY0lkO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEudXJsO1xuICAgIH1cbiAgICBnZXQgZm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0OyAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXG4gICAgfVxufVxuXG5jbGFzcyBFdmVudEltcGwge1xuICAgIC8vIGluc3RhbmNlIHdpbGwgYmUgbnVsbCBpZiBleHByZXNzaW5nIGEgcmVjdXJyaW5nIGV2ZW50IHRoYXQgaGFzIG5vIGN1cnJlbnQgaW5zdGFuY2VzLFxuICAgIC8vIE9SIGlmIHRyeWluZyB0byB2YWxpZGF0ZSBhbiBpbmNvbWluZyBleHRlcm5hbCBldmVudCB0aGF0IGhhcyBubyBkYXRlcyBhc3NpZ25lZFxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZSB8fCBudWxsO1xuICAgIH1cbiAgICAvKlxuICAgIFRPRE86IG1ha2UgZXZlbnQgc3RydWN0IG1vcmUgcmVzcG9uc2libGUgZm9yIHRoaXNcbiAgICAqL1xuICAgIHNldFByb3AobmFtZSwgdmFsKSB7XG4gICAgICAgIGlmIChuYW1lIGluIEVWRU5UX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHNldCBkYXRlLXJlbGF0ZWQgcHJvcCBcXCduYW1lXFwnLiBVc2Ugb25lIG9mIHRoZSBkYXRlLXJlbGF0ZWQgbWV0aG9kcyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBwcm9wZXIgYWxpYXNpbmcgc3lzdGVtP1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBwdWJsaWNJZDogdmFsIH0sIC8vIGhhcmRjb2RlZCBpbnRlcm5hbCBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSB7XG4gICAgICAgICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgW25hbWVdOiB2YWwgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfVUlfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIGxldCB1aSA9IEVWRU5UX1VJX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgICAgIHVpID0geyBiYWNrZ3JvdW5kQ29sb3I6IHZhbCwgYm9yZGVyQ29sb3I6IHZhbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2VkaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIHVpID0geyBzdGFydEVkaXRhYmxlOiB2YWwsIGR1cmF0aW9uRWRpdGFibGU6IHZhbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IFtuYW1lXTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyB1aSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBzZXQgcHJvcCAnJHtuYW1lfScuIFVzZSBzZXRFeHRlbmRlZFByb3AgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFeHRlbmRlZFByb3AobmFtZSwgdmFsKSB7XG4gICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgIGV4dGVuZGVkUHJvcHM6IHsgW25hbWVdOiB2YWwgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldFN0YXJ0KHN0YXJ0SW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHRoaXMuX2luc3RhbmNlKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIGxldCBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTsgLy8gd2hhdCBpZiBwYXJzZWQgYmFkIT9cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1haW50YWluRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RW5kKGVuZElucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKGVuZElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kRGVsdGEgPSBkaWZmRGF0ZXModGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHM6IHsgaGFzRW5kOiBmYWxzZSB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldERhdGVzKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheTogb3B0aW9ucy5hbGxEYXkgfTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dCk7XG4gICAgICAgIGxldCBlbmQ7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2U7XG4gICAgICAgICAgICAvLyB3aGVuIGNvbXB1dGluZyB0aGUgZGlmZiBmb3IgYW4gZXZlbnQgYmVpbmcgY29udmVydGVkIHRvIGFsbC1kYXksXG4gICAgICAgICAgICAvLyBjb21wdXRlIGRpZmYgb2ZmIG9mIHRoZSBhbGwtZGF5IHZhbHVlcyB0aGUgd2F5IGV2ZW50LW11dGF0aW9uIGRvZXMuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxEYXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShpbnN0YW5jZVJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kRGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uc0VxdWFsKHN0YXJ0RGVsdGEsIGVuZERlbHRhKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGEsIGVuZERlbHRhLCBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBtZWFucyBcImNsZWFyIHRoZSBlbmRcIlxuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVTdGFydChkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVFbmQoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZURhdGVzKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0QWxsRGF5KGFsbERheSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBzdGFuZGFyZFByb3BzID0geyBhbGxEYXkgfTtcbiAgICAgICAgbGV0IHsgbWFpbnRhaW5EdXJhdGlvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG1haW50YWluRHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWFpbnRhaW5EdXJhdGlvbiA9IHRoaXMuX2NvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuYWxsRGF5ICE9PSBhbGxEYXkpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gbWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKGZvcm1hdElucHV0KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBsZXQgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdElucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5yYW5nZS5lbmQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChpbnN0YW5jZS5yYW5nZS5zdGFydCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXV0YXRlKG11dGF0aW9uKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgICAgICBsZXQgeyBldmVudFN0b3JlIH0gPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZS5pbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIGxldCBldmVudENvbmZpZ0Jhc2UgPSB7XG4gICAgICAgICAgICAgICAgJyc6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJycsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgb2xkRXZlbnQgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpOyAvLyBzbmFwc2hvdFxuICAgICAgICAgICAgdGhpcy5fZGVmID0gcmVsZXZhbnRFdmVudHMuZGVmc1tkZWYuZGVmSWRdO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSByZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF07XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywge1xuICAgICAgICAgICAgICAgIG9sZEV2ZW50LFxuICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRVNFVF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZSwgLy8gdGhlIE9SSUdJTkFMIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IGFzU3RvcmUgPSBldmVudEFwaVRvU3RvcmUodGhpcyk7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlbW92ZScsIHtcbiAgICAgICAgICAgIGV2ZW50OiB0aGlzLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzb3VyY2UoKSB7XG4gICAgICAgIGxldCB7IHNvdXJjZUlkIH0gPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChzb3VyY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwodGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlc1tzb3VyY2VJZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSA/XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmRhdGVFbnYudG9EYXRlKHRoaXMuX2luc3RhbmNlLnJhbmdlLnN0YXJ0KSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpID9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTdHIoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgb21pdFRpbWU6IHRoaXMuX2RlZi5hbGxEYXksXG4gICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0IGVuZFN0cigpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5lbmQsIHtcbiAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLy8gY29tcHV0YWJsZSBwcm9wcyB0aGF0IGFsbCBhY2Nlc3MgdGhlIGRlZlxuICAgIC8vIFRPRE86IGZpbmQgYSBUeXBlU2NyaXB0LWNvbXBhdGlibGUgd2F5IHRvIGRvIHRoaXMgYXQgc2NhbGVcbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLl9kZWYucHVibGljSWQ7IH1cbiAgICBnZXQgZ3JvdXBJZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5ncm91cElkOyB9XG4gICAgZ2V0IGFsbERheSgpIHsgcmV0dXJuIHRoaXMuX2RlZi5hbGxEYXk7IH1cbiAgICBnZXQgdGl0bGUoKSB7IHJldHVybiB0aGlzLl9kZWYudGl0bGU7IH1cbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVybDsgfVxuICAgIGdldCBkaXNwbGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmRpc3BsYXkgfHwgJ2F1dG8nOyB9IC8vIGJhZC4ganVzdCBub3JtYWxpemUgdGhlIHR5cGUgZWFybGllclxuICAgIGdldCBzdGFydEVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnN0YXJ0RWRpdGFibGU7IH1cbiAgICBnZXQgZHVyYXRpb25FZGl0YWJsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5kdXJhdGlvbkVkaXRhYmxlOyB9XG4gICAgZ2V0IGNvbnN0cmFpbnQoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuY29uc3RyYWludHNbMF0gfHwgbnVsbDsgfVxuICAgIGdldCBvdmVybGFwKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLm92ZXJsYXA7IH1cbiAgICBnZXQgYWxsb3coKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYWxsb3dzWzBdIHx8IG51bGw7IH1cbiAgICBnZXQgYmFja2dyb3VuZENvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJhY2tncm91bmRDb2xvcjsgfVxuICAgIGdldCBib3JkZXJDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5ib3JkZXJDb2xvcjsgfVxuICAgIGdldCB0ZXh0Q29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkudGV4dENvbG9yOyB9XG4gICAgLy8gTk9URTogdXNlciBjYW4ndCBtb2RpZnkgdGhlc2UgYmVjYXVzZSBPYmplY3QuZnJlZXplIHdhcyBjYWxsZWQgaW4gZXZlbnQtZGVmIHBhcnNpbmdcbiAgICBnZXQgY2xhc3NOYW1lcygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jbGFzc05hbWVzOyB9XG4gICAgZ2V0IGV4dGVuZGVkUHJvcHMoKSB7IHJldHVybiB0aGlzLl9kZWYuZXh0ZW5kZWRQcm9wczsgfVxuICAgIHRvUGxhaW5PYmplY3Qoc2V0dGluZ3MgPSB7fSkge1xuICAgICAgICBsZXQgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBsZXQgeyB1aSB9ID0gZGVmO1xuICAgICAgICBsZXQgeyBzdGFydFN0ciwgZW5kU3RyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVzID0ge1xuICAgICAgICAgICAgYWxsRGF5OiBkZWYuYWxsRGF5LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVmLnRpdGxlKSB7XG4gICAgICAgICAgICByZXMudGl0bGUgPSBkZWYudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0U3RyKSB7XG4gICAgICAgICAgICByZXMuc3RhcnQgPSBzdGFydFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kU3RyKSB7XG4gICAgICAgICAgICByZXMuZW5kID0gZW5kU3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucHVibGljSWQpIHtcbiAgICAgICAgICAgIHJlcy5pZCA9IGRlZi5wdWJsaWNJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgIHJlcy5ncm91cElkID0gZGVmLmdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi51cmwpIHtcbiAgICAgICAgICAgIHJlcy51cmwgPSBkZWYudXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ICYmIHVpLmRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmVzLmRpc3BsYXkgPSB1aS5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgcmVjdXJyaW5nLWV2ZW50IHByb3BlcnRpZXM/Pz9cbiAgICAgICAgLy8gVE9ETzogaW5jbHVkZSBzdGFydEVkaXRhYmxlL2R1cmF0aW9uRWRpdGFibGUvY29uc3RyYWludC9vdmVybGFwL2FsbG93XG4gICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUNvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgPT09IHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICByZXMuY29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodWkuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJhY2tncm91bmRDb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5ib3JkZXJDb2xvciA9IHVpLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1aS50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIHJlcy50ZXh0Q29sb3IgPSB1aS50ZXh0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMuY2xhc3NOYW1lcyA9IHVpLmNsYXNzTmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlZi5leHRlbmRlZFByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzLmV4dGVuZGVkUHJvcHMgPSBkZWYuZXh0ZW5kZWRQcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUGxhaW5PYmplY3QoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpIHtcbiAgICBsZXQgZGVmID0gZXZlbnRBcGkuX2RlZjtcbiAgICBsZXQgaW5zdGFuY2UgPSBldmVudEFwaS5faW5zdGFuY2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogeyBbZGVmLmRlZklkXTogZGVmIH0sXG4gICAgICAgIGluc3RhbmNlczogaW5zdGFuY2VcbiAgICAgICAgICAgID8geyBbaW5zdGFuY2UuaW5zdGFuY2VJZF06IGluc3RhbmNlIH1cbiAgICAgICAgICAgIDoge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRBcGlzKGV2ZW50U3RvcmUsIGNvbnRleHQsIGV4Y2x1ZGVJbnN0YW5jZSkge1xuICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICBsZXQgZXZlbnRBcGlzID0gW107XG4gICAgbGV0IGV4Y2x1ZGVJbnN0YW5jZUlkID0gZXhjbHVkZUluc3RhbmNlID8gZXhjbHVkZUluc3RhbmNlLmluc3RhbmNlSWQgOiAnJztcbiAgICBmb3IgKGxldCBpZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2lkXTtcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBpZiAoaW5zdGFuY2UuaW5zdGFuY2VJZCAhPT0gZXhjbHVkZUluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgIGV2ZW50QXBpcy5wdXNoKG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudEFwaXM7XG59XG5cbi8qXG5TcGVjaWZ5aW5nIG5leHREYXlUaHJlc2hvbGQgc2lnbmFscyB0aGF0IGFsbC1kYXkgcmFuZ2VzIHNob3VsZCBiZSBzbGljZWQuXG4qL1xuZnVuY3Rpb24gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZnJhbWluZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgbGV0IGludmVyc2VCZ0J5R3JvdXBJZCA9IHt9O1xuICAgIGxldCBpbnZlcnNlQmdCeURlZklkID0ge307XG4gICAgbGV0IGRlZkJ5R3JvdXBJZCA9IHt9O1xuICAgIGxldCBiZ1JhbmdlcyA9IFtdO1xuICAgIGxldCBmZ1JhbmdlcyA9IFtdO1xuICAgIGxldCBldmVudFVpcyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50VWlCYXNlcyk7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSA9IGRlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2RlZklkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICBsZXQgb3JpZ1JhbmdlID0gaW5zdGFuY2UucmFuZ2U7XG4gICAgICAgIGxldCBub3JtYWxSYW5nZSA9ICghZGVmLmFsbERheSAmJiBuZXh0RGF5VGhyZXNob2xkKSA/XG4gICAgICAgICAgICBjb21wdXRlVmlzaWJsZURheVJhbmdlKG9yaWdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkgOlxuICAgICAgICAgICAgb3JpZ1JhbmdlO1xuICAgICAgICBsZXQgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMobm9ybWFsUmFuZ2UsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xuICAgICAgICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0ucHVzaChzbGljZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2luc3RhbmNlLmRlZklkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1aS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAodWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnID8gYmdSYW5nZXMgOiBmZ1JhbmdlcykucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IG5vcm1hbFJhbmdlLnN0YXJ0ICYmIG5vcm1hbFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogbm9ybWFsUmFuZ2UuZW5kICYmIG5vcm1hbFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgZ3JvdXBJZCBpbiBpbnZlcnNlQmdCeUdyb3VwSWQpIHsgLy8gQlkgR1JPVVBcbiAgICAgICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5R3JvdXBJZFtncm91cElkXTtcbiAgICAgICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGRlZiA9IGRlZkJ5R3JvdXBJZFtncm91cElkXTtcbiAgICAgICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWYsXG4gICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gaW52ZXJzZUJnQnlEZWZJZCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF07XG4gICAgICAgIGxldCBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGZvciAobGV0IGludmVydGVkUmFuZ2Ugb2YgaW52ZXJ0ZWRSYW5nZXMpIHtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZjogZXZlbnRTdG9yZS5kZWZzW2RlZklkXSxcbiAgICAgICAgICAgICAgICB1aTogZXZlbnRVaXNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxuICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzRW5kOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGJnOiBiZ1JhbmdlcywgZmc6IGZnUmFuZ2VzIH07XG59XG5mdW5jdGlvbiBoYXNCZ1JlbmRlcmluZyhkZWYpIHtcbiAgICByZXR1cm4gZGVmLnVpLmRpc3BsYXkgPT09ICdiYWNrZ3JvdW5kJyB8fCBkZWYudWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCc7XG59XG5mdW5jdGlvbiBzZXRFbFNlZyhlbCwgc2VnKSB7XG4gICAgZWwuZmNTZWcgPSBzZWc7XG59XG5mdW5jdGlvbiBnZXRFbFNlZyhlbCkge1xuICAgIHJldHVybiBlbC5mY1NlZyB8fFxuICAgICAgICBlbC5wYXJlbnROb2RlLmZjU2VnIHx8IC8vIGZvciB0aGUgaGFybmVzc1xuICAgICAgICBudWxsO1xufVxuLy8gZXZlbnQgdWkgY29tcHV0YXRpb25cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpcyhldmVudERlZnMsIGV2ZW50VWlCYXNlcykge1xuICAgIHJldHVybiBtYXBIYXNoKGV2ZW50RGVmcywgKGV2ZW50RGVmKSA9PiBjb21waWxlRXZlbnRVaShldmVudERlZiwgZXZlbnRVaUJhc2VzKSk7XG59XG5mdW5jdGlvbiBjb21waWxlRXZlbnRVaShldmVudERlZiwgZXZlbnRVaUJhc2VzKSB7XG4gICAgbGV0IHVpcyA9IFtdO1xuICAgIGlmIChldmVudFVpQmFzZXNbJyddKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1snJ10pO1xuICAgIH1cbiAgICBpZiAoZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSkge1xuICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKTtcbiAgICB9XG4gICAgdWlzLnB1c2goZXZlbnREZWYudWkpO1xuICAgIHJldHVybiBjb21iaW5lRXZlbnRVaXModWlzKTtcbn1cbmZ1bmN0aW9uIHNvcnRFdmVudFNlZ3Moc2VncywgZXZlbnRPcmRlclNwZWNzKSB7XG4gICAgbGV0IG9ianMgPSBzZWdzLm1hcChidWlsZFNlZ0NvbXBhcmVPYmopO1xuICAgIG9ianMuc29ydCgob2JqMCwgb2JqMSkgPT4gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBldmVudE9yZGVyU3BlY3MpKTtcbiAgICByZXR1cm4gb2Jqcy5tYXAoKGMpID0+IGMuX3NlZyk7XG59XG4vLyByZXR1cm5zIGEgb2JqZWN0IHdpdGggYWxsIHByaW1pdGl2ZSBwcm9wcyB0aGF0IGNhbiBiZSBjb21wYXJlZFxuZnVuY3Rpb24gYnVpbGRTZWdDb21wYXJlT2JqKHNlZykge1xuICAgIGxldCB7IGV2ZW50UmFuZ2UgfSA9IHNlZztcbiAgICBsZXQgZXZlbnREZWYgPSBldmVudFJhbmdlLmRlZjtcbiAgICBsZXQgcmFuZ2UgPSBldmVudFJhbmdlLmluc3RhbmNlID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5yYW5nZSA6IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQgPyByYW5nZS5zdGFydC52YWx1ZU9mKCkgOiAwOyAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igb3Blbi1yYW5nZSBldmVudHNcbiAgICBsZXQgZW5kID0gcmFuZ2UuZW5kID8gcmFuZ2UuZW5kLnZhbHVlT2YoKSA6IDA7IC8vIFwiXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudERlZi5leHRlbmRlZFByb3BzKSwgZXZlbnREZWYpLCB7IGlkOiBldmVudERlZi5wdWJsaWNJZCwgc3RhcnQsXG4gICAgICAgIGVuZCwgZHVyYXRpb246IGVuZCAtIHN0YXJ0LCBhbGxEYXk6IE51bWJlcihldmVudERlZi5hbGxEYXkpLCBfc2VnOiBzZWcgfSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCkge1xuICAgIGxldCB7IHBsdWdpbkhvb2tzIH0gPSBjb250ZXh0O1xuICAgIGxldCB0cmFuc2Zvcm1lcnMgPSBwbHVnaW5Ib29rcy5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycztcbiAgICBsZXQgeyBkZWYsIHVpIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICBsZXQgdmFsID0gdWkuc3RhcnRFZGl0YWJsZTtcbiAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICAgICAgdmFsID0gdHJhbnNmb3JtZXIodmFsLCBkZWYsIHVpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2VnLmlzU3RhcnQgJiYgc2VnLmV2ZW50UmFuZ2UudWkuZHVyYXRpb25FZGl0YWJsZSAmJiBjb250ZXh0Lm9wdGlvbnMuZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNFbmQgJiYgc2VnLmV2ZW50UmFuZ2UudWkuZHVyYXRpb25FZGl0YWJsZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBkZWZhdWx0RGlzcGxheUV2ZW50VGltZSwgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuc3RhcnRPdmVycmlkZSwgZW5kT3ZlcnJpZGUpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGRpc3BsYXlFdmVudFRpbWUsIGRpc3BsYXlFdmVudEVuZCB9ID0gb3B0aW9ucztcbiAgICBsZXQgZXZlbnREZWYgPSBzZWcuZXZlbnRSYW5nZS5kZWY7XG4gICAgbGV0IGV2ZW50SW5zdGFuY2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICBpZiAoZGlzcGxheUV2ZW50VGltZSA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSBkZWZhdWx0RGlzcGxheUV2ZW50VGltZSAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSBkZWZhdWx0RGlzcGxheUV2ZW50RW5kICE9PSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHdob2xlRXZlbnRTdGFydCA9IGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IHdob2xlRXZlbnRFbmQgPSBldmVudEluc3RhbmNlLnJhbmdlLmVuZDtcbiAgICBsZXQgc2VnU3RhcnQgPSBzdGFydE92ZXJyaWRlIHx8IHNlZy5zdGFydCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcbiAgICBsZXQgc2VnRW5kID0gZW5kT3ZlcnJpZGUgfHwgc2VnLmVuZCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XG4gICAgbGV0IGlzU3RhcnREYXkgPSBzdGFydE9mRGF5KHdob2xlRXZlbnRTdGFydCkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KHNlZ1N0YXJ0KS52YWx1ZU9mKCk7XG4gICAgbGV0IGlzRW5kRGF5ID0gc3RhcnRPZkRheShhZGRNcyh3aG9sZUV2ZW50RW5kLCAtMSkpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShhZGRNcyhzZWdFbmQsIC0xKSkudmFsdWVPZigpO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lICYmICFldmVudERlZi5hbGxEYXkgJiYgKGlzU3RhcnREYXkgfHwgaXNFbmREYXkpKSB7XG4gICAgICAgIHNlZ1N0YXJ0ID0gaXNTdGFydERheSA/IHdob2xlRXZlbnRTdGFydCA6IHNlZ1N0YXJ0O1xuICAgICAgICBzZWdFbmQgPSBpc0VuZERheSA/IHdob2xlRXZlbnRFbmQgOiBzZWdFbmQ7XG4gICAgICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgJiYgZXZlbnREZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzZWdTdGFydCwgc2VnRW5kLCB0aW1lRm9ybWF0LCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KHNlZ1N0YXJ0LCB0aW1lRm9ybWF0LCB7XG4gICAgICAgICAgICBmb3JjZWRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgLy8gbm9vb29vLCBzYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkge1xuICAgIGxldCBzZWdSYW5nZSA9IHNlZy5ldmVudFJhbmdlLnJhbmdlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzUGFzdDogc2VnUmFuZ2UuZW5kIDw9IChub3dEYXRlIHx8IHRvZGF5UmFuZ2Uuc3RhcnQpLFxuICAgICAgICBpc0Z1dHVyZTogc2VnUmFuZ2Uuc3RhcnQgPj0gKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5lbmQpLFxuICAgICAgICBpc1RvZGF5OiB0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgc2VnUmFuZ2Uuc3RhcnQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRFdmVudENsYXNzTmFtZXMocHJvcHMpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFsnZmMtZXZlbnQnXTtcbiAgICBpZiAocHJvcHMuaXNNaXJyb3IpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1taXJyb3InKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRHJhZ2dhYmxlKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dhYmxlJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1N0YXJ0UmVzaXphYmxlIHx8IHByb3BzLmlzRW5kUmVzaXphYmxlKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXphYmxlJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dpbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzUmVzaXppbmcpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemluZycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTZWxlY3RlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXNlbGVjdGVkJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1N0YXJ0KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc3RhcnQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRW5kKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZW5kJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1Bhc3QpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1wYXN0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1RvZGF5KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtdG9kYXknKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRnV0dXJlKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZnV0dXJlJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFJhbmdlS2V5KGV2ZW50UmFuZ2UpIHtcbiAgICByZXR1cm4gZXZlbnRSYW5nZS5pbnN0YW5jZVxuICAgICAgICA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZFxuICAgICAgICA6IGAke2V2ZW50UmFuZ2UuZGVmLmRlZklkfToke2V2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQudG9JU09TdHJpbmcoKX1gO1xuICAgIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxufVxuZnVuY3Rpb24gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGVmLCBpbnN0YW5jZSB9ID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgbGV0IHsgdXJsIH0gPSBkZWY7XG4gICAgaWYgKHVybCkge1xuICAgICAgICByZXR1cm4geyBocmVmOiB1cmwgfTtcbiAgICB9XG4gICAgbGV0IHsgZW1pdHRlciwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgeyBldmVudEludGVyYWN0aXZlIH0gPSBvcHRpb25zO1xuICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgZXZlbnRJbnRlcmFjdGl2ZSA9IGRlZi5pbnRlcmFjdGl2ZTtcbiAgICAgICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZXZlbnRJbnRlcmFjdGl2ZSA9IEJvb2xlYW4oZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRDbGljaycpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtb2NrIHdoYXQgaGFwcGVucyBpbiBFdmVudENsaWNraW5nXG4gICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUpIHtcbiAgICAgICAgLy8gb25seSBhdHRhY2gga2V5Ym9hcmQtcmVsYXRlZCBoYW5kbGVycyBiZWNhdXNlIGNsaWNrIGhhbmRsZXIgaXMgYWxyZWFkeSBkb25lIGluIEV2ZW50Q2xpY2tpbmdcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzKChldikgPT4ge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xuICAgICAgICAgICAgICAgIGVsOiBldi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5cbmNvbnN0IFNUQU5EQVJEX1BST1BTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG5mdW5jdGlvbiBwYXJzZURhdGVTcGFuKHJhdywgZGF0ZUVudiwgZGVmYXVsdER1cmF0aW9uKSB7XG4gICAgbGV0IHNwYW4gPSBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpO1xuICAgIGxldCB7IHJhbmdlIH0gPSBzcGFuO1xuICAgIGlmICghcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmFuZ2UuZW5kKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UuZW5kID0gZGF0ZUVudi5hZGQocmFuZ2Uuc3RhcnQsIGRlZmF1bHREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xufVxuLypcblRPRE86IHNvbWVob3cgY29tYmluZSB3aXRoIHBhcnNlUmFuZ2U/XG5XaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxuKi9cbmZ1bmN0aW9uIHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudikge1xuICAgIGxldCB7IHJlZmluZWQ6IHN0YW5kYXJkUHJvcHMsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIFNUQU5EQVJEX1BST1BTKTtcbiAgICBsZXQgc3RhcnRNZXRhID0gc3RhbmRhcmRQcm9wcy5zdGFydCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLnN0YXJ0KSA6IG51bGw7XG4gICAgbGV0IGVuZE1ldGEgPSBzdGFuZGFyZFByb3BzLmVuZCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLmVuZCkgOiBudWxsO1xuICAgIGxldCB7IGFsbERheSB9ID0gc3RhbmRhcmRQcm9wcztcbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgYWxsRGF5ID0gKHN0YXJ0TWV0YSAmJiBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgcmFuZ2U6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydE1ldGEgPyBzdGFydE1ldGEubWFya2VyIDogbnVsbCxcbiAgICAgICAgICAgIGVuZDogZW5kTWV0YSA/IGVuZE1ldGEubWFya2VyIDogbnVsbCxcbiAgICAgICAgfSwgYWxsRGF5IH0sIGV4dHJhKTtcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNwYW5zRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHJhbmdlc0VxdWFsKHNwYW4wLnJhbmdlLCBzcGFuMS5yYW5nZSkgJiZcbiAgICAgICAgc3BhbjAuYWxsRGF5ID09PSBzcGFuMS5hbGxEYXkgJiZcbiAgICAgICAgaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpO1xufVxuLy8gdGhlIE5PTi1EQVRFLVJFTEFURUQgcHJvcHNcbmZ1bmN0aW9uIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gc3BhbjEpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lICE9PSAncmFuZ2UnICYmIHByb3BOYW1lICE9PSAnYWxsRGF5Jykge1xuICAgICAgICAgICAgaWYgKHNwYW4wW3Byb3BOYW1lXSAhPT0gc3BhbjFbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFyZSB0aGVyZSBhbnkgcHJvcHMgdGhhdCBzcGFuMCBoYXMgdGhhdCBzcGFuMSBET0VTTidUIGhhdmU/XG4gICAgLy8gYm90aCBoYXZlIHJhbmdlL2FsbERheSwgc28gbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UuXG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gc3BhbjApIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gc3BhbjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHNwYW4ucmFuZ2UsIGRhdGVFbnYsIHNwYW4uYWxsRGF5KSksIHsgYWxsRGF5OiBzcGFuLmFsbERheSB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpKSwgeyB0aW1lWm9uZTogZGF0ZUVudi50aW1lWm9uZSB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICAgICAgZW5kOiBkYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgICAgICBzdGFydFN0cjogZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWUgfSksXG4gICAgICAgIGVuZFN0cjogZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kLCB7IG9taXRUaW1lIH0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpIHtcbiAgICBsZXQgcmVzID0gcmVmaW5lRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgY29udGV4dCk7XG4gICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVzLnJlZmluZWQsIHJlcy5leHRyYSwgJycsIC8vIHNvdXJjZUlkXG4gICAgZGF0ZVNwYW4uYWxsRGF5LCB0cnVlLCAvLyBoYXNFbmRcbiAgICBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWYsXG4gICAgICAgIHVpOiBjb21waWxlRXZlbnRVaShkZWYsIGV2ZW50VWlCYXNlcyksXG4gICAgICAgIGluc3RhbmNlOiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgZGF0ZVNwYW4ucmFuZ2UpLFxuICAgICAgICByYW5nZTogZGF0ZVNwYW4ucmFuZ2UsXG4gICAgICAgIGlzU3RhcnQ6IHRydWUsXG4gICAgICAgIGlzRW5kOiB0cnVlLFxuICAgIH07XG59XG5cbi8qXG5naXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXG50aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcbm9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxuaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXG4qL1xuZnVuY3Rpb24gdW5wcm9taXNpZnkoZnVuYywgbm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjaywgbm9ybWFsaXplZEZhaWx1cmVDYWxsYmFjaykge1xuICAgIC8vIGd1YXJkIGFnYWluc3Qgc3VjY2Vzcy9mYWlsdXJlIGNhbGxiYWNrcyBiZWluZyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgICAvLyBhbmQgZ3VhcmQgYWdhaW5zdCBhIHByb21pc2UgQU5EIGNhbGxiYWNrIGJlaW5nIHVzZWQgdG9nZXRoZXIuXG4gICAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICBsZXQgd3JhcHBlZFN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrKHJlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCB3cmFwcGVkRmFpbHVyZSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbm9ybWFsaXplZEZhaWx1cmVDYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICB9XG59XG5cbmNsYXNzIEpzb25SZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1ZXN0SnNvbihtZXRob2QsIHVybCwgcGFyYW1zKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgICBtZXRob2QsXG4gICAgfTtcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArXG4gICAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmZXRjaE9wdGlvbnMuYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmZXRjaCh1cmwsIGZldGNoT3B0aW9ucykudGhlbigoZmV0Y2hSZXMpID0+IHtcbiAgICAgICAgaWYgKGZldGNoUmVzLm9rKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hSZXMuanNvbigpLnRoZW4oKHBhcnNlZFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwYXJzZWRSZXNwb25zZSwgZmV0Y2hSZXNdO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUmVxdWVzdEVycm9yKCdGYWlsdXJlIHBhcnNpbmcgSlNPTicsIGZldGNoUmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25SZXF1ZXN0RXJyb3IoJ1JlcXVlc3QgZmFpbGVkJywgZmV0Y2hSZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmxldCBjYW5WR3Jvd1dpdGhpbkNlbGw7XG5mdW5jdGlvbiBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKSB7XG4gICAgaWYgKGNhblZHcm93V2l0aGluQ2VsbCA9PSBudWxsKSB7XG4gICAgICAgIGNhblZHcm93V2l0aGluQ2VsbCA9IGNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhblZHcm93V2l0aGluQ2VsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwoKSB7XG4gICAgLy8gZm9yIFNTUiwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGwgaW1tZWRpYXRlbHkgYXQgdG9wLWxldmVsXG4gICAgLy8gVE9ETzoganVzdCBtYWtlIHRoaXMgbG9naWMgZXhlY3V0ZSB0b3AtbGV2ZWwsIGltbWVkaWF0ZWx5LCBpbnN0ZWFkIG9mIGRvaW5nIGxhemlseVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJzBweCc7XG4gICAgZWwuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIGVsLmlubmVySFRNTCA9ICc8dGFibGU+PHRyPjx0ZD48ZGl2PjwvZGl2PjwvdGQ+PC90cj48L3RhYmxlPic7XG4gICAgZWwucXVlcnlTZWxlY3RvcigndGFibGUnKS5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICBsZXQgZGl2ID0gZWwucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgbGV0IHBvc3NpYmxlID0gZGl2Lm9mZnNldEhlaWdodCA+IDA7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlO1xufVxuXG5jbGFzcyBDYWxlbmRhclJvb3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZvclByaW50OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVCZWZvcmVQcmludCA9ICgpID0+IHtcbiAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZvclByaW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCA9ICgpID0+IHtcbiAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZvclByaW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgZm9yUHJpbnQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBpc0hlaWdodEF1dG8gPSBmb3JQcmludCB8fCBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMuY29udGVudEhlaWdodCA9PT0gJ2F1dG8nO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gKCFpc0hlaWdodEF1dG8gJiYgb3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkgPyBvcHRpb25zLmhlaWdodCA6ICcnO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYycsXG4gICAgICAgICAgICBmb3JQcmludCA/ICdmYy1tZWRpYS1wcmludCcgOiAnZmMtbWVkaWEtc2NyZWVuJyxcbiAgICAgICAgICAgIGBmYy1kaXJlY3Rpb24tJHtvcHRpb25zLmRpcmVjdGlvbn1gLFxuICAgICAgICAgICAgcHJvcHMudGhlbWUuZ2V0Q2xhc3MoJ3Jvb3QnKSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKCFnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1saXF1aWQtaGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbihjbGFzc05hbWVzLCBoZWlnaHQsIGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgZW1pdHRlci5vbignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludCk7XG4gICAgICAgIGVtaXR0ZXIub24oJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vZmYoJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KTtcbiAgICB9XG59XG5cbmNsYXNzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHNldHRpbmdzLmNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5pc0hpdENvbWJvQWxsb3dlZCA9IHNldHRpbmdzLmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGw7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIGVsOiBpbnB1dC5lbCxcbiAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGlucHV0LnVzZUV2ZW50Q2VudGVyICE9IG51bGwgPyBpbnB1dC51c2VFdmVudENlbnRlciA6IHRydWUsXG4gICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiBpbnB1dC5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtzZXR0aW5ncy5jb21wb25lbnQudWlkXTogc2V0dGluZ3MsXG4gICAgfTtcbn1cbi8vIGdsb2JhbCBzdGF0ZVxuY29uc3QgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlID0ge307XG5cbmNsYXNzIE5vd1RpbWVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVmcmVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1pbmcgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKTtcbiAgICAgICAgICAgIGlmICh0aW1pbmcuc3RhdGUubm93RGF0ZS52YWx1ZU9mKCkgIT09IHRoaXMuc3RhdGUubm93RGF0ZS52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHRpbWluZy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KHRpbWluZy53YWl0TXMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jb21wdXRlVGltaW5nKCkuc3RhdGU7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oc3RhdGUubm93RGF0ZSwgc3RhdGUudG9kYXlSYW5nZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0Lm5vd01hbmFnZXIuYWRkUmVzZXRMaXN0ZW5lcih0aGlzLmhhbmRsZVJlZnJlc2gpO1xuICAgICAgICAvLyBmaXJlZCB0YWIgYmVjb21lcyB2aXNpYmxlIGFmdGVyIGJlaW5nIGhpZGRlblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQubm93TWFuYWdlci5yZW1vdmVSZXNldExpc3RlbmVyKHRoaXMuaGFuZGxlUmVmcmVzaCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgIH1cbiAgICBjb21wdXRlVGltaW5nKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHVucm91bmRlZE5vdyA9IGNvbnRleHQubm93TWFuYWdlci5nZXREYXRlTWFya2VyKCk7XG4gICAgICAgIGxldCBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KTtcbiAgICAgICAgbGV0IG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKTtcbiAgICAgICAgbGV0IHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKTtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgICAgICB3YWl0TXMgPSBNYXRoLm1pbigxMDAwICogNjAgKiA2MCAqIDI0LCB3YWl0TXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxuICAgICAgICAgICAgd2FpdE1zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KHdhaXRNcyA9IHRoaXMuY29tcHV0ZVRpbWluZygpLndhaXRNcykge1xuICAgICAgICAvLyBOT1RFOiB0aW1lb3V0IGNvdWxkIHRha2UgbG9uZ2VyIHRoYW4gZXhwZWN0ZWQgaWYgdGFiIHNsZWVwcyxcbiAgICAgICAgLy8gd2hpY2ggaXMgd2h5IHdlIGxpc3RlbiB0byAndmlzaWJpbGl0eWNoYW5nZSdcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHRpbWVvdXQgY291bGQgYWxzbyByZXR1cm4gKmVhcmxpZXIqIHRoYW4gZXhwZWN0ZWQsIGFuZCB3ZSBuZWVkIHRvIHdhaXQgMiBtcyBtb3JlXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHdoeSB1c2UgdXNlIHNhbWUgd2FpdE1zIGZyb20gY29tcHV0ZVRpbWluZywgc28gd2UgZG9uJ3Qgc2tpcCBhbiBpbnRlcnZhbCB3aGlsZVxuICAgICAgICAgICAgLy8gLnNldFN0YXRlKCkgaXMgZXhlY3V0aW5nXG4gICAgICAgICAgICBjb25zdCB0aW1pbmcgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUodGltaW5nLnN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KHRpbWluZy53YWl0TXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHdhaXRNcyk7XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuTm93VGltZXIuY29udGV4dFR5cGUgPSBWaWV3Q29udGV4dFR5cGU7XG5mdW5jdGlvbiBidWlsZERheVJhbmdlKGRhdGUpIHtcbiAgICBsZXQgc3RhcnQgPSBzdGFydE9mRGF5KGRhdGUpO1xuICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG5cbmNsYXNzIENhbGVuZGFySW1wbCB7XG4gICAgZ2V0Q3VycmVudERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5nZXRDdXJyZW50RGF0YSgpO1xuICAgIH1cbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZGlzcGF0Y2goYWN0aW9uKTtcbiAgICB9XG4gICAgZ2V0IHZpZXcoKSB7IHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkudmlld0FwaTsgfVxuICAgIGJhdGNoUmVuZGVyaW5nKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBPcHRpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzZXRPcHRpb24obmFtZSwgdmFsKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgb3B0aW9uTmFtZTogbmFtZSxcbiAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiB2YWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRPcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W25hbWVdO1xuICAgIH1cbiAgICBnZXRBdmFpbGFibGVMb2NhbGVDb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5hdmFpbGFibGVSYXdMb2NhbGVzKTtcbiAgICB9XG4gICAgLy8gVHJpZ2dlclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgb24oaGFuZGxlck5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IHsgY3VycmVudERhdGFNYW5hZ2VyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVyc1toYW5kbGVyTmFtZV0pIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9uKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBsaXN0ZW5lciBuYW1lICcke2hhbmRsZXJOYW1lfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvZmYoaGFuZGxlck5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci5vZmYoaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBub3QgbWVhbnQgZm9yIHB1YmxpYyB1c2VcbiAgICB0cmlnZ2VyKGhhbmRsZXJOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIudHJpZ2dlcihoYW5kbGVyTmFtZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8vIFZpZXdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNoYW5nZVZpZXcodmlld1R5cGUsIGRhdGVPclJhbmdlKSB7XG4gICAgICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlLnN0YXJ0ICYmIGRhdGVPclJhbmdlLmVuZCkgeyAvLyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWU6ICd2aXNpYmxlUmFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IGRhdGVPclJhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGRhdGVFbnYuY3JlYXRlTWFya2VyKGRhdGVPclJhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGb3JjZXMgbmF2aWdhdGlvbiB0byBhIHZpZXcgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIGB2aWV3VHlwZWAgY2FuIGJlIGEgc3BlY2lmaWMgdmlldyBuYW1lIG9yIGEgZ2VuZXJpYyBvbmUgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLlxuICAgIC8vIG5lZWRzIHRvIGNoYW5nZVxuICAgIHpvb21UbyhkYXRlTWFya2VyLCB2aWV3VHlwZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzcGVjO1xuICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXG4gICAgICAgIHNwZWMgPSBzdGF0ZS52aWV3U3BlY3Nbdmlld1R5cGVdIHx8IHRoaXMuZ2V0VW5pdFZpZXdTcGVjKHZpZXdUeXBlKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgIHZpZXdUeXBlOiBzcGVjLnR5cGUsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuICAgIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cbiAgICBnZXRVbml0Vmlld1NwZWModW5pdCkge1xuICAgICAgICBsZXQgeyB2aWV3U3BlY3MsIHRvb2xiYXJDb25maWcgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHZpZXdUeXBlcyA9IFtdLmNvbmNhdCh0b29sYmFyQ29uZmlnLmhlYWRlciA/IHRvb2xiYXJDb25maWcuaGVhZGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSwgdG9vbGJhckNvbmZpZy5mb290ZXIgPyB0b29sYmFyQ29uZmlnLmZvb3Rlci52aWV3c1dpdGhCdXR0b25zIDogW10pO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IHNwZWM7XG4gICAgICAgIGZvciAobGV0IHZpZXdUeXBlIGluIHZpZXdTcGVjcykge1xuICAgICAgICAgICAgdmlld1R5cGVzLnB1c2godmlld1R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNwZWMgPSB2aWV3U3BlY3Nbdmlld1R5cGVzW2ldXTtcbiAgICAgICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgRGF0ZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJldigpIHtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1BSRVYnIH0pO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnTkVYVCcgfSk7XG4gICAgfVxuICAgIHByZXZZZWFyKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgLTEpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmV4dFllYXIoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAxKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvZGF5KCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUubm93TWFuYWdlci5nZXREYXRlTWFya2VyKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRlKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfVxuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZm9ybWF0RGF0ZShkLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIGZvcm1hdFJhbmdlKGQwLCBkMSwgc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBmb3JtYXRJc28oZCwgb21pdFRpbWUpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIERhdGUgU2VsZWN0aW9uIC8gRXZlbnQgU2VsZWN0aW9uIC8gRGF5Q2xpY2tcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNlbGVjdChkYXRlT3JPYmosIGVuZERhdGUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbklucHV0O1xuICAgICAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IGRhdGVPck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKHNlbGVjdGlvbklucHV0LCBzdGF0ZS5kYXRlRW52LCBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSkpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIHRocm93IHBhcnNlIGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zZWxlY3QocGV2KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWRkRXZlbnQoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEltcGwpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudElucHV0Ll9kZWY7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGF0YS5ldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHsgZGVmLCBpbnN0YW5jZSB9KSwgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKGV2ZW50SW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZXZlbnRTb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgW2V2ZW50U291cmNlXSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgICAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCk7IC8vIFRPRE86IHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFzb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFwiJHtzb3VyY2VJbnB1dH1cImApOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgbGV0IG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChzdGF0ZSwgdHVwbGUuZGVmLCB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50QWRkKGV2ZW50QXBpKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIGdldEV2ZW50QnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW1wbChzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVFMnIH0pO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldEV2ZW50U291cmNlcygpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgbGV0IHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH1cbiAgICBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUltcGwpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2VdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHN0YXRlKTtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbZXZlbnRTb3VyY2VdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfVxuICAgIHJlZmV0Y2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsIGlzUmVmZXRjaDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzY3JvbGxUb1RpbWUodGltZUlucHV0KSB7XG4gICAgICAgIGxldCB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxuY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuY2xhc3MgU3BsaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cbiAgICB9XG4gICAgc3BsaXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH1cbiAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9XG4gICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcbiAgICB9XG4gICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcbiAgICB9XG4gICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XG4gICAgfVxuICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XG4gICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICBsZXQgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0dWZmO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlTWV0YShkYXRlLCB0b2RheVJhbmdlLCBub3dEYXRlLCBkYXRlUHJvZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdzogZGF0ZS5nZXRVVENEYXkoKSxcbiAgICAgICAgaXNEaXNhYmxlZDogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAoIWRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIHx8ICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKSkpLFxuICAgICAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzUGFzdDogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPCBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA8IHRvZGF5UmFuZ2Uuc3RhcnQpIDogZmFsc2UpLFxuICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLWRheScsXG4gICAgICAgIGBmYy1kYXktJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIGBmYy1zbG90LSR7REFZX0lEU1ttZXRhLmRvd119YCxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbmNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xuY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XG5mdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbmxldCBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBsZXQgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgbGV0IGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xuICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xuICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcbiAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXG4gICAgfTtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XG4gICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xuICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xuICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XG4gICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbCkge1xuICAgIGxldCBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpO1xuICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZm9yIChsZXQgY2xpcHBpbmdQYXJlbnQgb2YgY2xpcHBpbmdQYXJlbnRzKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbi8vIGRvZXMgbm90IHJldHVybiB3aW5kb3dcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbCkge1xuICAgIGxldCBwYXJlbnRzID0gW107XG4gICAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59XG5cbi8qXG5SZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxuQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxuKi9cbmNsYXNzIFBvc2l0aW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbkVsLCBlbHMsIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmVscyA9IGVscztcbiAgICAgICAgbGV0IG9yaWdpbkNsaWVudFJlY3QgPSB0aGlzLm9yaWdpbkNsaWVudFJlY3QgPSBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wLWxlZnRcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFJlY3QudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBidWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50TGVmdCkge1xuICAgICAgICBsZXQgbGVmdHMgPSBbXTtcbiAgICAgICAgbGV0IHJpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRUb3ApIHtcbiAgICAgICAgbGV0IHRvcHMgPSBbXTtcbiAgICAgICAgbGV0IGJvdHRvbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgbGVmdFRvSW5kZXgobGVmdFBvc2l0aW9uKSB7XG4gICAgICAgIGxldCB7IGxlZnRzLCByaWdodHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIHRvcFRvSW5kZXgodG9wUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHsgdG9wcywgYm90dG9tcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9XG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0V2lkdGgobGVmdEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuICAgIH1cbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0SGVpZ2h0KHRvcEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcbiAgICB9XG4gICAgc2ltaWxhclRvKG90aGVyQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHNpbWlsYXJOdW1BcnJheXModGhpcy50b3BzIHx8IFtdLCBvdGhlckNhY2hlLnRvcHMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMuYm90dG9tcyB8fCBbXSwgb3RoZXJDYWNoZS5ib3R0b21zIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmxlZnRzIHx8IFtdLCBvdGhlckNhY2hlLmxlZnRzIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLnJpZ2h0cyB8fCBbXSwgb3RoZXJDYWNoZS5yaWdodHMgfHwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNpbWlsYXJOdW1BcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGxlbiA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZChhW2ldKSAhPT0gTWF0aC5yb3VuZChiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG5jbGFzcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBnZXRNYXhTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9XG4gICAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbFVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbERvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfVxufVxuY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFg7XG4gICAgfVxuICAgIHNldFNjcm9sbFRvcChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnNjcm9sbFgsIG4pO1xuICAgIH1cbiAgICBzZXRTY3JvbGxMZWZ0KG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cuc2Nyb2xsWSk7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB9XG59XG5cbi8qXG5hbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcblxuUFVSUE9TRVM6XG4tIGhvb2sgdXAgdG8gZmcsIGZpbGwsIGFuZCBtaXJyb3IgcmVuZGVyZXJzXG4tIGludGVyZmFjZSBmb3IgZHJhZ2dpbmcgYW5kIGhpdHNcbiovXG5jbGFzcyBEYXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudWlkID0gZ3VpZCgpO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmVwYXJlSGl0cygpIHtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0XG4gICAgfVxuICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlzVmFsaWRTZWdEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlzVmFsaWREYXRlRG93bkVsKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH1cbn1cblxuY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoZ2V0RW50cnlUaGlja25lc3MgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gaWYgbm8gdGhpY2tuZXNzIGtub3duLCBhc3N1bWUgMSAoaWYgMCwgc28gc21hbGwgaXQgYWx3YXlzIGZpdHMpXG4gICAgICAgIHJldHVybiBlbnRyeS50aGlja25lc3MgfHwgMTtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuZ2V0RW50cnlUaGlja25lc3MgPSBnZXRFbnRyeVRoaWNrbmVzcztcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBhZGRTZWdzKGlucHV0cykge1xuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyhlbnRyeSkgPD0gdGhpcy5tYXhDb29yZCkgJiZcbiAgICAgICAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KTtcbiAgICB9XG4gICAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKGVudHJ5LnNwYW4sIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LnNwYW4pIH0pO1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIERvZXMgTk9UIGFkZCB3aGF0IGhpdCB0aGUgYGJhcnJpZXJgIGludG8gaGlkZGVuRW50cmllcy4gU2hvdWxkIGFscmVhZHkgYmUgZG9uZS5cbiAgICAqL1xuICAgIHNwbGl0RW50cnkoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IGVudHJ5U3BhbiA9IGVudHJ5LnNwYW47XG4gICAgICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhbjtcbiAgICAgICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGJhcnJpZXJTcGFuLmVuZCwgZW5kOiBlbnRyeVNwYW4uZW5kIH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH1cbiAgICAvKlxuICAgIGRvZXMgbm90IGNhcmUgYWJvdXQgbGltaXRzXG4gICAgKi9cbiAgICBmaW5kSW5zZXJ0aW9uKG5ld0VudHJ5KSB7XG4gICAgICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCwgc3RyaWN0T3JkZXIsIHN0YWNrQ250cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICBsZXQgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICBsZXQgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICBsZXQgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgbGV0IHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yIChsZXQgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2luZ0Nvb3JkID0gbGV2ZWxDb29yZHNbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBwYXN0IHRoZSBwbGFjZWQgZW50cnksIHdlIGhhdmUgZm91bmQgYSBnb29kIGVtcHR5IHNwYWNlIGFuZCBjYW4gc3RvcC5cbiAgICAgICAgICAgIC8vIGlmIHN0cmljdE9yZGVyLCBrZWVwIGZpbmRpbmcgbW9yZSBsYXRlcmFsIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICBpZiAoIXN0cmljdE9yZGVyICYmIHRyYWNraW5nQ29vcmQgPj0gY2FuZGlkYXRlQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKG5ld0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKHRyYWNraW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICBsZXQgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgbGV0IGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICAgICAgICB0b3VjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gc29ydGVkIGJ5IGxldmVsQ29vcmQgKGxvd2VzdCB0byBoaWdoZXN0KVxuICAgIHRvUmVjdHMoKSB7XG4gICAgICAgIGxldCB7IGVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gZW50cmllc0J5TGV2ZWwubGVuZ3RoO1xuICAgICAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgICAgIGxldCBsZXZlbENvb3JkID0gbGV2ZWxDb29yZHNbbGV2ZWxdO1xuICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgdGhpY2tuZXNzOiB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSwgbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudHJ5U3BhbkVuZChlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5zcGFuLmVuZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRW50cnlLZXkoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuaW5kZXggKyAnOicgKyBlbnRyeS5zcGFuLnN0YXJ0O1xufVxuLy8gcmV0dXJucyBncm91cHMgd2l0aCBlbnRyaWVzIHNvcnRlZCBieSBpbnB1dCBvcmRlclxuZnVuY3Rpb24gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzKGVudHJpZXMpIHtcbiAgICBsZXQgbWVyZ2VzID0gW107XG4gICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBsZXQgZmlsdGVyZWRNZXJnZXMgPSBbXTtcbiAgICAgICAgbGV0IGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgICAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG1lcmdlIG9mIG1lcmdlcykge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdFNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXM6IG1lcmdlLmVudHJpZXMuY29uY2F0KGh1bmdyeU1lcmdlLmVudHJpZXMpLFxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBqb2luU3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2gobWVyZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2goaHVuZ3J5TWVyZ2UpO1xuICAgICAgICBtZXJnZXMgPSBmaWx0ZXJlZE1lcmdlcztcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlcztcbn1cbmZ1bmN0aW9uIGpvaW5TcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogTWF0aC5taW4oc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KSxcbiAgICAgICAgZW5kOiBNYXRoLm1heChzcGFuMC5lbmQsIHNwYW4xLmVuZCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCk7XG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHNwYW4wLmVuZCwgc3BhbjEuZW5kKTtcbiAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIGdlbmVyYWwgdXRpbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpbnNlcnRBdChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgYXJyLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYSwgc2VhcmNoVmFsLCBnZXRJdGVtVmFsKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgIGxldCBlbmRJbmRleCA9IGEubGVuZ3RoOyAvLyBleGNsdXNpdmVcbiAgICBpZiAoIWVuZEluZGV4IHx8IHNlYXJjaFZhbCA8IGdldEl0ZW1WYWwoYVtzdGFydEluZGV4XSkpIHsgLy8gbm8gaXRlbXMgT1IgYmVmb3JlIGZpcnN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaFZhbCA+IGdldEl0ZW1WYWwoYVtlbmRJbmRleCAtIDFdKSkgeyAvLyBhZnRlciBsYXN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFtlbmRJbmRleCwgMF07XG4gICAgfVxuICAgIHdoaWxlIChzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IG1pZGRsZUluZGV4ID0gTWF0aC5mbG9vcihzdGFydEluZGV4ICsgKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyAyKTtcbiAgICAgICAgbGV0IG1pZGRsZVZhbCA9IGdldEl0ZW1WYWwoYVttaWRkbGVJbmRleF0pO1xuICAgICAgICBpZiAoc2VhcmNoVmFsIDwgbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlYXJjaFZhbCA+IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG1pZGRsZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gZXF1YWwhXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZUluZGV4LCAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0SW5kZXgsIDBdO1xufVxuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbmNsYXNzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfVxuICAgIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH1cbn1cblxuLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGluIGZhdm9yIG9mIG9wdGlvbnMgc3lzdGVtLFxuLy8gdGhvIGl0J3MgcmVhbGx5IGVhc3kgdG8gYWNjZXNzIHRoaXMgZ2xvYmFsbHkgcmF0aGVyIHRoYW4gcGFzcyB0aHJ1IG9wdGlvbnMuXG5jb25zdCBjb25maWcgPSB7fTtcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cbmNvbnN0IERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG4vLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5mdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRheUNudCkge1xuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXG4gICAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JyB9KTsgLy8gXCJTYXRcIlxuICAgIH1cbiAgICBpZiAoZGF5Q250ID4gMSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSk7IC8vIFwiU2F0IDExLzEyXCJcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTsgLy8gXCJTYXR1cmRheVwiXG59XG5cbmNvbnN0IENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJzsgLy8gZG8gdGhlIGN1c2hpb24gdG9vPyBub1xuZnVuY3Rpb24gcmVuZGVySW5uZXIkMShyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuXG4vLyBCQUQgbmFtZSBmb3IgdGhpcyBjbGFzcyBub3cuIHVzZWQgaW4gdGhlIEhlYWRlclxuY2xhc3MgVGFibGVEYXRlQ2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdGhlbWUsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSk7XG4gICAgICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoIWRheU1ldGEuaXNEaXNhYmxlZCAmJiBwcm9wcy5jb2xDbnQgPiAxKVxuICAgICAgICAgICAgPyBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRhdGUpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBsZXQgcHVibGljRGF0ZSA9IGRhdGVFbnYudG9EYXRlKGRhdGUpO1xuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBMdXhvbiAoYW5kIG1heWJlIG1vbWVudCkgcmV0dXJuaW5nIHByaW9yLWRheXMgd2hlbiBzdGFydC1vZi1kYXlcbiAgICAgICAgLy8gaW4gRFNUIGdhcDogaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzc2MzNcbiAgICAgICAgaWYgKGRhdGVFbnYubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHB1YmxpY0RhdGUgPSBhZGRNcyhwdWJsaWNEYXRlLCAzNjAwMDAwKTsgLy8gYWRkIGFuIGhvdXJcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IHB1YmxpY0RhdGUsIHZpZXc6IHZpZXdBcGkgfSwgcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyksIHsgdGV4dCB9KSwgZGF5TWV0YSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogY2xhc3NOYW1lcywgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuLCAnZGF0YS1kYXRlJzogIWRheU1ldGEuaXNEaXNhYmxlZCA/IGZvcm1hdERheVN0cmluZyhkYXRlKSA6IHVuZGVmaW5lZCB9LCBwcm9wcy5leHRyYURhdGFBdHRycyksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlIZWFkZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lciQxLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIChJbm5lckNvbnRhaW5lcikgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSwgIWRheU1ldGEuaXNEaXNhYmxlZCAmJiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRhaW5lciwgeyBlbFRhZzogXCJhXCIsIGVsQXR0cnM6IG5hdkxpbmtBdHRycywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICBwcm9wcy5pc1N0aWNreSAmJiAnZmMtc3RpY2t5JyxcbiAgICAgICAgICAgIF0gfSkpKSkpKTtcbiAgICB9XG59XG5cbmNvbnN0IFdFRUtEQVlfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pO1xuY2xhc3MgVGFibGVEb3dDZWxsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgdGhlbWUsIHZpZXdBcGksIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGRhdGUgPSBhZGREYXlzKG5ldyBEYXRlKDI1OTIwMDAwMCksIHByb3BzLmRvdyk7IC8vIHN0YXJ0IHdpdGggU3VuLCAwNCBKYW4gMTk3MCAwMDowMDowMCBHTVRcbiAgICAgICAgbGV0IGRhdGVNZXRhID0ge1xuICAgICAgICAgICAgZG93OiBwcm9wcy5kb3csXG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRnV0dXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGFzdDogZmFsc2UsXG4gICAgICAgICAgICBpc1RvZGF5OiBmYWxzZSxcbiAgICAgICAgICAgIGlzT3RoZXI6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdCk7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgICAgICAgZGF0ZSB9LCBkYXRlTWV0YSksIHsgdmlldzogdmlld0FwaSB9KSwgcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyksIHsgdGV4dCB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgQ0xBU1NfTkFNRSxcbiAgICAgICAgICAgICAgICAuLi5nZXREYXlDbGFzc05hbWVzKGRhdGVNZXRhLCB0aGVtZSksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKHsgcm9sZTogJ2NvbHVtbmhlYWRlcicsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIkMSwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgJiYgJ2ZjLXN0aWNreScsXG4gICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGRhdGVFbnYuZm9ybWF0KGRhdGUsIFdFRUtEQVlfRk9STUFUKSxcbiAgICAgICAgICAgICAgICB9IH0pKSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIERheUhlYWRlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXRlcywgZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzLCByZW5kZXJJbnRybyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHJlbmRlckludHJvICYmIHJlbmRlckludHJvKCdkYXknKSxcbiAgICAgICAgICAgIGRhdGVzLm1hcCgoZGF0ZSkgPT4gKGRhdGVzUmVwRGlzdGluY3REYXlzID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVEYXRlQ2VsbCwgeyBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBjb2xDbnQ6IGRhdGVzLmxlbmd0aCwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVEb3dDZWxsLCB7IGtleTogZGF0ZS5nZXRVVENEYXkoKSwgZG93OiBkYXRlLmdldFVUQ0RheSgpLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkpKSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGV4cGxpY2l0Rm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCkge1xuICAgIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpO1xufVxuXG5jbGFzcyBEYXlTZXJpZXNNb2RlbCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgICAgIGxldCBkYXRlID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGxldCB7IGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGxldCBpbmRpY2VzID0gW107XG4gICAgICAgIGxldCBkYXRlcyA9IFtdO1xuICAgICAgICBsZXQgZGF5SW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKGRhdGUgPCBlbmQpIHsgLy8gbG9vcCBlYWNoIGRheSBmcm9tIHN0YXJ0IHRvIGVuZFxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlR2VuZXJhdG9yLmlzSGlkZGVuRGF5KGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KTsgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXlJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCk7XG4gICAgICAgICAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBkYXRlcztcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgICAgdGhpcy5jbnQgPSBkYXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHNsaWNlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxuICAgICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgoYWRkRGF5cyhyYW5nZS5lbmQsIC0xKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG4gICAgICAgIGxldCBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXgpO1xuICAgICAgICBsZXQgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KTtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xuICAgICAgICBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGguY2VpbChjbGlwcGVkRmlyc3RJbmRleCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuICAgICAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuICAgICAgICBpZiAoY2xpcHBlZEZpcnN0SW5kZXggPD0gY2xpcHBlZExhc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXg6IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmlyc3RJbmRleCA9PT0gY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgZGF0ZSwgcmV0dXJucyBpdHMgY2hyb25vbG9jaWFsIGNlbGwtaW5kZXggZnJvbSB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgZ3JpZC5cbiAgICAvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXG4gICAgLy8gSWYgYmVmb3JlIHRoZSBmaXJzdCBvZmZzZXQsIHJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gICAgLy8gSWYgYWZ0ZXIgdGhlIGxhc3Qgb2Zmc2V0LCByZXR1cm5zIGFuIG9mZnNldCBwYXN0IHRoZSBsYXN0IGNlbGwgb2Zmc2V0LlxuICAgIC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxuICAgIGdldERhdGVEYXlJbmRleChkYXRlKSB7XG4gICAgICAgIGxldCB7IGluZGljZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkYXlPZmZzZXQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRoaXMuZGF0ZXNbMF0sIGRhdGUpKTtcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzWzBdIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlc1tkYXlPZmZzZXRdO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGVNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoZGF5U2VyaWVzLCBicmVha09uV2Vla3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZXMgfSA9IGRheVNlcmllcztcbiAgICAgICAgbGV0IGRheXNQZXJSb3c7XG4gICAgICAgIGxldCBmaXJzdERheTtcbiAgICAgICAgbGV0IHJvd0NudDtcbiAgICAgICAgaWYgKGJyZWFrT25XZWVrcykge1xuICAgICAgICAgICAgLy8gY291bnQgY29sdW1ucyB1bnRpbCB0aGUgZGF5LW9mLXdlZWsgcmVwZWF0c1xuICAgICAgICAgICAgZmlyc3REYXkgPSBkYXRlc1swXS5nZXRVVENEYXkoKTtcbiAgICAgICAgICAgIGZvciAoZGF5c1BlclJvdyA9IDE7IGRheXNQZXJSb3cgPCBkYXRlcy5sZW5ndGg7IGRheXNQZXJSb3cgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRlc1tkYXlzUGVyUm93XS5nZXRVVENEYXkoKSA9PT0gZmlyc3REYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Q250ID0gTWF0aC5jZWlsKGRhdGVzLmxlbmd0aCAvIGRheXNQZXJSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm93Q250ID0gMTtcbiAgICAgICAgICAgIGRheXNQZXJSb3cgPSBkYXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dDbnQgPSByb3dDbnQ7XG4gICAgICAgIHRoaXMuY29sQ250ID0gZGF5c1BlclJvdztcbiAgICAgICAgdGhpcy5kYXlTZXJpZXMgPSBkYXlTZXJpZXM7XG4gICAgICAgIHRoaXMuY2VsbHMgPSB0aGlzLmJ1aWxkQ2VsbHMoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJEYXRlcyA9IHRoaXMuYnVpbGRIZWFkZXJEYXRlcygpO1xuICAgIH1cbiAgICBidWlsZENlbGxzKCkge1xuICAgICAgICBsZXQgcm93cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnJvd0NudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjZWxscyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCh0aGlzLmJ1aWxkQ2VsbChyb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93cy5wdXNoKGNlbGxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93cztcbiAgICB9XG4gICAgYnVpbGRDZWxsKHJvdywgY29sKSB7XG4gICAgICAgIGxldCBkYXRlID0gdGhpcy5kYXlTZXJpZXMuZGF0ZXNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZEhlYWRlckRhdGVzKCkge1xuICAgICAgICBsZXQgZGF0ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBkYXRlcy5wdXNoKHRoaXMuY2VsbHNbMF1bY29sXS5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfVxuICAgIHNsaWNlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgY29sQ250IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VyaWVzU2VnID0gdGhpcy5kYXlTZXJpZXMuc2xpY2VSYW5nZShyYW5nZSk7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGlmIChzZXJpZXNTZWcpIHtcbiAgICAgICAgICAgIGxldCB7IGZpcnN0SW5kZXgsIGxhc3RJbmRleCB9ID0gc2VyaWVzU2VnO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gZmlyc3RJbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbENudCk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRJbmRleCA9IE1hdGgubWluKChyb3cgKyAxKSAqIGNvbENudCwgbGFzdEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbDogaW5kZXggJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb2w6IChuZXh0SW5kZXggLSAxKSAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VyaWVzU2VnLmlzU3RhcnQgJiYgaW5kZXggPT09IGZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZXJpZXNTZWcuaXNFbmQgJiYgKG5leHRJbmRleCAtIDEpID09PSBsYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuXG5jbGFzcyBTbGljZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gZmFsc2U7IC8vIGhhY2tcbiAgICB9XG4gICAgc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBsZXQgeyBldmVudFVpQmFzZXMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgZXZlbnRVaUJhc2VzLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMocHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxuICAgICAgICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogdGhpcy5zbGljZUV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cbiAgICB9XG4gICAgc2xpY2VOb3dEYXRlKC8vIGRvZXMgbm90IG1lbW9pemVcbiAgICBkYXRlLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zbGljZURhdGVTcGFuKHsgcmFuZ2U6IHsgc3RhcnQ6IGRhdGUsIGVuZDogYWRkTXMoZGF0ZSwgMSkgfSwgYWxsRGF5OiBmYWxzZSB9LCAvLyBhZGQgMSBtcywgcHJvdGVjdCBhZ2FpbnN0IG51bGwgcmFuZ2VcbiAgICAgICAgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIHt9LCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpO1xuICAgIH1cbiAgICBfc2xpY2VCdXNpbmVzc0hvdXJzKGJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRXZlbnRTdG9yZShleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3VycywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgY29udGV4dCksIHt9LCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKS5iZztcbiAgICB9XG4gICAgX3NsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH07XG4gICAgfVxuICAgIF9zbGljZUludGVyYWN0aW9uKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWdzOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzLFxuICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3NsaWNlRGF0ZVNwYW4oZGF0ZVNwYW4sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGl2ZVJhbmdlID0gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKTtcbiAgICAgICAgbGV0IGFjdGl2ZURhdGVTcGFuUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZGF0ZVNwYW4ucmFuZ2UsIGFjdGl2ZVJhbmdlKTtcbiAgICAgICAgaWYgKGFjdGl2ZURhdGVTcGFuUmFuZ2UpIHtcbiAgICAgICAgICAgIGRhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3BhbiksIHsgcmFuZ2U6IGFjdGl2ZURhdGVTcGFuUmFuZ2UgfSk7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlU3Bhbi5yYW5nZSwgLi4uZXh0cmFBcmdzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgc2xpY2VFdmVudFJhbmdlcyhldmVudFJhbmdlcywgZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcbiAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLnNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIHNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IGRhdGVSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgICAgIC8vIGhhY2sgdG8gbWFrZSBtdWx0aS1kYXkgZXZlbnRzIHRoYXQgYXJlIGJlaW5nIGZvcmNlLWRpc3BsYXllZCBhcyBsaXN0LWl0ZW1zIHRvIHRha2UgdXAgb25seSBvbmUgZGF5XG4gICAgICAgIGlmICh0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSAmJiBldmVudFJhbmdlLnVpLmRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nKSB7XG4gICAgICAgICAgICBkYXRlUmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVSYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF0ZVJhbmdlLnN0YXJ0LCAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnLmlzU3RhcnQ7XG4gICAgICAgICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG59XG4vKlxuZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcblRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxuVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcbiovXG5mdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxuICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpLCAvLyA4NjRlNSA9IG1zIGluIGEgZGF5XG4gICAgfTtcbn1cblxuLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCB7IGluc3RhbmNlcyB9ID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cztcbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGV2ZW50RHJhZzogaW50ZXJhY3Rpb24gfSwgY29udGV4dCk7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xufVxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNOZXdQcm9wc1ZhbGlkKG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGJ1c2luZXNzSG91cnM6IGNhbGVuZGFyU3RhdGUuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogJycsIGV2ZW50U3RvcmU6IGNhbGVuZGFyU3RhdGUuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBjYWxlbmRhclN0YXRlLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246ICcnLCBldmVudERyYWc6IG51bGwsIGV2ZW50UmVzaXplOiBudWxsIH0sIG5ld1Byb3BzKTtcbiAgICByZXR1cm4gKGNvbnRleHQucGx1Z2luSG9va3MuaXNQcm9wc1ZhbGlkIHx8IGlzUHJvcHNWYWxpZCkocHJvcHMsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNQcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEgPSB7fSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIE1vdmluZyBFdmVudCBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIGxldCBjdXJyZW50U3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgbGV0IGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbiAgICBsZXQgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIGxldCBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnM7XG4gICAgbGV0IHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKHN1YmplY3REZWZzLCBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cbiAgICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcbiAgICAgICAgeyAnJzogY3VycmVudFN0YXRlLnNlbGVjdGlvbkNvbmZpZyB9KTtcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKTtcbiAgICB9XG4gICAgLy8gZXhjbHVkZSB0aGUgc3ViamVjdCBldmVudHMuIFRPRE86IGV4Y2x1ZGUgZGVmcyB0b28/XG4gICAgbGV0IG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKTtcbiAgICBsZXQgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XG4gICAgbGV0IG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKGxldCBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgbGV0IHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBsZXQgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGNvbnN0cmFpbnRcbiAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3ZlcmxhcFxuICAgICAgICBsZXQgeyBldmVudE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgbGV0IGV2ZW50T3ZlcmxhcEZ1bmMgPSB0eXBlb2YgZXZlbnRPdmVybGFwID09PSAnZnVuY3Rpb24nID8gZXZlbnRPdmVybGFwIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2VzW290aGVySW5zdGFuY2VJZF07XG4gICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJPdmVybGFwID0gb3RoZXJDb25maWdzW290aGVySW5zdGFuY2UuZGVmSWRdLm92ZXJsYXA7XG4gICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Mgb3ZlcmxhcC4gb25seSBkbyB0aGlzIGlmIHRoZSBzdWJqZWN0IGV2ZW50IGlzIGEgXCJyZWFsXCIgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRPdmVybGFwRnVuYyAmJiAhZXZlbnRPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG90aGVyRGVmc1tvdGhlckluc3RhbmNlLmRlZklkXSwgb3RoZXJJbnN0YW5jZSksIC8vIHN0aWxsIGV2ZW50XG4gICAgICAgICAgICAgICAgbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgICAgICBsZXQgY2FsZW5kYXJFdmVudFN0b3JlID0gY3VycmVudFN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXG4gICAgICAgIGZvciAobGV0IHN1YmplY3RBbGxvdyBvZiBzdWJqZWN0Q29uZmlnLmFsbG93cykge1xuICAgICAgICAgICAgbGV0IHN1YmplY3REYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgeyByYW5nZTogc3ViamVjdEluc3RhbmNlLnJhbmdlLCBhbGxEYXk6IHN1YmplY3REZWYuYWxsRGF5IH0pO1xuICAgICAgICAgICAgbGV0IG9yaWdEZWYgPSBjYWxlbmRhckV2ZW50U3RvcmUuZGVmc1tzdWJqZWN0RGVmLmRlZklkXTtcbiAgICAgICAgICAgIGxldCBvcmlnSW5zdGFuY2UgPSBjYWxlbmRhckV2ZW50U3RvcmUuaW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGxldCBldmVudEFwaTtcbiAgICAgICAgICAgIGlmIChvcmlnRGVmKSB7IC8vIHdhcyBwcmV2aW91c2x5IGluIHRoZSBjYWxlbmRhclxuICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN1YmplY3RBbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc3ViamVjdERhdGVTcGFuLCBjb250ZXh0KSwgZXZlbnRBcGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gRGF0ZSBTZWxlY3Rpb24gVmFsaWRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIGxldCByZWxldmFudEV2ZW50U3RvcmUgPSBzdGF0ZS5ldmVudFN0b3JlO1xuICAgIGxldCByZWxldmFudERlZnMgPSByZWxldmFudEV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZXMgPSByZWxldmFudEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBzZWxlY3Rpb24gPSBzdGF0ZS5kYXRlU2VsZWN0aW9uO1xuICAgIGxldCBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZTtcbiAgICBsZXQgeyBzZWxlY3Rpb25Db25maWcgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZyA9IGZpbHRlckNvbmZpZyhzZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICAvLyBjb25zdHJhaW50XG4gICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG92ZXJsYXBcbiAgICBsZXQgeyBzZWxlY3RPdmVybGFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgbGV0IHNlbGVjdE92ZXJsYXBGdW5jID0gdHlwZW9mIHNlbGVjdE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RPdmVybGFwIDogbnVsbDtcbiAgICBmb3IgKGxldCByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xuICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksIG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgIGZvciAobGV0IHNlbGVjdGlvbkFsbG93IG9mIHNlbGVjdGlvbkNvbmZpZy5hbGxvd3MpIHtcbiAgICAgICAgbGV0IGZ1bGxEYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIENvbnN0cmFpbnQgVXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpIHtcbiAgICBmb3IgKGxldCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIGlmICghYW55UmFuZ2VzQ29udGFpblJhbmdlKGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLCBzdWJqZWN0UmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xub3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXG5idXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXG5jb250ZXh0KSB7XG4gICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2Vcbn1cbi8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cbmZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XG4gICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICByYW5nZXMucHVzaChpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XG5mdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcbiAgICBmb3IgKGxldCBvdXRlclJhbmdlIG9mIG91dGVyUmFuZ2VzKSB7XG4gICAgICAgIGlmIChyYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgVklTSUJMRV9ISURERU5fUkUgPSAvXih2aXNpYmxlfGhpZGRlbikkLztcbmNsYXNzIFNjcm9sbGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGxpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ107XG4gICAgICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxuICAgICAgICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxuICAgICAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBuZWVkc1hTY3JvbGxpbmcoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsV2lkdGg+Y2xpZW50V2lkdGggaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlYWxDbGllbnRXaWR0aCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSB0aGlzLmdldFlTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmVlZHNZU2Nyb2xsaW5nKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbEhlaWdodD5jbGllbnRIZWlnaHQgaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlYWxDbGllbnRIZWlnaHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAtIHRoaXMuZ2V0WFNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFhTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSB0aGlzLmVsLmNsaWVudEhlaWdodDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH1cbiAgICBnZXRZU2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0V2lkdGggLSB0aGlzLmVsLmNsaWVudFdpZHRoOyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfVxufVxuXG4vKlxuVE9ETzogc29tZWhvdyBpbmZlciBPdGhlckFyZ3MgZnJvbSBtYXN0ZXJDYWxsYmFjaz9cblRPRE86IGluZmVyIFJlZlR5cGUgZnJvbSBtYXN0ZXJDYWxsYmFjayBpZiBwcm92aWRlZFxuKi9cbmNsYXNzIFJlZk1hcCB7XG4gICAgY29uc3RydWN0b3IobWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayA9IG1hc3RlckNhbGxiYWNrO1xuICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5kZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFja01hcCA9IHt9O1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkZXB0aHMsIGN1cnJlbnRNYXAgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGJ1Zy4uLiBBQ1RVQUxMWTogY2FuIHByb2JhYmx5IGRvIGF3YXkgd2l0aCB0aGlzIG5vdyB0aGF0IGNhbGxlcnMgZG9uJ3Qgc2hhcmUgbnVtZXJpYyBpbmRpY2VzIGFueW1vcmVcbiAgICAgICAgICAgICAgICByZW1vdmVkID0gKGtleSBpbiBjdXJyZW50TWFwKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFwW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gPSAoZGVwdGhzW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoc1trZXldIC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudE1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tYXN0ZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sobnVsbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZVJlZihrZXkpIHtcbiAgICAgICAgbGV0IHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICBpZiAoIXJlZkNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZWZDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tNYXBba2V5XSA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVZhbHVlKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmQ2FsbGJhY2s7XG4gICAgfVxuICAgIC8vIFRPRE86IGNoZWNrIGNhbGxlcnMgdGhhdCBkb24ndCBjYXJlIGFib3V0IG9yZGVyLiBzaG91bGQgdXNlIGdldEFsbCBpbnN0ZWFkXG4gICAgLy8gTk9URTogdGhpcyBtZXRob2QgaGFzIGJlY29tZSBsZXNzIHZhbHVhYmxlIG5vdyB0aGF0IHdlIGFyZSBlbmNvdXJhZ2VkIHRvIG1hcCBvcmRlciBieSBzb21lIG90aGVyIGluZGV4XG4gICAgLy8gVE9ETzogcHJvdmlkZSBPTkUgYXJyYXktZXhwb3J0IGZ1bmN0aW9uLCBidWlsZEFycmF5LCB3aGljaCBmYWlscyBvbiBub24tbnVtZXJpYyBpbmRleGVzLiBjYWxsZXIgY2FuIG1hbmlwdWxhdGUgYW5kIFwiY29sbGVjdFwiXG4gICAgY29sbGVjdChzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdEZyb21IYXNoKHRoaXMuY3VycmVudE1hcCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApO1xuICAgIH1cbiAgICBnZXRBbGwoKSB7XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWVzVG9BcnJheSh0aGlzLmN1cnJlbnRNYXApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNocmlua1dpZHRoKGNodW5rRWxzKSB7XG4gICAgbGV0IHNocmlua0NlbGxzID0gZmluZEVsZW1lbnRzKGNodW5rRWxzLCAnLmZjLXNjcm9sbGdyaWQtc2hyaW5rJyk7XG4gICAgbGV0IGxhcmdlc3RXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgc2hyaW5rQ2VsbCBvZiBzaHJpbmtDZWxscykge1xuICAgICAgICBsYXJnZXN0V2lkdGggPSBNYXRoLm1heChsYXJnZXN0V2lkdGgsIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChzaHJpbmtDZWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwobGFyZ2VzdFdpZHRoKTsgLy8gPHRhYmxlPiBlbGVtZW50cyB3b3JrIGJlc3Qgd2l0aCBpbnRlZ2Vycy4gcm91bmQgdXAgdG8gZW5zdXJlIGNvbnRlbnRzIGZpdHNcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gcHJvcHMubGlxdWlkICYmIHNlY3Rpb25Db25maWcubGlxdWlkOyAvLyBkb2VzIHRoZSBzZWN0aW9uIGRvIGxpcXVpZC1oZWlnaHQ/IChuZWVkIHRvIGhhdmUgd2hvbGUgc2Nyb2xsZ3JpZCBsaXF1aWQtaGVpZ2h0IGFzIHdlbGwpXG59XG5mdW5jdGlvbiBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgIT0gbnVsbCB8fCAvLyBpZiBpdHMgcG9zc2libGUgZm9yIHRoZSBoZWlnaHQgdG8gbWF4IG91dCwgd2UgbWlnaHQgbmVlZCBzY3JvbGxiYXJzXG4gICAgICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpOyAvLyBpZiB0aGUgc2VjdGlvbiBpcyBsaXF1aWQgaGVpZ2h0LCBpdCBtaWdodCBjb25kZW5zZSBlbm91Z2ggdG8gcmVxdWlyZSBzY3JvbGxiYXJzXG59XG4vLyBUT0RPOiBPTkxZIHVzZSBgYXJnYC4gZm9yY2Ugb3V0IGludGVybmFsIGZ1bmN0aW9uIHRvIHVzZSBzYW1lIEFQSVxuZnVuY3Rpb24gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCBhcmcsIGlzSGVhZGVyKSB7XG4gICAgbGV0IHsgZXhwYW5kUm93cyB9ID0gYXJnO1xuICAgIGxldCBjb250ZW50ID0gdHlwZW9mIGNodW5rQ29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjaHVua0NvbmZpZy5jb250ZW50KGFyZykgOlxuICAgICAgICBjcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgY2h1bmtDb25maWcudGFibGVDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgc2VjdGlvbkNvbmZpZy5zeW5jUm93SGVpZ2h0cyA/ICdmYy1zY3JvbGxncmlkLXN5bmMtdGFibGUnIDogJycsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnLCAvLyBjc3MgYGhlaWdodGAgb24gYSA8dGFibGU+IHNlcnZlcyBhcyBhIG1pbi1oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFyZy50YWJsZUNvbEdyb3VwTm9kZSwgY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aGVhZCcgOiAndGJvZHknLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgdHlwZW9mIGNodW5rQ29uZmlnLnJvd0NvbnRlbnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2h1bmtDb25maWcucm93Q29udGVudChhcmcpXG4gICAgICAgICAgICA6IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQpKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIGlzQ29sUHJvcHNFcXVhbChjb2xzMCwgY29sczEpIHtcbiAgICByZXR1cm4gaXNBcnJheXNFcXVhbChjb2xzMCwgY29sczEsIGlzUHJvcHNFcXVhbCk7XG59XG5mdW5jdGlvbiByZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHNocmlua1dpZHRoKSB7XG4gICAgbGV0IGNvbE5vZGVzID0gW107XG4gICAgLypcbiAgICBmb3IgQ29sUHJvcHMgd2l0aCBzcGFucywgaXQgd291bGQgaGF2ZSBiZWVuIGdyZWF0IHRvIG1ha2UgYSBzaW5nbGUgPGNvbCBzcGFuPVwiXCI+XG4gICAgSE9XRVZFUiwgQ2hyb21lIHdhcyBnZXR0aW5nIG1lc3NpbmcgdXAgZGlzdHJpYnV0aW5nIHRoZSB3aWR0aCB0byA8dGQ+Lzx0aD4gZWxlbWVudHMgd2l0aCBjb2xzcGFucy5cbiAgICBTT0xVVElPTjogbWFraW5nIGluZGl2aWR1YWwgPGNvbD4gZWxlbWVudHMgbWFrZXMgQ2hyb21lIGJlaGF2ZS5cbiAgICAqL1xuICAgIGZvciAobGV0IGNvbFByb3BzIG9mIGNvbHMpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBjb2xQcm9wcy5zcGFuIHx8IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb2xOb2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJjb2xcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sUHJvcHMud2lkdGggPT09ICdzaHJpbmsnID8gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkgOiAoY29sUHJvcHMud2lkdGggfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogY29sUHJvcHMubWluV2lkdGggfHwgJycsXG4gICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2NvbGdyb3VwJywge30sIC4uLmNvbE5vZGVzKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIHtcbiAgICAvKiB3aHkgND8gaWYgd2UgZG8gMCwgaXQgd2lsbCBraWxsIGFueSBib3JkZXIsIHdoaWNoIGFyZSBuZWVkZWQgZm9yIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aFxuICAgIDQgYWNjb3VudHMgZm9yIDIgMi1waXhlbCBib3JkZXJzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb24/ICovXG4gICAgcmV0dXJuIHNocmlua1dpZHRoID09IG51bGwgPyA0IDogc2hyaW5rV2lkdGg7XG59XG5mdW5jdGlvbiBoYXNTaHJpbmtXaWR0aChjb2xzKSB7XG4gICAgZm9yIChsZXQgY29sIG9mIGNvbHMpIHtcbiAgICAgICAgaWYgKGNvbC53aWR0aCA9PT0gJ3NocmluaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKGxpcXVpZCwgY29udGV4dCkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZCcsXG4gICAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gICAgXTtcbiAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1saXF1aWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB3aG9sZVRhYmxlVkdyb3cpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbicsXG4gICAgICAgIGBmYy1zY3JvbGxncmlkLXNlY3Rpb24tJHtzZWN0aW9uQ29uZmlnLnR5cGV9YCxcbiAgICAgICAgc2VjdGlvbkNvbmZpZy5jbGFzc05hbWUsIC8vIHVzZWQ/XG4gICAgXTtcbiAgICBpZiAod2hvbGVUYWJsZVZHcm93ICYmIHNlY3Rpb25Db25maWcubGlxdWlkICYmIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkJyk7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uQ29uZmlnLmlzU3RpY2t5KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIHJlbmRlclNjcm9sbFNoaW0oYXJnKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3RpY2t5LXNoaW1cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgIH0gfSkpO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMob3B0aW9ucykge1xuICAgIGxldCB7IHN0aWNreUhlYWRlckRhdGVzIH0gPSBvcHRpb25zO1xuICAgIGlmIChzdGlja3lIZWFkZXJEYXRlcyA9PSBudWxsIHx8IHN0aWNreUhlYWRlckRhdGVzID09PSAnYXV0bycpIHtcbiAgICAgICAgc3RpY2t5SGVhZGVyRGF0ZXMgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5SGVhZGVyRGF0ZXM7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIob3B0aW9ucykge1xuICAgIGxldCB7IHN0aWNreUZvb3RlclNjcm9sbGJhciB9ID0gb3B0aW9ucztcbiAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID09IG51bGwgfHwgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID09PSAnYXV0bycpIHtcbiAgICAgICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNreUZvb3RlclNjcm9sbGJhcjtcbn1cblxuY2xhc3MgU2ltcGxlU2Nyb2xsR3JpZCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb2xzID0gbWVtb2l6ZSgoYSkgPT4gYSwgaXNDb2xQcm9wc0VxdWFsKTsgLy8gc28gd2UgZ2V0IHNhbWUgYGNvbHNgIHByb3BzIGV2ZXJ5IHRpbWVcbiAgICAgICAgLy8geXVja3kgdG8gbWVtb2l6ZSBWTm9kZXMsIGJ1dCBtdWNoIG1vcmUgZWZmaWNpZW50IGZvciBjb25zdW1lcnNcbiAgICAgICAgdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwID0gbWVtb2l6ZShyZW5kZXJNaWNyb0NvbEdyb3VwKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJFbFJlZnMgPSBuZXcgUmVmTWFwKHRoaXMuX2hhbmRsZVNjcm9sbGVyRWwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzaHJpbmtXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnM6IGZhbHNlLFxuICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHt9LFxuICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogY2FuIGRvIGEgcmVhbGx5IHNpbXBsZSBwcmludC12aWV3LiBkb250IG5lZWQgdG8gam9pbiByb3dzXG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7IHNocmlua1dpZHRoOiB0aGlzLmNvbXB1dGVTaHJpbmtXaWR0aCgpIH0sIHRoaXMuY29tcHV0ZVNjcm9sbGVyRGltcygpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VjdGlvbkNvbmZpZ3MgPSBwcm9wcy5zZWN0aW9ucyB8fCBbXTtcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpO1xuICAgICAgICBsZXQgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKHByb3BzLmxpcXVpZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChwcm9wcy5jb2xsYXBzaWJsZVdpZHRoKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtY29sbGFwc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBtYWtlIERSWVxuICAgICAgICBsZXQgY29uZmlnQ250ID0gc2VjdGlvbkNvbmZpZ3MubGVuZ3RoO1xuICAgICAgICBsZXQgY29uZmlnSSA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50Q29uZmlnO1xuICAgICAgICBsZXQgaGVhZFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICBsZXQgYm9keVNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICBsZXQgZm9vdFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnaGVhZGVyJykge1xuICAgICAgICAgICAgaGVhZFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xuICAgICAgICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcmVmb3ggYnVnOiB3aGVuIHNldHRpbmcgaGVpZ2h0IG9uIHRhYmxlIGFuZCB0aGVyZSBpcyBhIHRoZWFkIG9yIHRmb290LFxuICAgICAgICAvLyB0aGUgbmVjZXNzYXJ5IGhlaWdodDoxMDAlIG9uIHRoZSBsaXF1aWQtaGVpZ2h0IGJvZHkgc2VjdGlvbiBmb3JjZXMgdGhlICp3aG9sZSogdGFibGUgdG8gYmUgdGFsbGVyLiAoYnVnICM1NTI0KVxuICAgICAgICAvLyB1c2UgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGEgd2F5IHRvIGRldGVjdCB0YWJsZS1zdHVwaWQgZmlyZWZveC5cbiAgICAgICAgLy8gaWYgc28sIHVzZSBhIHNpbXBsZXIgZG9tIHN0cnVjdHVyZSwgamFtIGV2ZXJ5dGhpbmcgaW50byBhIGxvbmUgdGJvZHkuXG4gICAgICAgIGxldCBpc0J1Z2d5ID0gIWdldENhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgICAgICBjb25zdCByb2xlQXR0cnMgPSB7IHJvbGU6ICdyb3dncm91cCcgfTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ2dyaWQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH0sXG4gICAgICAgIH0sIEJvb2xlYW4oIWlzQnVnZ3kgJiYgaGVhZFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3RoZWFkJywgcm9sZUF0dHJzLCAuLi5oZWFkU2VjdGlvbk5vZGVzKSwgQm9vbGVhbighaXNCdWdneSAmJiBib2R5U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGJvZHknLCByb2xlQXR0cnMsIC4uLmJvZHlTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGZvb3RTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Zm9vdCcsIHJvbGVBdHRycywgLi4uZm9vdFNlY3Rpb25Ob2RlcyksIGlzQnVnZ3kgJiYgY3JlYXRlRWxlbWVudCgndGJvZHknLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMsIC4uLmJvZHlTZWN0aW9uTm9kZXMsIC4uLmZvb3RTZWN0aW9uTm9kZXMpKTtcbiAgICB9XG4gICAgcmVuZGVyU2VjdGlvbihzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5IH0sIHNlY3Rpb25Db25maWcub3V0ZXJDb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5LCByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHRoaXMucHJvcHMubGlxdWlkKS5qb2luKCcgJykgfSwgdGhpcy5yZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBzZWN0aW9uQ29uZmlnLmNodW5rLCBpc0hlYWRlcikpKTtcbiAgICB9XG4gICAgcmVuZGVyQ2h1bmtUZChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgY2h1bmtDb25maWcsIGlzSGVhZGVyKSB7XG4gICAgICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBjaHVua0NvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rQ29uZmlnLm91dGVyQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzWVNjcm9sbGluZyA9IGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIFRPRE86IGRvIGxhemlseS4gZG8gaW4gc2VjdGlvbiBjb25maWc/XG4gICAgICAgIGxldCBpc0xpcXVpZCA9IGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpO1xuICAgICAgICAvLyBmb3IgYCFwcm9wcy5saXF1aWRgIC0gaXMgV0hPTEUgc2Nyb2xsZ3JpZCBuYXR1cmFsIGhlaWdodD9cbiAgICAgICAgLy8gVE9ETzogZG8gc2FtZSB0aGluZyBpbiBhZHZhbmNlZCBzY3JvbGxncmlkPyBwcm9sbHkgbm90IGIvYyBhbHdheXMgaGFzIGhvcml6b250YWwgc2Nyb2xsYmFyc1xuICAgICAgICBsZXQgb3ZlcmZsb3dZID0gIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6XG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID8gJ3Njcm9sbCcgOlxuICAgICAgICAgICAgICAgICFuZWVkc1lTY3JvbGxpbmcgPyAnaGlkZGVuJyA6XG4gICAgICAgICAgICAgICAgICAgICdhdXRvJztcbiAgICAgICAgbGV0IHNlY3Rpb25LZXkgPSBzZWN0aW9uQ29uZmlnLmtleTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIHtcbiAgICAgICAgICAgIHRhYmxlQ29sR3JvdXBOb2RlOiBtaWNyb0NvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgIHRhYmxlTWluV2lkdGg6ICcnLFxuICAgICAgICAgICAgY2xpZW50V2lkdGg6ICghcHJvcHMuY29sbGFwc2libGVXaWR0aCAmJiBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkKSA/IHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQgPyBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgZXhwYW5kUm93czogc2VjdGlvbkNvbmZpZy5leHBhbmRSb3dzLFxuICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IGZhbHNlLFxuICAgICAgICAgICAgcm93U3luY0hlaWdodHM6IFtdLFxuICAgICAgICAgICAgcmVwb3J0Um93SGVpZ2h0Q2hhbmdlOiAoKSA9PiB7IH0sXG4gICAgICAgIH0sIGlzSGVhZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGgnIDogJ3RkJywge1xuICAgICAgICAgICAgcmVmOiBjaHVua0NvbmZpZy5lbFJlZixcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgZmMtc2Nyb2xsZXItaGFybmVzcyR7aXNMaXF1aWQgPyAnIGZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlkJyA6ICcnfWAgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsZXIsIHsgcmVmOiB0aGlzLnNjcm9sbGVyUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIGVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgb3ZlcmZsb3dZOiBvdmVyZmxvd1ksIG92ZXJmbG93WDogIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nIC8qIG5hdHVyYWwgaGVpZ2h0PyAqLywgbWF4SGVpZ2h0OiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCwgbGlxdWlkOiBpc0xpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSAvLyBiZWNhdXNlIGl0cyB3aXRoaW4gYSBoYXJuZXNzXG4gICAgICAgICAgICAgICAgOiB0cnVlIH0sIGNvbnRlbnQpKSk7XG4gICAgfVxuICAgIF9oYW5kbGVTY3JvbGxlckVsKHNjcm9sbGVyRWwsIGtleSkge1xuICAgICAgICBsZXQgc2VjdGlvbiA9IGdldFNlY3Rpb25CeUtleSh0aGlzLnByb3BzLnNlY3Rpb25zLCBrZXkpO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgc2V0UmVmKHNlY3Rpb24uY2h1bmsuc2Nyb2xsZXJFbFJlZiwgc2Nyb2xsZXJFbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBUT0RPOiBuZWVkIGJldHRlciBzb2x1dGlvbiB3aGVuIHN0YXRlIGNvbnRhaW5zIG5vbi1zaXppbmcgdGhpbmdzXG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZyk7XG4gICAgfVxuICAgIGNvbXB1dGVTaHJpbmtXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc1Nocmlua1dpZHRoKHRoaXMucHJvcHMuY29scylcbiAgICAgICAgICAgID8gY29tcHV0ZVNocmlua1dpZHRoKHRoaXMuc2Nyb2xsZXJFbFJlZnMuZ2V0QWxsKCkpXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIGNvbXB1dGVTY3JvbGxlckRpbXMoKSB7XG4gICAgICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRocygpO1xuICAgICAgICBsZXQgeyBzY3JvbGxlclJlZnMsIHNjcm9sbGVyRWxSZWZzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZm9yY2VZU2Nyb2xsYmFycyA9IGZhbHNlO1xuICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRXaWR0aHMgPSB7fTtcbiAgICAgICAgbGV0IHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBzZWN0aW9uS2V5IGluIHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwKSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXIgPSBzY3JvbGxlclJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlciAmJiBzY3JvbGxlci5uZWVkc1lTY3JvbGxpbmcoKSkge1xuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlY3Rpb24gb2YgdGhpcy5wcm9wcy5zZWN0aW9ucykge1xuICAgICAgICAgICAgbGV0IHNlY3Rpb25LZXkgPSBzZWN0aW9uLmtleTtcbiAgICAgICAgICAgIGxldCBzY3JvbGxlckVsID0gc2Nyb2xsZXJFbFJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhcm5lc3NFbCA9IHNjcm9sbGVyRWwucGFyZW50Tm9kZTsgLy8gVE9ETzogd2VpcmQgd2F5IHRvIGdldCB0aGlzLiBuZWVkIGhhcm5lc3MgYi9jIGRvZXNuJ3QgaW5jbHVkZSB0YWJsZSBib3JkZXJzXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIChmb3JjZVlTY3JvbGxiYXJzXG4gICAgICAgICAgICAgICAgICAgID8gc2Nyb2xsYmFyV2lkdGgueSAvLyB1c2UgZ2xvYmFsIGJlY2F1c2Ugc2Nyb2xsZXIgbWlnaHQgbm90IGhhdmUgc2Nyb2xsYmFycyB5ZXQgYnV0IHdpbGwgbmVlZCB0aGVtIGluIGZ1dHVyZVxuICAgICAgICAgICAgICAgICAgICA6IDApKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHMgfTtcbiAgICB9XG59XG5TaW1wbGVTY3JvbGxHcmlkLmFkZFN0YXRlRXF1YWxpdHkoe1xuICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiBpc1Byb3BzRXF1YWwsXG4gICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiBpc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGdldFNlY3Rpb25CeUtleShzZWN0aW9ucywga2V5KSB7XG4gICAgZm9yIChsZXQgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICBpZiAoc2VjdGlvbi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIEV2ZW50Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIHNldEVsU2VnKGVsLCB0aGlzLnByb3BzLnNlZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRSYW5nZSB9ID0gc2VnO1xuICAgICAgICBjb25zdCB7IHVpIH0gPSBldmVudFJhbmdlO1xuICAgICAgICBjb25zdCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIHRpbWVUZXh0OiBwcm9wcy50aW1lVGV4dCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogdWkudGV4dENvbG9yLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBpc0RyYWdnYWJsZTogIXByb3BzLmRpc2FibGVEcmFnZ2luZyAmJiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc1N0YXJ0UmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgICAgICAgaXNFbmRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcpLFxuICAgICAgICAgICAgaXNNaXJyb3I6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyB8fCBwcm9wcy5pc1Jlc2l6aW5nIHx8IHByb3BzLmlzRGF0ZVNlbGVjdGluZyksXG4gICAgICAgICAgICBpc1N0YXJ0OiBCb29sZWFuKHNlZy5pc1N0YXJ0KSxcbiAgICAgICAgICAgIGlzRW5kOiBCb29sZWFuKHNlZy5pc0VuZCksXG4gICAgICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4ocHJvcHMuaXNQYXN0KSxcbiAgICAgICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKHByb3BzLmlzRnV0dXJlKSxcbiAgICAgICAgICAgIGlzVG9kYXk6IEJvb2xlYW4ocHJvcHMuaXNUb2RheSksXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiBCb29sZWFuKHByb3BzLmlzU2VsZWN0ZWQpLFxuICAgICAgICAgICAgaXNEcmFnZ2luZzogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nKSxcbiAgICAgICAgICAgIGlzUmVzaXppbmc6IEJvb2xlYW4ocHJvcHMuaXNSZXNpemluZyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBjb250YWlucyBjaGlsZHJlbiAqLywgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uZ2V0RXZlbnRDbGFzc05hbWVzKHJlbmRlclByb3BzKSxcbiAgICAgICAgICAgICAgICAuLi5zZWcuZXZlbnRSYW5nZS51aS5jbGFzc05hbWVzLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImV2ZW50Q29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZXZlbnRDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiBwcm9wcy5kZWZhdWx0R2VuZXJhdG9yLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5ldmVudERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ldmVudFdpbGxVbm1vdW50IH0pKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgdGhpcy5wcm9wcy5zZWcgIT09IHByZXZQcm9wcy5zZWcpIHtcbiAgICAgICAgICAgIHNldEVsU2VnKHRoaXMuZWwsIHRoaXMucHJvcHMuc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gc2hvdWxkIG5vdCBiZSBhIHB1cmVjb21wb25lbnRcbmNsYXNzIFN0YW5kYXJkRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdFRpbWVGb3JtYXQ7XG4gICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50VGltZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgZWxSZWYgKi8sIHsgZWxUYWc6IFwiYVwiLCBlbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgfSwgZWxBdHRyczogZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50JDEsIHRpbWVUZXh0OiB0aW1lVGV4dCB9KSwgKElubmVyQ29udGVudCwgZXZlbnRDb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtZXZlbnQtbWFpbiddLCBlbFN0eWxlOiB7IGNvbG9yOiBldmVudENvbnRlbnRBcmcudGV4dENvbG9yIH0gfSksXG4gICAgICAgICAgICBCb29sZWFuKGV2ZW50Q29udGVudEFyZy5pc1N0YXJ0UmVzaXphYmxlKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItc3RhcnRcIiB9KSksXG4gICAgICAgICAgICBCb29sZWFuKGV2ZW50Q29udGVudEFyZy5pc0VuZFJlc2l6YWJsZSkgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLWVuZFwiIH0pKSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDEoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1tYWluLWZyYW1lXCIgfSxcbiAgICAgICAgaW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlIGZjLXN0aWNreVwiIH0sIGlubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgXCJcXHUwMEEwXCIpKSkpKTtcbn1cblxuY29uc3QgTm93SW5kaWNhdG9yQ29udGFpbmVyID0gKHByb3BzKSA9PiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgIGlzQXhpczogcHJvcHMuaXNBeGlzLFxuICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibm93SW5kaWNhdG9yQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMubm93SW5kaWNhdG9yQ29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm5vd0luZGljYXRvckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JXaWxsVW5tb3VudCB9KSkpO1xufSkpO1xuXG5jb25zdCBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pO1xuY2xhc3MgRGF5Q2VsbENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJlZmluZVJlbmRlclByb3BzID0gbWVtb2l6ZU9iakFyZyhyZWZpbmVSZW5kZXJQcm9wcyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHRoaXMucmVmaW5lUmVuZGVyUHJvcHMoe1xuICAgICAgICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXG4gICAgICAgICAgICBpc01vbnRoU3RhcnQ6IHByb3BzLmlzTW9udGhTdGFydCB8fCBmYWxzZSxcbiAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXG4gICAgICAgICAgICBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzLFxuICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgICAgICAgICAgbW9udGhTdGFydEZvcm1hdDogb3B0aW9ucy5tb250aFN0YXJ0Rm9ybWF0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIC4uLmdldERheUNsYXNzTmFtZXMocmVuZGVyUHJvcHMsIGNvbnRleHQudGhlbWUpLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgKHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB7fSA6IHsgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhwcm9wcy5kYXRlKSB9KSksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlDZWxsQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogXG4gICAgICAgICAgICAvLyBkb24ndCB1c2UgY3VzdG9tIGNsYXNzTmFtZXMgaWYgZGlzYWJsZWRcbiAgICAgICAgICAgIHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmRheUNlbGxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlDZWxsRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUNlbGxXaWxsVW5tb3VudCB9KSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmRheUNlbGxDb250ZW50IHx8IGhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIoJ2RheUNlbGxDb250ZW50Jywgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gcmVmaW5lUmVuZGVyUHJvcHMocmF3KSB7XG4gICAgbGV0IHsgZGF0ZSwgZGF0ZUVudiwgZGF0ZVByb2ZpbGUsIGlzTW9udGhTdGFydCB9ID0gcmF3O1xuICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcmF3LnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcbiAgICBsZXQgZGF5TnVtYmVyVGV4dCA9IHJhdy5zaG93RGF5TnVtYmVyID8gKGRhdGVFbnYuZm9ybWF0KGRhdGUsIGlzTW9udGhTdGFydCA/IHJhdy5tb250aFN0YXJ0Rm9ybWF0IDogREFZX05VTV9GT1JNQVQpKSA6ICcnO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiByYXcudmlld0FwaSB9LCBkYXlNZXRhKSwgeyBpc01vbnRoU3RhcnQsXG4gICAgICAgIGRheU51bWJlclRleHQgfSksIHJhdy5leHRyYVJlbmRlclByb3BzKTtcbn1cblxuY2xhc3MgQmdFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLWJnLWV2ZW50J10sIGVsU3R5bGU6IHsgYmFja2dyb3VuZENvbG9yOiBzZWcuZXZlbnRSYW5nZS51aS5iYWNrZ3JvdW5kQ29sb3IgfSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50LCBzZWc6IHNlZywgdGltZVRleHQ6IFwiXCIsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogZmFsc2UsIGlzUGFzdDogcHJvcHMuaXNQYXN0LCBpc0Z1dHVyZTogcHJvcHMuaXNGdXR1cmUsIGlzVG9kYXk6IHByb3BzLmlzVG9kYXksIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlIH0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICBsZXQgeyB0aXRsZSB9ID0gcHJvcHMuZXZlbnQ7XG4gICAgcmV0dXJuIHRpdGxlICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcHJvcHMuZXZlbnQudGl0bGUpKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckZpbGwoZmlsbFR5cGUpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy0ke2ZpbGxUeXBlfWAgfSkpO1xufVxuXG5jb25zdCBXZWVrTnVtYmVyQ29udGFpbmVyID0gKHByb3BzKSA9PiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgeyBkYXRlIH0gPSBwcm9wcztcbiAgICBsZXQgZm9ybWF0ID0gb3B0aW9ucy53ZWVrTnVtYmVyRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRGb3JtYXQ7XG4gICAgbGV0IG51bSA9IGRhdGVFbnYuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZSk7IC8vIFRPRE86IHNvbWVob3cgdXNlIGZvciBmb3JtYXR0aW5nIGFzIHdlbGw/XG4gICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBmb3JtYXQpO1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHsgbnVtLCB0ZXh0LCBkYXRlIH07XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIgLy8gd2h5IGlzbid0IFdlZWtOdW1iZXJDb250ZW50QXJnIGJlaW5nIGF1dG8tZGV0ZWN0ZWQ/XG4gICAgLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwid2Vla051bWJlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLndlZWtOdW1iZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLndlZWtOdW1iZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJXaWxsVW5tb3VudCB9KSkpO1xufSkpO1xuZnVuY3Rpb24gcmVuZGVySW5uZXIoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiBpbm5lclByb3BzLnRleHQ7XG59XG5cbmNvbnN0IFBBRERJTkdfRlJPTV9WSUVXUE9SVCA9IDEwO1xuY2xhc3MgUG9wb3ZlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGl0bGVJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAqYW55d2hlcmUqIGluIHRoZSBkb2N1bWVudCwgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlXG4gICAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgaGlkZSB0aGUgcG9wb3ZlciBpZiB0aGUgY2xpY2sgaGFwcGVuZWQgb3V0c2lkZSB0aGUgcG9wb3ZlclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb290RWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb25DbG9zZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHRoZW1lLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtcG9wb3ZlcicsXG4gICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygncG9wb3ZlcicpLFxuICAgICAgICBdLmNvbmNhdChwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZXh0cmFBdHRycywgeyBpZDogcHJvcHMuaWQsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHN0YXRlLnRpdGxlSWQsIHJlZjogdGhpcy5oYW5kbGVSb290RWwgfSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJykgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy1wb3BvdmVyLXRpdGxlXCIsIGlkOiBzdGF0ZS50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSwgdGl0bGU6IG9wdGlvbnMuY2xvc2VIaW50LCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgfSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50JykgfSwgcHJvcHMuY2hpbGRyZW4pKSwgcHJvcHMucGFyZW50RWwpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93bik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93bik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IGFsaWdubWVudEVsLCBhbGlnbkdyaWRUb3AgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHJvb3RFbCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGFsaWdubWVudFJlY3QgPSBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoYWxpZ25tZW50RWwpO1xuICAgICAgICBpZiAoYWxpZ25tZW50UmVjdCkge1xuICAgICAgICAgICAgbGV0IHBvcG92ZXJEaW1zID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gcmVsYXRpdmUgdG8gdmlld3BvcnRcbiAgICAgICAgICAgIGxldCBwb3BvdmVyVG9wID0gYWxpZ25HcmlkVG9wXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50Q2xvc2VzdChhbGlnbm1lbnRFbCwgJy5mYy1zY3JvbGxncmlkJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgICAgICAgICAgOiBhbGlnbm1lbnRSZWN0LnRvcDtcbiAgICAgICAgICAgIGxldCBwb3BvdmVyTGVmdCA9IGlzUnRsID8gYWxpZ25tZW50UmVjdC5yaWdodCAtIHBvcG92ZXJEaW1zLndpZHRoIDogYWxpZ25tZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgLy8gY29uc3RyYWluXG4gICAgICAgICAgICBwb3BvdmVyVG9wID0gTWF0aC5tYXgocG9wb3ZlclRvcCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIHBvcG92ZXJMZWZ0ID0gTWF0aC5taW4ocG9wb3ZlckxlZnQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIFBBRERJTkdfRlJPTV9WSUVXUE9SVCAtIHBvcG92ZXJEaW1zLndpZHRoKTtcbiAgICAgICAgICAgIHBvcG92ZXJMZWZ0ID0gTWF0aC5tYXgocG9wb3ZlckxlZnQsIFBBRERJTkdfRlJPTV9WSUVXUE9SVCk7XG4gICAgICAgICAgICBsZXQgb3JpZ2luID0gcm9vdEVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUocm9vdEVsLCB7XG4gICAgICAgICAgICAgICAgdG9wOiBwb3BvdmVyVG9wIC0gb3JpZ2luLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb3BvdmVyTGVmdCAtIG9yaWdpbi5sZWZ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIE1vcmVQb3BvdmVyIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKHJvb3RFbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICB1c2VFdmVudENlbnRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHN0YXJ0RGF0ZSwgdG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdGl0bGUgPSBkYXRlRW52LmZvcm1hdChzdGFydERhdGUsIG9wdGlvbnMuZGF5UG9wb3ZlckZvcm1hdCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgZGF0ZTogc3RhcnREYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSwgKElubmVyQ29udGVudCwgcmVuZGVyUHJvcHMsIGVsQXR0cnMpID0+IChjcmVhdGVFbGVtZW50KFBvcG92ZXIsIHsgZWxSZWY6IGVsQXR0cnMucmVmLCBpZDogcHJvcHMuaWQsIHRpdGxlOiB0aXRsZSwgZXh0cmFDbGFzc05hbWVzOiBbJ2ZjLW1vcmUtcG9wb3ZlciddLmNvbmNhdChlbEF0dHJzLmNsYXNzTmFtZSB8fCBbXSksIGV4dHJhQXR0cnM6IGVsQXR0cnMgLyogVE9ETzogbWFrZSB0aGVzZSB0aW1lLWJhc2VkIHdoZW4gbm90IHdob2xlLWRheT8gKi8sIHBhcmVudEVsOiBwcm9wcy5wYXJlbnRFbCwgYWxpZ25tZW50RWw6IHByb3BzLmFsaWdubWVudEVsLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgb25DbG9zZTogcHJvcHMub25DbG9zZSB9LFxuICAgICAgICAgICAgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbW9yZS1wb3BvdmVyLW1pc2MnXSB9KSksXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbikpKSk7XG4gICAgfVxuICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgIGxldCB7IHJvb3RFbCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCBlbFdpZHRoICYmXG4gICAgICAgICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgZWxIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgYWxsRGF5OiAhcHJvcHMuZm9yY2VUaW1lZCwgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5zdGFydERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByb3BzLmVuZERhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgcHJvcHMuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogZWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMSwgLy8gaW1wb3J0YW50IHdoZW4gY29tcGFyaW5nIHdpdGggaGl0cyBmcm9tIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5jbGFzcyBNb3JlTGlua0NvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaXNQb3BvdmVyT3BlbjogZmFsc2UsXG4gICAgICAgICAgICBwb3BvdmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTGlua0VsID0gKGxpbmtFbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saW5rRWwgPSBsaW5rRWw7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBsaW5rRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rQ2xpY2sgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgICAgIGxldCBkYXRlID0gY29tcHV0ZVJhbmdlKHByb3BzKS5zdGFydDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljU2VnKHNlZykge1xuICAgICAgICAgICAgICAgIGxldCB7IGRlZiwgaW5zdGFuY2UsIHJhbmdlIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1vcmVMaW5rQ2xpY2sgPSBtb3JlTGlua0NsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiBCb29sZWFuKHByb3BzLmFsbERheURhdGUpLFxuICAgICAgICAgICAgICAgICAgICBhbGxTZWdzOiBwcm9wcy5hbGxTZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9yZUxpbmtDbGljayB8fCBtb3JlTGlua0NsaWNrID09PSAncG9wb3ZlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnc3RyaW5nJykgeyAvLyBhIHZpZXcgbmFtZVxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuem9vbVRvKGRhdGUsIG1vcmVMaW5rQ2xpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyB2aWV3QXBpLCBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rVGV4dCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxldCB7IG1vcmVDbnQgfSA9IHByb3BzO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gY29tcHV0ZVJhbmdlKHByb3BzKTtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIG1vcmVMaW5rVGV4dCA9PT0gJ2Z1bmN0aW9uJyAvLyBUT0RPOiBldmVudHVhbGx5IHVzZSBmb3JtYXRXaXRoT3JkaW5hbHNcbiAgICAgICAgICAgICAgICA/IG1vcmVMaW5rVGV4dC5jYWxsKGNhbGVuZGFyQXBpLCBtb3JlQ250KVxuICAgICAgICAgICAgICAgIDogYCske21vcmVDbnR9ICR7bW9yZUxpbmtUZXh0fWA7XG4gICAgICAgICAgICBsZXQgaGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyhvcHRpb25zLm1vcmVMaW5rSGludCwgW21vcmVDbnRdLCB0ZXh0KTtcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBudW06IG1vcmVDbnQsXG4gICAgICAgICAgICAgICAgc2hvcnRUZXh0OiBgKyR7bW9yZUNudH1gLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5tb3JlQ250KSAmJiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnYScsIGVsUmVmOiB0aGlzLmhhbmRsZUxpbmtFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1tb3JlLWxpbmsnLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbFN0eWxlOiBwcm9wcy5lbFN0eWxlLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIGNyZWF0ZUFyaWFDbGlja0F0dHJzKHRoaXMuaGFuZGxlQ2xpY2spKSwgeyB0aXRsZTogaGludCwgJ2FyaWEtZXhwYW5kZWQnOiBzdGF0ZS5pc1BvcG92ZXJPcGVuLCAnYXJpYS1jb250cm9scyc6IHN0YXRlLmlzUG9wb3Zlck9wZW4gPyBzdGF0ZS5wb3BvdmVySWQgOiAnJyB9KSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIm1vcmVMaW5rQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMubW9yZUxpbmtDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiBwcm9wcy5kZWZhdWx0R2VuZXJhdG9yIHx8IHJlbmRlck1vcmVMaW5rSW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm1vcmVMaW5rRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm1vcmVMaW5rV2lsbFVubW91bnQgfSwgcHJvcHMuY2hpbGRyZW4pKSxcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvcG92ZXJPcGVuICYmIChjcmVhdGVFbGVtZW50KE1vcmVQb3BvdmVyLCB7IGlkOiBzdGF0ZS5wb3BvdmVySWQsIHN0YXJ0RGF0ZTogcmFuZ2Uuc3RhcnQsIGVuZERhdGU6IHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBwYXJlbnRFbDogdGhpcy5wYXJlbnRFbCwgYWxpZ25tZW50RWw6IHByb3BzLmFsaWdubWVudEVsUmVmID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmFsaWdubWVudEVsUmVmLmN1cnJlbnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rRWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBmb3JjZVRpbWVkOiBwcm9wcy5mb3JjZVRpbWVkLCBvbkNsb3NlOiB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSB9LCBwcm9wcy5wb3BvdmVyQ29udGVudCgpKSkpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcbiAgICB9XG4gICAgdXBkYXRlUGFyZW50RWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtFbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRFbCA9IGVsZW1lbnRDbG9zZXN0KHRoaXMubGlua0VsLCAnLmZjLXZpZXctaGFybmVzcycpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyTW9yZUxpbmtJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmFsbERheURhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5hbGxEYXlEYXRlLFxuICAgICAgICAgICAgZW5kOiBhZGREYXlzKHByb3BzLmFsbERheURhdGUsIDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgeyBoaWRkZW5TZWdzIH0gPSBwcm9wcztcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncyksXG4gICAgICAgIGVuZDogY29tcHV0ZUxhdGVzdFNlZ0VuZChoaWRkZW5TZWdzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrRWFybGllc3RTdGFydCkuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcbn1cbmZ1bmN0aW9uIHBpY2tFYXJsaWVzdFN0YXJ0KHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0IDwgc2VnMS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0ID8gc2VnMCA6IHNlZzE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGF0ZXN0U2VnRW5kKHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0xhdGVzdEVuZCkuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XG59XG5mdW5jdGlvbiBwaWNrTGF0ZXN0RW5kKHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLmVuZCA+IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPyBzZWcwIDogc2VnMTtcbn1cblxuY2xhc3MgU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIodGhpcy5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuU3Vic2NyaWJlcnMgd2lsbCBnZXQgYSBMSVNUIG9mIEN1c3RvbVJlbmRlcmluZ3NcbiovXG5jbGFzcyBDdXN0b21SZW5kZXJpbmdTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8vIGZvciBjb25zaXN0ZW50IG9yZGVyXG4gICAgaGFuZGxlKGN1c3RvbVJlbmRlcmluZykge1xuICAgICAgICBjb25zdCB7IG1hcCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGN1c3RvbVJlbmRlcmluZy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgbWFwLnNldChjdXN0b21SZW5kZXJpbmcuaWQsIGN1c3RvbVJlbmRlcmluZyk7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXAuaGFzKGN1c3RvbVJlbmRlcmluZy5pZCkpIHtcbiAgICAgICAgICAgIG1hcC5kZWxldGUoY3VzdG9tUmVuZGVyaW5nLmlkKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldChtYXApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBsaXN0ZW5CeVNlbGVjdG9yIGFzICQsIG1lbW9pemVPYmpBcmcgYXMgQSwgQmFzZUNvbXBvbmVudCBhcyBCLCBDb250ZW50Q29udGFpbmVyIGFzIEMsIERlbGF5ZWRSdW5uZXIgYXMgRCwgaXNQcm9wc0VxdWFsIGFzIEUsIEVtaXR0ZXIgYXMgRiwgcmFuZ2VDb250YWluc01hcmtlciBhcyBHLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgYXMgSCwgcmVkdWNlRXZlbnRTdG9yZSBhcyBJLCByZXpvbmVFdmVudFN0b3JlRGF0ZXMgYXMgSiwgbWVyZ2VSYXdPcHRpb25zIGFzIEssIEJBU0VfT1BUSU9OX1JFRklORVJTIGFzIEwsIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIGFzIE0sIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyBhcyBOLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyBhcyBPLCBWSUVXX09QVElPTl9SRUZJTkVSUyBhcyBQLCBEYXRlRW52IGFzIFEsIERhdGVQcm9maWxlR2VuZXJhdG9yIGFzIFIsIGNyZWF0ZUV2ZW50VWkgYXMgUywgVGhlbWUgYXMgVCwgcGFyc2VCdXNpbmVzc0hvdXJzIGFzIFUsIFZpZXdDb250ZXh0VHlwZSBhcyBWLCBzZXRSZWYgYXMgVywgSW50ZXJhY3Rpb24gYXMgWCwgZ2V0RWxTZWcgYXMgWSwgZWxlbWVudENsb3Nlc3QgYXMgWiwgRXZlbnRJbXBsIGFzIF8sIG1hcEhhc2ggYXMgYSwgcHJldmVudERlZmF1bHQgYXMgYSQsIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yIGFzIGEwLCBQdXJlQ29tcG9uZW50IGFzIGExLCBidWlsZFZpZXdDb250ZXh0IGFzIGEyLCBnZXRVbmlxdWVEb21JZCBhcyBhMywgcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzIGFzIGE0LCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgYXMgYTUsIE5vd1RpbWVyIGFzIGE2LCBDYWxlbmRhckltcGwgYXMgYTcsIGZsdXNoU3luYyBhcyBhOCwgQ2FsZW5kYXJSb290IGFzIGE5LCBtZW1vaXplQXJyYXlsaWtlIGFzIGFBLCBtZW1vaXplSGFzaGxpa2UgYXMgYUIsIGludGVyc2VjdFJlY3RzIGFzIGFDLCBwb2ludEluc2lkZVJlY3QgYXMgYUQsIGNvbnN0cmFpblBvaW50IGFzIGFFLCBnZXRSZWN0Q2VudGVyIGFzIGFGLCBkaWZmUG9pbnRzIGFzIGFHLCB0cmFuc2xhdGVSZWN0IGFzIGFILCBjb21wYXJlT2JqcyBhcyBhSSwgY29sbGVjdEZyb21IYXNoIGFzIGFKLCBmaW5kRWxlbWVudHMgYXMgYUssIGZpbmREaXJlY3RDaGlsZHJlbiBhcyBhTCwgcmVtb3ZlRWxlbWVudCBhcyBhTSwgYXBwbHlTdHlsZSBhcyBhTiwgZWxlbWVudE1hdGNoZXMgYXMgYU8sIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCBhcyBhUCwgcGFyc2VDbGFzc05hbWVzIGFzIGFRLCBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYVIsIG1lcmdlRXZlbnRTdG9yZXMgYXMgYVMsIGdldFJlbGV2YW50RXZlbnRzIGFzIGFULCBldmVudFR1cGxlVG9TdG9yZSBhcyBhVSwgY29tYmluZUV2ZW50VWlzIGFzIGFWLCBTcGxpdHRlciBhcyBhVywgZ2V0RGF5Q2xhc3NOYW1lcyBhcyBhWCwgZ2V0RGF0ZU1ldGEgYXMgYVksIGdldFNsb3RDbGFzc05hbWVzIGFzIGFaLCBidWlsZE5hdkxpbmtBdHRycyBhcyBhXywgUmVuZGVySWQgYXMgYWEsIGVuc3VyZUVsSGFzU3R5bGVzIGFzIGFiLCBhcHBseVN0eWxlUHJvcCBhcyBhYywgc2xpY2VFdmVudFN0b3JlIGFzIGFkLCBKc29uUmVxdWVzdEVycm9yIGFzIGFlLCBjcmVhdGVDb250ZXh0IGFzIGFmLCByZWZpbmVQcm9wcyBhcyBhZywgY3JlYXRlRXZlbnRJbnN0YW5jZSBhcyBhaCwgcGFyc2VFdmVudERlZiBhcyBhaSwgcmVmaW5lRXZlbnREZWYgYXMgYWosIHBhZFN0YXJ0IGFzIGFrLCBpc0ludCBhcyBhbCwgcGFyc2VGaWVsZFNwZWNzIGFzIGFtLCBjb21wYXJlQnlGaWVsZFNwZWNzIGFzIGFuLCBmbGV4aWJsZUNvbXBhcmUgYXMgYW8sIHByZXZlbnRTZWxlY3Rpb24gYXMgYXAsIGFsbG93U2VsZWN0aW9uIGFzIGFxLCBwcmV2ZW50Q29udGV4dE1lbnUgYXMgYXIsIGFsbG93Q29udGV4dE1lbnUgYXMgYXMsIGNvbXBhcmVOdW1iZXJzIGFzIGF0LCBlbmFibGVDdXJzb3IgYXMgYXUsIGRpc2FibGVDdXJzb3IgYXMgYXYsIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgYXMgYXcsIGlzTXVsdGlEYXlSYW5nZSBhcyBheCwgZGlmZkRhdGVzIGFzIGF5LCByZW1vdmVFeGFjdCBhcyBheiwgYnVpbGRWaWV3Q2xhc3NOYW1lcyBhcyBiLCByZW5kZXJNaWNyb0NvbEdyb3VwIGFzIGIkLCB3aGVuVHJhbnNpdGlvbkRvbmUgYXMgYjAsIGNvbXB1dGVJbm5lclJlY3QgYXMgYjEsIGNvbXB1dGVFZGdlcyBhcyBiMiwgZ2V0Q2xpcHBpbmdQYXJlbnRzIGFzIGIzLCBjb21wdXRlUmVjdCBhcyBiNCwgcmFuZ2VzRXF1YWwgYXMgYjUsIHJhbmdlc0ludGVyc2VjdCBhcyBiNiwgcmFuZ2VDb250YWluc1JhbmdlIGFzIGI3LCBQb3NpdGlvbkNhY2hlIGFzIGI4LCBTY3JvbGxDb250cm9sbGVyIGFzIGI5LCBnZXRFbnRyeVNwYW5FbmQgYXMgYkEsIGJpbmFyeVNlYXJjaCBhcyBiQiwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIGFzIGJDLCBpbnRlcnNlY3RTcGFucyBhcyBiRCwgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUgYXMgYkUsIEVsZW1lbnREcmFnZ2luZyBhcyBiRiwgY29uZmlnIGFzIGJHLCBwYXJzZURyYWdNZXRhIGFzIGJILCBEYXlIZWFkZXIgYXMgYkksIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCBhcyBiSiwgVGFibGVEYXRlQ2VsbCBhcyBiSywgVGFibGVEb3dDZWxsIGFzIGJMLCBEYXlTZXJpZXNNb2RlbCBhcyBiTSwgaGFzQmdSZW5kZXJpbmcgYXMgYk4sIGJ1aWxkU2VnVGltZVRleHQgYXMgYk8sIHNvcnRFdmVudFNlZ3MgYXMgYlAsIGdldFNlZ01ldGEgYXMgYlEsIGJ1aWxkRXZlbnRSYW5nZUtleSBhcyBiUiwgZ2V0U2VnQW5jaG9yQXR0cnMgYXMgYlMsIERheVRhYmxlTW9kZWwgYXMgYlQsIFNsaWNlciBhcyBiVSwgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSBhcyBiViwgaXNQcm9wc1ZhbGlkIGFzIGJXLCBpc0ludGVyYWN0aW9uVmFsaWQgYXMgYlgsIGlzRGF0ZVNlbGVjdGlvblZhbGlkIGFzIGJZLCBTaW1wbGVTY3JvbGxHcmlkIGFzIGJaLCBoYXNTaHJpbmtXaWR0aCBhcyBiXywgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgYXMgYmEsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgYXMgYmIsIERhdGVDb21wb25lbnQgYXMgYmMsIGlzRGF0ZVNwYW5zRXF1YWwgYXMgYmQsIGFkZE1zIGFzIGJlLCBhZGRXZWVrcyBhcyBiZiwgZGlmZldlZWtzIGFzIGJnLCBkaWZmV2hvbGVXZWVrcyBhcyBiaCwgZGlmZkRheUFuZFRpbWUgYXMgYmksIGRpZmZEYXlzIGFzIGJqLCBpc1ZhbGlkRGF0ZSBhcyBiaywgYXNDbGVhbkRheXMgYXMgYmwsIG11bHRpcGx5RHVyYXRpb24gYXMgYm0sIGFkZER1cmF0aW9ucyBhcyBibiwgYXNSb3VnaE1pbnV0ZXMgYXMgYm8sIGFzUm91Z2hTZWNvbmRzIGFzIGJwLCBhc1JvdWdoTXMgYXMgYnEsIHdob2xlRGl2aWRlRHVyYXRpb25zIGFzIGJyLCBmb3JtYXRJc29UaW1lU3RyaW5nIGFzIGJzLCBmb3JtYXREYXlTdHJpbmcgYXMgYnQsIGJ1aWxkSXNvU3RyaW5nIGFzIGJ1LCBmb3JtYXRJc29Nb250aFN0ciBhcyBidiwgTmFtZWRUaW1lWm9uZUltcGwgYXMgYncsIHBhcnNlIGFzIGJ4LCBTZWdIaWVyYXJjaHkgYXMgYnksIGJ1aWxkRW50cnlLZXkgYXMgYnosIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciBhcyBjLCBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyBhcyBjMCwgZ2V0U2VjdGlvbkNsYXNzTmFtZXMgYXMgYzEsIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQgYXMgYzIsIGdldEFsbG93WVNjcm9sbGluZyBhcyBjMywgcmVuZGVyQ2h1bmtDb250ZW50IGFzIGM0LCBjb21wdXRlU2hyaW5rV2lkdGggYXMgYzUsIHNhbml0aXplU2hyaW5rV2lkdGggYXMgYzYsIGlzQ29sUHJvcHNFcXVhbCBhcyBjNywgcmVuZGVyU2Nyb2xsU2hpbSBhcyBjOCwgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIGFzIGM5LCBnZXRTdGlja3lIZWFkZXJEYXRlcyBhcyBjYSwgU2Nyb2xsZXIgYXMgY2IsIGdldFNjcm9sbGJhcldpZHRocyBhcyBjYywgUmVmTWFwIGFzIGNkLCBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCBhcyBjZSwgU2Nyb2xsUmVzcG9uZGVyIGFzIGNmLCBTdGFuZGFyZEV2ZW50IGFzIGNnLCBOb3dJbmRpY2F0b3JDb250YWluZXIgYXMgY2gsIERheUNlbGxDb250YWluZXIgYXMgY2ksIGhhc0N1c3RvbURheUNlbGxDb250ZW50IGFzIGNqLCBFdmVudENvbnRhaW5lciBhcyBjaywgcmVuZGVyRmlsbCBhcyBjbCwgQmdFdmVudCBhcyBjbSwgV2Vla051bWJlckNvbnRhaW5lciBhcyBjbiwgTW9yZUxpbmtDb250YWluZXIgYXMgY28sIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IGFzIGNwLCBWaWV3Q29udGFpbmVyIGFzIGNxLCB0cmlnZ2VyRGF0ZVNlbGVjdCBhcyBjciwgZ2V0RGVmYXVsdEV2ZW50RW5kIGFzIGNzLCBpbmplY3RTdHlsZXMgYXMgY3QsIGJ1aWxkRWxBdHRycyBhcyBjdSwgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgYXMgY3YsIGNyZWF0ZUR1cmF0aW9uIGFzIGQsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIGFzIGUsIGFycmF5VG9IYXNoIGFzIGYsIGd1aWQgYXMgZywgZmlsdGVySGFzaCBhcyBoLCBpc0FycmF5c0VxdWFsIGFzIGksIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyBhcyBqLCBmb3JtYXRXaXRoT3JkaW5hbHMgYXMgaywgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSBhcyBsLCBtZXJnZVByb3BzIGFzIG0sIGlkZW50aXR5IGFzIG4sIGludGVyc2VjdFJhbmdlcyBhcyBvLCBwYXJzZUV2ZW50U291cmNlIGFzIHAsIHN0YXJ0T2ZEYXkgYXMgcSwgcmVxdWVzdEpzb24gYXMgciwgc3VidHJhY3REdXJhdGlvbnMgYXMgcywgYWRkRGF5cyBhcyB0LCB1bnByb21pc2lmeSBhcyB1LCBoYXNoVmFsdWVzVG9BcnJheSBhcyB2LCBidWlsZEV2ZW50QXBpcyBhcyB3LCBjcmVhdGVGb3JtYXR0ZXIgYXMgeCwgZGlmZldob2xlRGF5cyBhcyB5LCBtZW1vaXplIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJwcmVhY3QiLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJGcmFnbWVudCIsImNyZWF0ZVBvcnRhbCIsInN0eWxlVGV4dHMiLCJzdHlsZUVscyIsIk1hcCIsImluamVjdFN0eWxlcyIsInN0eWxlVGV4dCIsInB1c2giLCJmb3JFYWNoIiwic3R5bGVFbCIsImFwcGVuZFN0eWxlc1RvIiwiZW5zdXJlRWxIYXNTdHlsZXMiLCJlbCIsImlzQ29ubmVjdGVkIiwiZ2V0Um9vdE5vZGUiLCJyZWdpc3RlclN0eWxlc1Jvb3QiLCJyb290Tm9kZSIsImdldCIsInF1ZXJ5U2VsZWN0b3IiLCJkb2N1bWVudCIsInNldEF0dHJpYnV0ZSIsIm5vbmNlIiwiZ2V0Tm9uY2VWYWx1ZSIsInBhcmVudEVsIiwiaGVhZCIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJzZXQiLCJoeWRyYXRlU3R5bGVzUm9vdCIsInNoZWV0IiwicnVsZUNudCIsImNzc1J1bGVzIiwibGVuZ3RoIiwic3BsaXQiLCJzdHlsZVN0ciIsImkiLCJ0cmltIiwiaW5zZXJ0UnVsZSIsInF1ZXJpZWROb25jZVZhbHVlIiwidW5kZWZpbmVkIiwicXVlcnlOb25jZVZhbHVlIiwibWV0YVdpdGhOb25jZSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImVsV2l0aE5vbmNlIiwiY3NzXzI0OHoiLCJEZWxheWVkUnVubmVyIiwiY29uc3RydWN0b3IiLCJkcmFpbmVkT3B0aW9uIiwiaXNSdW5uaW5nIiwiaXNEaXJ0eSIsInBhdXNlRGVwdGhzIiwidGltZW91dElkIiwicmVxdWVzdCIsImRlbGF5IiwiaXNQYXVzZWQiLCJjbGVhclRpbWVvdXQiLCJ0cnlEcmFpbiIsInNldFRpbWVvdXQiLCJiaW5kIiwicGF1c2UiLCJzY29wZSIsInJlc3VtZSIsImZvcmNlIiwiZGVwdGgiLCJPYmplY3QiLCJrZXlzIiwiZHJhaW5lZCIsImNsZWFyIiwicmVtb3ZlRWxlbWVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVsZW1lbnRDbG9zZXN0Iiwic2VsZWN0b3IiLCJjbG9zZXN0IiwiZG9jdW1lbnRFbGVtZW50IiwiY29udGFpbnMiLCJlbGVtZW50TWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJub2RlVHlwZSIsIm1ldGhvZCIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImNhbGwiLCJmaW5kRWxlbWVudHMiLCJjb250YWluZXIiLCJjb250YWluZXJzIiwiSFRNTEVsZW1lbnQiLCJhbGxNYXRjaGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImoiLCJmaW5kRGlyZWN0Q2hpbGRyZW4iLCJwYXJlbnQiLCJwYXJlbnRzIiwiY2hpbGROb2RlcyIsImNoaWxkcmVuIiwiY2hpbGROb2RlIiwiUElYRUxfUFJPUF9SRSIsImFwcGx5U3R5bGUiLCJwcm9wcyIsInByb3BOYW1lIiwiYXBwbHlTdHlsZVByb3AiLCJuYW1lIiwidmFsIiwic3R5bGUiLCJ0ZXN0IiwiZ2V0RXZlbnRUYXJnZXRWaWFSb290IiwiZXYiLCJfYSIsIl9iIiwiY29tcG9zZWRQYXRoIiwidGFyZ2V0IiwiZ3VpZCQxIiwiZ2V0VW5pcXVlRG9tSWQiLCJwcmV2ZW50RGVmYXVsdCIsImJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIiLCJoYW5kbGVyIiwibWF0Y2hlZENoaWxkIiwibGlzdGVuQnlTZWxlY3RvciIsImV2ZW50VHlwZSIsImF0dGFjaGVkSGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJjdXJyZW50TWF0Y2hlZENoaWxkIiwibW91c2VPdmVyRXYiLCJyZWFsT25Nb3VzZUxlYXZlIiwibW91c2VMZWF2ZUV2IiwidHJhbnNpdGlvbkV2ZW50TmFtZXMiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJjYWxsYmFjayIsInJlYWxDYWxsYmFjayIsImV2ZW50TmFtZSIsImNyZWF0ZUFyaWFDbGlja0F0dHJzIiwiYXNzaWduIiwib25DbGljayIsImNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzIiwidGFiSW5kZXgiLCJvbktleURvd24iLCJrZXkiLCJndWlkTnVtYmVyIiwiZ3VpZCIsIlN0cmluZyIsImRpc2FibGVDdXJzb3IiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiZW5hYmxlQ3Vyc29yIiwicmVtb3ZlIiwicHJldmVudFNlbGVjdGlvbiIsInVzZXJTZWxlY3QiLCJ3ZWJraXRVc2VyU2VsZWN0IiwiYWxsb3dTZWxlY3Rpb24iLCJwcmV2ZW50Q29udGV4dE1lbnUiLCJhbGxvd0NvbnRleHRNZW51IiwicGFyc2VGaWVsZFNwZWNzIiwiaW5wdXQiLCJzcGVjcyIsInRva2VucyIsInRva2VuIiwiQXJyYXkiLCJpc0FycmF5IiwiY2hhckF0IiwiZmllbGQiLCJzdWJzdHJpbmciLCJvcmRlciIsImZ1bmMiLCJjb21wYXJlQnlGaWVsZFNwZWNzIiwib2JqMCIsIm9iajEiLCJmaWVsZFNwZWNzIiwiY21wIiwiY29tcGFyZUJ5RmllbGRTcGVjIiwiZmllbGRTcGVjIiwiZmxleGlibGVDb21wYXJlIiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwicGFkU3RhcnQiLCJsZW4iLCJzIiwic3Vic3RyIiwiZm9ybWF0V2l0aE9yZGluYWxzIiwiZm9ybWF0dGVyIiwiYXJncyIsImZhbGxiYWNrVGV4dCIsInJlZHVjZSIsInN0ciIsImFyZyIsImluZGV4IiwicmVwbGFjZSIsImNvbXBhcmVOdW1iZXJzIiwiaXNJbnQiLCJuIiwiY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoIiwiY2VsbEVsIiwiYWxsV2lkdGhFbCIsImNvbnRlbnRXaWR0aEVsIiwiRXJyb3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsIklOVEVSTkFMX1VOSVRTIiwiUEFSU0VfUkUiLCJjcmVhdGVEdXJhdGlvbiIsInVuaXQiLCJwYXJzZVN0cmluZyIsInBhcnNlT2JqZWN0IiwibSIsImV4ZWMiLCJzaWduIiwieWVhcnMiLCJtb250aHMiLCJkYXlzIiwicGFyc2VJbnQiLCJtaWxsaXNlY29uZHMiLCJvYmoiLCJkdXJhdGlvbiIsInllYXIiLCJtb250aCIsImRheSIsImhvdXJzIiwiaG91ciIsIm1pbnV0ZXMiLCJtaW51dGUiLCJzZWNvbmRzIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJtcyIsIndlZWtzIiwid2VlayIsInNwZWNpZmllZFdlZWtzIiwiZHVyYXRpb25zRXF1YWwiLCJkMCIsImQxIiwiYXNDbGVhbkRheXMiLCJkdXIiLCJhZGREdXJhdGlvbnMiLCJzdWJ0cmFjdER1cmF0aW9ucyIsIm11bHRpcGx5RHVyYXRpb24iLCJkIiwiYXNSb3VnaFllYXJzIiwiYXNSb3VnaERheXMiLCJhc1JvdWdoTW9udGhzIiwiYXNSb3VnaE1zIiwiYXNSb3VnaE1pbnV0ZXMiLCJhc1JvdWdoU2Vjb25kcyIsIndob2xlRGl2aWRlRHVyYXRpb25zIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJyZXMiLCJsb2NhbFJlcyIsImdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciIsInZhbHVlIiwicmVtb3ZlRXhhY3QiLCJhcnJheSIsImV4YWN0VmFsIiwicmVtb3ZlQ250Iiwic3BsaWNlIiwiaXNBcnJheXNFcXVhbCIsImEwIiwiYTEiLCJlcXVhbGl0eUZ1bmMiLCJEQVlfSURTIiwiYWRkV2Vla3MiLCJkYXRlVG9VdGNBcnJheSIsImFycmF5VG9VdGNEYXRlIiwiYWRkRGF5cyIsImFkZE1zIiwiZGlmZldlZWtzIiwibTAiLCJtMSIsImRpZmZEYXlzIiwidmFsdWVPZiIsImRpZmZIb3VycyIsImRpZmZNaW51dGVzIiwiZGlmZlNlY29uZHMiLCJkaWZmRGF5QW5kVGltZSIsIm0wZGF5Iiwic3RhcnRPZkRheSIsIm0xZGF5IiwiTWF0aCIsInJvdW5kIiwiZGlmZldob2xlV2Vla3MiLCJkaWZmV2hvbGVEYXlzIiwidGltZUFzTXMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsInN0YXJ0T2ZIb3VyIiwiZ2V0VVRDSG91cnMiLCJzdGFydE9mTWludXRlIiwiZ2V0VVRDTWludXRlcyIsInN0YXJ0T2ZTZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwid2Vla09mWWVhciIsIm1hcmtlciIsImRvdyIsImRveSIsInkiLCJ3Iiwid2Vla09mR2l2ZW5ZZWFyIiwibmV4dFciLCJtaW4iLCJmaXJzdFdlZWtTdGFydCIsImZpcnN0V2Vla09mZnNldCIsImRheVN0YXJ0IiwiZmxvb3IiLCJmd2QiLCJmd2RsdyIsImdldFVUQ0RheSIsImRhdGVUb0xvY2FsQXJyYXkiLCJkYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwiYXJyYXlUb0xvY2FsRGF0ZSIsIkRhdGUiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJjb25jYXQiLCJVVEMiLCJpc1ZhbGlkRGF0ZSIsImlzTmFOIiwiYnVpbGRJc29TdHJpbmciLCJ0aW1lWm9uZU9mZnNldCIsInN0cmlwWmVyb1RpbWUiLCJ0b0lTT1N0cmluZyIsImZvcm1hdFRpbWVab25lT2Zmc2V0IiwiZm9ybWF0RGF5U3RyaW5nIiwiZm9ybWF0SXNvTW9udGhTdHIiLCJtYXRjaCIsImZvcm1hdElzb1RpbWVTdHJpbmciLCJkb0lzbyIsImFicyIsIm1pbnMiLCJtZW1vaXplIiwid29ya2VyRnVuYyIsInJlc0VxdWFsaXR5IiwidGVhcmRvd25GdW5jIiwiY3VycmVudEFyZ3MiLCJjdXJyZW50UmVzIiwibmV3QXJncyIsImFwcGx5IiwibWVtb2l6ZU9iakFyZyIsImN1cnJlbnRBcmciLCJuZXdBcmciLCJpc1Byb3BzRXF1YWwiLCJtZW1vaXplQXJyYXlsaWtlIiwiY3VycmVudEFyZ1NldHMiLCJjdXJyZW50UmVzdWx0cyIsIm5ld0FyZ1NldHMiLCJjdXJyZW50TGVuIiwibmV3TGVuIiwibWVtb2l6ZUhhc2hsaWtlIiwiY3VycmVudEFyZ0hhc2giLCJjdXJyZW50UmVzSGFzaCIsIm5ld0FyZ0hhc2giLCJuZXdSZXNIYXNoIiwiRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMiLCJzZXBhcmF0b3IiLCJvbWl0WmVyb01pbnV0ZSIsIm1lcmlkaWVtIiwib21pdENvbW1hcyIsIlNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTIiwidGltZVpvbmVOYW1lIiwiZXJhIiwid2Vla2RheSIsIk1FUklESUVNX1JFIiwiQ09NTUFfUkUiLCJNVUxUSV9TUEFDRV9SRSIsIkxUUl9SRSIsIlVUQ19SRSIsIk5hdGl2ZUZvcm1hdHRlciIsImZvcm1hdFNldHRpbmdzIiwic3RhbmRhcmREYXRlUHJvcHMiLCJleHRlbmRlZFNldHRpbmdzIiwic21hbGxlc3RVbml0TnVtIiwic2V2ZXJpdHkiLCJidWlsZEZvcm1hdHRpbmdGdW5jIiwiZm9ybWF0IiwiY29udGV4dCIsImZvcm1hdFJhbmdlIiwic3RhcnQiLCJlbmQiLCJiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIiwiZGlmZlNldmVyaXR5IiwiY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eSIsImNhbGVuZGFyU3lzdGVtIiwiYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsIiwiZnVsbDAiLCJmdWxsMSIsInBhcnRpYWxEYXRlUHJvcHMiLCJjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zIiwicGFydGlhbEZvcm1hdHRpbmdGdW5jIiwicGFydGlhbDAiLCJwYXJ0aWFsMSIsImluc2VydGlvbiIsImZpbmRDb21tb25JbnNlcnRpb24iLCJkZWZhdWx0U2VwYXJhdG9yIiwiYmVmb3JlIiwiYWZ0ZXIiLCJnZXRTbWFsbGVzdFVuaXQiLCJzdGFuZGFyZERhdGVQcm9wQ250IiwiZm9ybWF0V2Vla051bWJlciIsImNvbXB1dGVXZWVrTnVtYmVyIiwid2Vla1RleHQiLCJ3ZWVrVGV4dExvbmciLCJsb2NhbGUiLCJidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jIiwic2FuaXRpemVTZXR0aW5ncyIsInRpbWVab25lIiwibm9ybWFsRm9ybWF0IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiY29kZXMiLCJ6ZXJvRm9ybWF0IiwiemVyb1Byb3BzIiwicG9zdFByb2Nlc3MiLCJpbmplY3RUem9TdHIiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsInR6b1N0ciIsInJlcGxhY2VkIiwibnVtIiwiZGlzcGxheSIsInBhcnRzIiwic2ltcGxlTnVtYmVyRm9ybWF0Iiwib3B0aW9ucyIsImRpcmVjdGlvbiIsInJldmVyc2UiLCJqb2luIiwiY2EiLCJnZXRNYXJrZXJZZWFyIiwiZ2V0TWFya2VyTW9udGgiLCJnZXRNYXJrZXJEYXkiLCJiaWdnZXN0VW5pdCIsInBhcnRpYWxPcHRpb25zIiwiaTAiLCJmb3VuZDAiLCJpbmRleE9mIiwiYmVmb3JlMCIsImFmdGVyMCIsImkxIiwiZm91bmQxIiwiYmVmb3JlMSIsImFmdGVyMSIsImV4cGFuZFpvbmVkTWFya2VyIiwiZGF0ZUluZm8iLCJtYXJrZXJUb0FycmF5IiwiY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmciLCJzdGFydEluZm8iLCJlbmRJbmZvIiwibG9jYWxlQ29kZXMiLCJDbWRGb3JtYXR0ZXIiLCJjbWRTdHIiLCJjbWRGb3JtYXR0ZXIiLCJGdW5jRm9ybWF0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiQkFTRV9PUFRJT05fUkVGSU5FUlMiLCJuYXZMaW5rRGF5Q2xpY2siLCJpZGVudGl0eSIsIm5hdkxpbmtXZWVrQ2xpY2siLCJib290c3RyYXBGb250QXdlc29tZSIsImJ1dHRvbkljb25zIiwiY3VzdG9tQnV0dG9ucyIsImRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIiwiZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiIsIm5leHREYXlUaHJlc2hvbGQiLCJzY3JvbGxUaW1lIiwic2Nyb2xsVGltZVJlc2V0IiwiQm9vbGVhbiIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJkYXlQb3BvdmVyRm9ybWF0Iiwic2xvdER1cmF0aW9uIiwic25hcER1cmF0aW9uIiwiaGVhZGVyVG9vbGJhciIsImZvb3RlclRvb2xiYXIiLCJkZWZhdWx0UmFuZ2VTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZm9yY2VFdmVudER1cmF0aW9uIiwiZGF5SGVhZGVycyIsImRheUhlYWRlckZvcm1hdCIsImRheUhlYWRlckNsYXNzTmFtZXMiLCJkYXlIZWFkZXJDb250ZW50IiwiZGF5SGVhZGVyRGlkTW91bnQiLCJkYXlIZWFkZXJXaWxsVW5tb3VudCIsImRheUNlbGxDbGFzc05hbWVzIiwiZGF5Q2VsbENvbnRlbnQiLCJkYXlDZWxsRGlkTW91bnQiLCJkYXlDZWxsV2lsbFVubW91bnQiLCJpbml0aWFsVmlldyIsImFzcGVjdFJhdGlvIiwiTnVtYmVyIiwid2Vla2VuZHMiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJ3ZWVrTnVtYmVycyIsIndlZWtOdW1iZXJDbGFzc05hbWVzIiwid2Vla051bWJlckNvbnRlbnQiLCJ3ZWVrTnVtYmVyRGlkTW91bnQiLCJ3ZWVrTnVtYmVyV2lsbFVubW91bnQiLCJlZGl0YWJsZSIsInZpZXdDbGFzc05hbWVzIiwidmlld0RpZE1vdW50Iiwidmlld1dpbGxVbm1vdW50Iiwibm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yQ2xhc3NOYW1lcyIsIm5vd0luZGljYXRvckNvbnRlbnQiLCJub3dJbmRpY2F0b3JEaWRNb3VudCIsIm5vd0luZGljYXRvcldpbGxVbm1vdW50Iiwic2hvd05vbkN1cnJlbnREYXRlcyIsImxhenlGZXRjaGluZyIsInN0YXJ0UGFyYW0iLCJlbmRQYXJhbSIsInRpbWVab25lUGFyYW0iLCJsb2NhbGVzIiwidGhlbWVTeXN0ZW0iLCJkcmFnUmV2ZXJ0RHVyYXRpb24iLCJkcmFnU2Nyb2xsIiwiYWxsRGF5TWFpbnRhaW5EdXJhdGlvbiIsInVuc2VsZWN0QXV0byIsImRyb3BBY2NlcHQiLCJldmVudE9yZGVyIiwiZXZlbnRPcmRlclN0cmljdCIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIndpbmRvd1Jlc2l6ZURlbGF5IiwibG9uZ1ByZXNzRGVsYXkiLCJldmVudERyYWdNaW5EaXN0YW5jZSIsImV4cGFuZFJvd3MiLCJoZWlnaHQiLCJjb250ZW50SGVpZ2h0Iiwid2Vla051bWJlckZvcm1hdCIsImV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0IiwiZGlzcGxheUV2ZW50VGltZSIsImRpc3BsYXlFdmVudEVuZCIsInByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmciLCJidXNpbmVzc0hvdXJzIiwiaW5pdGlhbERhdGUiLCJub3ciLCJldmVudERhdGFUcmFuc2Zvcm0iLCJzdGlja3lIZWFkZXJEYXRlcyIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInZpZXdIZWlnaHQiLCJkZWZhdWx0QWxsRGF5IiwiZXZlbnRTb3VyY2VGYWlsdXJlIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiZXZlbnREaXNwbGF5IiwiZXZlbnRTdGFydEVkaXRhYmxlIiwiZXZlbnREdXJhdGlvbkVkaXRhYmxlIiwiZXZlbnRPdmVybGFwIiwiZXZlbnRDb25zdHJhaW50IiwiZXZlbnRBbGxvdyIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiZXZlbnRCb3JkZXJDb2xvciIsImV2ZW50VGV4dENvbG9yIiwiZXZlbnRDb2xvciIsImV2ZW50Q2xhc3NOYW1lcyIsImV2ZW50Q29udGVudCIsImV2ZW50RGlkTW91bnQiLCJldmVudFdpbGxVbm1vdW50Iiwic2VsZWN0Q29uc3RyYWludCIsInNlbGVjdE92ZXJsYXAiLCJzZWxlY3RBbGxvdyIsImRyb3BwYWJsZSIsInVuc2VsZWN0Q2FuY2VsIiwic2xvdExhYmVsRm9ybWF0Iiwic2xvdExhbmVDbGFzc05hbWVzIiwic2xvdExhbmVDb250ZW50Iiwic2xvdExhbmVEaWRNb3VudCIsInNsb3RMYW5lV2lsbFVubW91bnQiLCJzbG90TGFiZWxDbGFzc05hbWVzIiwic2xvdExhYmVsQ29udGVudCIsInNsb3RMYWJlbERpZE1vdW50Iiwic2xvdExhYmVsV2lsbFVubW91bnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJkYXlNaW5XaWR0aCIsInNsb3RMYWJlbEludGVydmFsIiwiYWxsRGF5VGV4dCIsImFsbERheUNsYXNzTmFtZXMiLCJhbGxEYXlDb250ZW50IiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsInNsb3RNaW5XaWR0aCIsIm5hdkxpbmtzIiwiZXZlbnRUaW1lRm9ybWF0IiwicmVyZW5kZXJEZWxheSIsIm1vcmVMaW5rVGV4dCIsIm1vcmVMaW5rSGludCIsInNlbGVjdE1pbkRpc3RhbmNlIiwic2VsZWN0YWJsZSIsInNlbGVjdExvbmdQcmVzc0RlbGF5IiwiZXZlbnRMb25nUHJlc3NEZWxheSIsInNlbGVjdE1pcnJvciIsImV2ZW50TWF4U3RhY2siLCJldmVudE1pbkhlaWdodCIsImV2ZW50TWluV2lkdGgiLCJldmVudFNob3J0SGVpZ2h0Iiwic2xvdEV2ZW50T3ZlcmxhcCIsInBsdWdpbnMiLCJmaXJzdERheSIsImRheUNvdW50IiwiZGF0ZUFsaWdubWVudCIsImRhdGVJbmNyZW1lbnQiLCJoaWRkZW5EYXlzIiwiZml4ZWRXZWVrQ291bnQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlIiwidGl0bGVGb3JtYXQiLCJldmVudEludGVyYWN0aXZlIiwibm9FdmVudHNUZXh0Iiwidmlld0hpbnQiLCJuYXZMaW5rSGludCIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwibW9yZUxpbmtDbGljayIsIm1vcmVMaW5rQ2xhc3NOYW1lcyIsIm1vcmVMaW5rQ29udGVudCIsIm1vcmVMaW5rRGlkTW91bnQiLCJtb3JlTGlua1dpbGxVbm1vdW50IiwibW9udGhTdGFydEZvcm1hdCIsImhhbmRsZUN1c3RvbVJlbmRlcmluZyIsImN1c3RvbVJlbmRlcmluZ01ldGFNYXAiLCJjdXN0b21SZW5kZXJpbmdSZXBsYWNlcyIsIkJBU0VfT1BUSU9OX0RFRkFVTFRTIiwiY2VudGVyIiwiQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMiLCJkYXRlc1NldCIsImV2ZW50c1NldCIsImV2ZW50QWRkIiwiZXZlbnRDaGFuZ2UiLCJldmVudFJlbW92ZSIsIndpbmRvd1Jlc2l6ZSIsImV2ZW50Q2xpY2siLCJldmVudE1vdXNlRW50ZXIiLCJldmVudE1vdXNlTGVhdmUiLCJzZWxlY3QiLCJ1bnNlbGVjdCIsImxvYWRpbmciLCJfdW5tb3VudCIsIl9iZWZvcmVwcmludCIsIl9hZnRlcnByaW50IiwiX25vRXZlbnREcm9wIiwiX25vRXZlbnRSZXNpemUiLCJfcmVzaXplIiwiX3Njcm9sbFJlcXVlc3QiLCJDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMiLCJidXR0b25UZXh0IiwiYnV0dG9uSGludHMiLCJ2aWV3cyIsImluaXRpYWxFdmVudHMiLCJldmVudHMiLCJldmVudFNvdXJjZXMiLCJDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyIsImlzTWF5YmVPYmplY3RzRXF1YWwiLCJpc01heWJlQXJyYXlzRXF1YWwiLCJWSUVXX09QVElPTl9SRUZJTkVSUyIsInR5cGUiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsIm1lcmdlUHJvcHMiLCJyZWZpbmVQcm9wcyIsInJlZmluZXJzIiwicmVmaW5lZCIsImV4dHJhIiwicmF3IiwiaGFzT3duUHJvcGVydHkiLCJwcm90b3R5cGUiLCJwcm9wT2JqcyIsImNvbXBsZXhQcm9wc01hcCIsImRlc3QiLCJjb21wbGV4T2JqcyIsInVuc2hpZnQiLCJmaWx0ZXJIYXNoIiwiaGFzaCIsImZpbHRlcmVkIiwibWFwSGFzaCIsIm5ld0hhc2giLCJhcnJheVRvSGFzaCIsIml0ZW0iLCJoYXNoVmFsdWVzVG9BcnJheSIsIkhBTkRMRVJfUkUiLCJpc05vbkhhbmRsZXJQcm9wc0VxdWFsIiwiZ2V0VW5lcXVhbFByb3BzIiwiY29tcGFyZU9ianMiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwiZXF1YWxpdHlGdW5jcyIsImlzT2JqVmFsc0VxdWFsIiwidmFsMCIsInZhbDEiLCJjb21wYXJhdG9yIiwiY29sbGVjdEZyb21IYXNoIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwic3RlcCIsImNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAiLCJyZWdpc3RlckNhbGVuZGFyU3lzdGVtIiwidGhlQ2xhc3MiLCJjcmVhdGVDYWxlbmRhclN5c3RlbSIsIkdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIiwiYXJyYXlUb01hcmtlciIsImFyciIsIklTT19SRSIsInBhcnNlIiwiaXNUaW1lVW5zcGVjaWZpZWQiLCJEYXRlRW52Iiwic2V0dGluZ3MiLCJpc05hbWVkVGltZVpvbmUiLCJuYW1lZFRpbWVab25lSW1wbCIsImNhbkNvbXB1dGVPZmZzZXQiLCJ3ZWVrRG93Iiwid2Vla0RveSIsIndlZWtOdW1iZXJGdW5jIiwiY3JlYXRlTWFya2VyIiwibWV0YSIsImNyZWF0ZU1hcmtlck1ldGEiLCJjcmVhdGVOb3dNYXJrZXIiLCJ0aW1lc3RhbXBUb01hcmtlciIsImZvcmNlZFR6byIsImdldFllYXIiLCJnZXREYXkiLCJzdWJ0cmFjdCIsImFkZFllYXJzIiwiYWRkTW9udGhzIiwiZGlmZldob2xlWWVhcnMiLCJkaWZmV2hvbGVNb250aHMiLCJncmVhdGVzdFdob2xlVW5pdCIsImNvdW50RHVyYXRpb25zQmV0d2VlbiIsImRpZmYiLCJzdGFydE9mIiwic3RhcnRPZlllYXIiLCJzdGFydE9mTW9udGgiLCJzdGFydE9mV2VlayIsInRvRGF0ZSIsImRhdGVPcHRpb25zIiwib2Zmc2V0Rm9yTWFya2VyIiwiaXNFbmRFeGNsdXNpdmUiLCJmb3JjZWRTdGFydFR6byIsImZvcmNlZEVuZFR6byIsImZvcm1hdElzbyIsImV4dHJhT3B0aW9ucyIsIm9taXRUaW1lWm9uZU9mZnNldCIsIm9taXRUaW1lIiwidGltZXN0YW1wVG9BcnJheSIsImdldFRpbWV6b25lT2Zmc2V0Iiwib2Zmc2V0Rm9yQXJyYXkiLCJUaGVtZSIsImNhbGVuZGFyT3B0aW9ucyIsImljb25PdmVycmlkZU9wdGlvbiIsInNldEljb25PdmVycmlkZSIsImljb25PdmVycmlkZUhhc2giLCJpY29uQ2xhc3Nlc0NvcHkiLCJidXR0b25OYW1lIiwiaWNvbkNsYXNzZXMiLCJhcHBseUljb25PdmVycmlkZVByZWZpeCIsImNsYXNzTmFtZSIsInByZWZpeCIsImljb25PdmVycmlkZVByZWZpeCIsImdldENsYXNzIiwiY2xhc3NlcyIsImdldEljb25DbGFzcyIsImlzUnRsIiwicnRsSWNvbkNsYXNzZXMiLCJiYXNlSWNvbkNsYXNzIiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJmbHVzaFN5bmMiLCJydW5CZWZvcmVGbHVzaCIsIm9sZERlYm91bmNlUmVuZGVyaW5nIiwiZGVib3VuY2VSZW5kZXJpbmciLCJjYWxsYmFja1EiLCJleGVjQ2FsbGJhY2tTeW5jIiwicmVuZGVyIiwiRmFrZUNvbXBvbmVudCIsInNoaWZ0IiwiY29tcG9uZW50RGlkTW91bnQiLCJzZXRTdGF0ZSIsImNyZWF0ZUNvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJDb250ZXh0VHlwZSIsIm9yaWdQcm92aWRlciIsIlByb3ZpZGVyIiwiaXNOZXciLCJnZXRDaGlsZENvbnRleHQiLCJhcmd1bWVudHMiLCJzdWJzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiX3Byb3BzIiwiYyIsImZvcmNlVXBkYXRlIiwic3ViIiwib2xkIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJTY3JvbGxSZXNwb25kZXIiLCJleGVjRnVuYyIsImVtaXR0ZXIiLCJoYW5kbGVTY3JvbGxSZXF1ZXN0IiwicXVldWVkUmVxdWVzdCIsImRyYWluIiwib24iLCJmaXJlSW5pdGlhbFNjcm9sbCIsImRldGFjaCIsIm9mZiIsInVwZGF0ZSIsImlzRGF0ZXNOZXciLCJ0aW1lIiwiVmlld0NvbnRleHRUeXBlIiwiYnVpbGRWaWV3Q29udGV4dCIsInZpZXdTcGVjIiwidmlld0FwaSIsInZpZXdPcHRpb25zIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJkYXRlRW52Iiwibm93TWFuYWdlciIsInRoZW1lIiwicGx1Z2luSG9va3MiLCJkaXNwYXRjaCIsImdldEN1cnJlbnREYXRhIiwiY2FsZW5kYXJBcGkiLCJyZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiYWRkUmVzaXplSGFuZGxlciIsInJlbW92ZVJlc2l6ZUhhbmRsZXIiLCJjcmVhdGVTY3JvbGxSZXNwb25kZXIiLCJQdXJlQ29tcG9uZW50IiwibmV4dFByb3BzIiwibmV4dFN0YXRlIiwiZGVidWciLCJjb25zb2xlIiwibG9nIiwic3RhdGUiLCJwcm9wRXF1YWxpdHkiLCJzdGF0ZUVxdWFsaXR5Iiwic2FmZVNldFN0YXRlIiwibmV3U3RhdGUiLCJhZGRQcm9wc0VxdWFsaXR5IiwiYWRkU3RhdGVFcXVhbGl0eSIsImNvbnRleHRUeXBlIiwiQmFzZUNvbXBvbmVudCIsImNyZWF0ZSIsInNldFJlZiIsInJlZiIsImN1cnJlbnQiLCJDb250ZW50SW5qZWN0b3IiLCJpZCIsInF1ZXVlZERvbU5vZGVzIiwiY3VycmVudERvbU5vZGVzIiwiaGFuZGxlRWwiLCJnZW5lcmF0b3JOYW1lIiwiaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlciIsInVwZGF0ZUVsUmVmIiwiZWxSZWYiLCJjdXN0b21HZW5lcmF0b3IiLCJkZWZhdWx0R2VuZXJhdG9yIiwicmVuZGVyUHJvcHMiLCJhdHRycyIsImJ1aWxkRWxBdHRycyIsInVzZURlZmF1bHQiLCJpbm5lckNvbnRlbnQiLCJjdXJyZW50R2VuZXJhdG9yTWV0YSIsImN1c3RvbUdlbmVyYXRvclJlcyIsImlzT2JqZWN0IiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJodG1sIiwic2xpY2UiLCJkb21Ob2RlcyIsImVsVGFnIiwiYXBwbHlRdWV1ZXVkRG9tTm9kZXMiLCJ0cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaXNBY3RpdmUiLCJnZW5lcmF0b3JNZXRhIiwiY29udGFpbmVyRWwiLCJiYXNlIiwicmVwb3J0TmV3Q29udGFpbmVyRWwiLCJlbENsYXNzZXMiLCJmaWx0ZXIiLCJpc1RydXRoeSIsIm5ld05vZGUiLCJhcHBlbmRDaGlsZCIsImVsU3R5bGUiLCJlbEF0dHJzIiwiZXh0cmFDbGFzc05hbWVzIiwiUmVuZGVySWQiLCJDb250ZW50Q29udGFpbmVyIiwiSW5uZXJDb250ZW50IiwiSW5uZXJDb250ZW50SW5qZWN0b3IiLCJkaWRNb3VudE1pc2ZpcmUiLCJnZW5lcmF0ZWRDbGFzc05hbWVzIiwiZ2VuZXJhdGVDbGFzc05hbWVzIiwiY2xhc3NOYW1lR2VuZXJhdG9yIiwicmVuZGVySWQiLCJjb250YWluZXJDb21wb25lbnQiLCJwYXJlbnRQcm9wcyIsIlZpZXdDb250YWluZXIiLCJ2aWV3IiwiYnVpbGRWaWV3Q2xhc3NOYW1lcyIsInBhcnNlUmFuZ2UiLCJpbnZlcnRSYW5nZXMiLCJyYW5nZXMiLCJjb25zdHJhaW50UmFuZ2UiLCJpbnZlcnRlZFJhbmdlcyIsImRhdGVSYW5nZSIsInNvcnQiLCJjb21wYXJlUmFuZ2VzIiwicmFuZ2UwIiwicmFuZ2UxIiwiaW50ZXJzZWN0UmFuZ2VzIiwibmV3UmFuZ2UiLCJtYXgiLCJyYW5nZXNFcXVhbCIsInJhbmdlc0ludGVyc2VjdCIsInJhbmdlQ29udGFpbnNSYW5nZSIsIm91dGVyUmFuZ2UiLCJpbm5lclJhbmdlIiwicmFuZ2VDb250YWluc01hcmtlciIsInJhbmdlIiwiY29uc3RyYWluTWFya2VyVG9SYW5nZSIsImNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UiLCJ0aW1lZFJhbmdlIiwiZGF5Q250IiwiY29tcHV0ZVZpc2libGVEYXlSYW5nZSIsInN0YXJ0RGF5IiwiZW5kRGF5IiwiZW5kVGltZU1TIiwiaXNNdWx0aURheVJhbmdlIiwiZGlmZkRhdGVzIiwiZGF0ZTAiLCJkYXRlMSIsImxhcmdlVW5pdCIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiaW5pdEhpZGRlbkRheXMiLCJidWlsZFByZXYiLCJjdXJyZW50RGF0ZVByb2ZpbGUiLCJjdXJyZW50RGF0ZSIsImZvcmNlVG9WYWxpZCIsInByZXZEYXRlIiwiY3VycmVudFJhbmdlVW5pdCIsImJ1aWxkIiwiYnVpbGROZXh0IiwibmV4dERhdGUiLCJjdXJyZW50SW5mbyIsImlzUmFuZ2VBbGxEYXkiLCJyZW5kZXJSYW5nZSIsImFjdGl2ZVJhbmdlIiwiaXNWYWxpZCIsImJ1aWxkVmFsaWRSYW5nZSIsInRyaW1IaWRkZW5EYXlzIiwiYnVpbGRDdXJyZW50UmFuZ2VJbmZvIiwiYnVpbGRSZW5kZXJSYW5nZSIsImFkanVzdEFjdGl2ZVJhbmdlIiwiY3VycmVudFJhbmdlIiwiYnVpbGREYXRlSW5jcmVtZW50IiwidmFsaWRSYW5nZUlucHV0Iiwic2ltcGxlSW5wdXQiLCJnZXREYXRlTWFya2VyIiwicmVmaW5lUmFuZ2UiLCJkdXJhdGlvblVuaXQiLCJidWlsZFJhbmdlRnJvbUR1cmF0aW9uIiwiYnVpbGRSYW5nZUZyb21EYXlDb3VudCIsImJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlIiwiZ2V0RmFsbGJhY2tEdXJhdGlvbiIsImlzSGlkZGVuRGF5Iiwic2tpcEhpZGRlbkRheXMiLCJjb21wdXRlUmVzIiwicnVubmluZ0NvdW50IiwidmlzaWJsZVJhbmdlSW5wdXQiLCJmYWxsYmFjayIsImN1c3RvbUFsaWdubWVudCIsInJhbmdlSW5wdXQiLCJpc0hpZGRlbkRheUhhc2giLCJpbmMiLCJpc0V4Y2x1c2l2ZSIsImNyZWF0ZUV2ZW50SW5zdGFuY2UiLCJkZWZJZCIsImluc3RhbmNlSWQiLCJwYXJzZVJlY3VycmluZyIsInJlY3VycmluZ1R5cGVzIiwicGFyc2VkIiwiYWxsRGF5IiwiYWxsRGF5R3Vlc3MiLCJ0eXBlRGF0YSIsInR5cGVJZCIsImV4cGFuZFJlY3VycmluZyIsImV2ZW50U3RvcmUiLCJmcmFtaW5nUmFuZ2UiLCJkZWZzIiwiaW5zdGFuY2VzIiwiaW5zdGFuY2UiLCJyZWN1cnJpbmdEZWYiLCJkZWYiLCJzdGFydHMiLCJleHBhbmRSZWN1cnJpbmdSYW5nZXMiLCJldmVudERlZiIsInR5cGVEZWYiLCJtYXJrZXJzIiwiZXhwYW5kIiwibWFwIiwiRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMiLCJncm91cElkIiwidGl0bGUiLCJ1cmwiLCJpbnRlcmFjdGl2ZSIsIkVWRU5UX0RBVEVfUkVGSU5FUlMiLCJFVkVOVF9SRUZJTkVSUyIsImV4dGVuZGVkUHJvcHMiLCJwYXJzZUV2ZW50IiwiZXZlbnRTb3VyY2UiLCJhbGxvd09wZW5SYW5nZSIsImJ1aWxkRXZlbnRSZWZpbmVycyIsImRlZklkTWFwIiwiaW5zdGFuY2VJZE1hcCIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzb3VyY2VJZCIsInNpbmdsZVJlcyIsInBhcnNlU2luZ2xlIiwiaGFzRW5kIiwicHVibGljSWQiLCJFVkVOVF9VSV9SRUZJTkVSUyIsImV2ZW50UmVmaW5lcnMiLCJ1aSIsImNyZWF0ZUV2ZW50VWkiLCJtZW1iZXJBZGRlciIsImV2ZW50RGVmTWVtYmVyQWRkZXJzIiwiZnJlZXplIiwic3RhcnRNZXRhIiwic3RhcnRNYXJrZXIiLCJlbmRNZXRhIiwiZW5kTWFya2VyIiwic3RhcnRJbnB1dCIsInBhcnNlRXZlbnRzIiwicmF3RXZlbnRzIiwiY3JlYXRlRW1wdHlFdmVudFN0b3JlIiwicmF3RXZlbnQiLCJ0dXBsZSIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZ2V0UmVsZXZhbnRFdmVudHMiLCJuZXdTdG9yZSIsImZpbHRlckV2ZW50U3RvcmVEZWZzIiwibG9va0RlZiIsImlzRXZlbnREZWZzR3JvdXBlZCIsImRlZjAiLCJkZWYxIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsInN0YXJ0RWRpdGFibGUiLCJkdXJhdGlvbkVkaXRhYmxlIiwiY29uc3RyYWludCIsIm92ZXJsYXAiLCJhbGxvdyIsImNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJ0ZXh0Q29sb3IiLCJFTVBUWV9FVkVOVF9VSSIsImNvbnN0cmFpbnRzIiwiYWxsb3dzIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX1NPVVJDRV9SRUZJTkVSUyIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwicGFyc2VFdmVudFNvdXJjZSIsImJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyIsInJhd09iaiIsIm1ldGFSZXMiLCJidWlsZEV2ZW50U291cmNlTWV0YSIsIl9yYXciLCJpc0ZldGNoaW5nIiwibGF0ZXN0RmV0Y2hJZCIsImZldGNoUmFuZ2UiLCJzb3VyY2VEZWZJZCIsImV2ZW50U291cmNlUmVmaW5lcnMiLCJldmVudFNvdXJjZURlZnMiLCJwYXJzZU1ldGEiLCJyZWR1Y2VFdmVudFN0b3JlIiwiYWN0aW9uIiwiZGF0ZVByb2ZpbGUiLCJyZWNlaXZlUmF3RXZlbnRzIiwiZmV0Y2hJZCIsInJlc2V0UmF3RXZlbnRzIiwiYWRkRXZlbnQiLCJleGNsdWRlRXZlbnRzQnlTb3VyY2VJZCIsInN1YnNldCIsInRyYW5zZm9ybVJhd0V2ZW50cyIsImV4aXN0aW5nRXZlbnRTdG9yZSIsImJ1aWxkUHVibGljSWRNYXBzIiwibmV3RXZlbnRTdG9yZSIsImNhbEVhY2hUcmFuc2Zvcm0iLCJzb3VyY2VFYWNoVHJhbnNmb3JtIiwidHJhbnNmb3JtRWFjaFJhd0V2ZW50IiwicmVmaW5lZEV2ZW50cyIsInJlZmluZWRFdmVudCIsImV4cGFuZFJhbmdlIiwicmV6b25lRXZlbnRTdG9yZURhdGVzIiwib2xkRGF0ZUVudiIsIm5ld0RhdGVFbnYiLCJleGNsdWRlSW5zdGFuY2VzIiwicmVtb3ZhbHMiLCJFbWl0dGVyIiwiaGFuZGxlcnMiLCJ0aGlzQ29udGV4dCIsInNldFRoaXNDb250ZXh0Iiwic2V0T3B0aW9ucyIsImFkZFRvSGFzaCIsInJlbW92ZUZyb21IYXNoIiwidHJpZ2dlciIsImF0dGFjaGVkSGFuZGxlcnMiLCJvcHRpb25IYW5kbGVyIiwiaGFzSGFuZGxlcnMiLCJERUZfREVGQVVMVFMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZGF5c09mV2VlayIsInBhcnNlQnVzaW5lc3NIb3VycyIsInJlZmluZUlucHV0cyIsInJhd0RlZnMiLCJyYXdEZWYiLCJ0cmlnZ2VyRGF0ZVNlbGVjdCIsInNlbGVjdGlvbiIsInBldiIsImJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dCIsImpzRXZlbnQiLCJvcmlnRXZlbnQiLCJ0cmlnZ2VyRGF0ZVVuc2VsZWN0IiwiZGF0ZVNwYW4iLCJ0cmFuc2Zvcm0iLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJidWlsZERhdGVTcGFuQXBpIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwiYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSIsImV2ZW50Q29uZmlnQmFzZSIsIm11dGF0aW9uIiwiZXZlbnRDb25maWdzIiwiY29tcGlsZUV2ZW50VWlzIiwiYXBwbHlNdXRhdGlvblRvRXZlbnREZWYiLCJhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlIiwiZXZlbnRDb25maWciLCJzdGFuZGFyZFByb3BzIiwic3RhcnREZWx0YSIsImVuZERlbHRhIiwiY29weSIsImFwcGxpZXIiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJldmVudEluc3RhbmNlIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJFdmVudFNvdXJjZUltcGwiLCJpbnRlcm5hbEV2ZW50U291cmNlIiwicmVmZXRjaCIsInNvdXJjZUlkcyIsImlzUmVmZXRjaCIsIkV2ZW50SW1wbCIsIl9jb250ZXh0IiwiX2RlZiIsIl9pbnN0YW5jZSIsInNldFByb3AiLCJ3YXJuIiwibXV0YXRlIiwic2V0RXh0ZW5kZWRQcm9wIiwic2V0U3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiZ3JhbnVsYXJpdHkiLCJtYWludGFpbkR1cmF0aW9uIiwic2V0RW5kIiwiZW5kSW5wdXQiLCJzZXREYXRlcyIsIm1vdmVTdGFydCIsImRlbHRhSW5wdXQiLCJkZWx0YSIsIm1vdmVFbmQiLCJtb3ZlRGF0ZXMiLCJzZXRBbGxEYXkiLCJmb3JtYXRJbnB1dCIsInJlbGV2YW50RXZlbnRzIiwib2xkRXZlbnQiLCJldmVudCIsInJlbGF0ZWRFdmVudHMiLCJidWlsZEV2ZW50QXBpcyIsInJldmVydCIsImFzU3RvcmUiLCJldmVudEFwaVRvU3RvcmUiLCJzb3VyY2UiLCJzdGFydFN0ciIsImVuZFN0ciIsInRvUGxhaW5PYmplY3QiLCJjb2xsYXBzZUNvbG9yIiwiY29sbGFwc2VFeHRlbmRlZFByb3BzIiwidG9KU09OIiwiZXZlbnRBcGkiLCJleGNsdWRlSW5zdGFuY2UiLCJldmVudEFwaXMiLCJleGNsdWRlSW5zdGFuY2VJZCIsInNsaWNlRXZlbnRTdG9yZSIsImV2ZW50VWlCYXNlcyIsImludmVyc2VCZ0J5R3JvdXBJZCIsImludmVyc2VCZ0J5RGVmSWQiLCJkZWZCeUdyb3VwSWQiLCJiZ1JhbmdlcyIsImZnUmFuZ2VzIiwiZXZlbnRVaXMiLCJvcmlnUmFuZ2UiLCJub3JtYWxSYW5nZSIsInNsaWNlZFJhbmdlIiwiaXNTdGFydCIsImlzRW5kIiwiaW52ZXJ0ZWRSYW5nZSIsImJnIiwiZmciLCJoYXNCZ1JlbmRlcmluZyIsInNldEVsU2VnIiwic2VnIiwiZmNTZWciLCJnZXRFbFNlZyIsImV2ZW50RGVmcyIsImNvbXBpbGVFdmVudFVpIiwic29ydEV2ZW50U2VncyIsInNlZ3MiLCJldmVudE9yZGVyU3BlY3MiLCJvYmpzIiwiYnVpbGRTZWdDb21wYXJlT2JqIiwiX3NlZyIsImV2ZW50UmFuZ2UiLCJjb21wdXRlU2VnRHJhZ2dhYmxlIiwidHJhbnNmb3JtZXJzIiwiaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lciIsImNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSIsImNvbXB1dGVTZWdFbmRSZXNpemFibGUiLCJidWlsZFNlZ1RpbWVUZXh0IiwidGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRUaW1lIiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsInN0YXJ0T3ZlcnJpZGUiLCJlbmRPdmVycmlkZSIsIndob2xlRXZlbnRTdGFydCIsIndob2xlRXZlbnRFbmQiLCJzZWdTdGFydCIsInNlZ0VuZCIsImlzU3RhcnREYXkiLCJpc0VuZERheSIsImdldFNlZ01ldGEiLCJ0b2RheVJhbmdlIiwibm93RGF0ZSIsInNlZ1JhbmdlIiwiaXNQYXN0IiwiaXNGdXR1cmUiLCJpc1RvZGF5IiwiZ2V0RXZlbnRDbGFzc05hbWVzIiwiaXNNaXJyb3IiLCJpc0RyYWdnYWJsZSIsImlzU3RhcnRSZXNpemFibGUiLCJpc0VuZFJlc2l6YWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNTZWxlY3RlZCIsImJ1aWxkRXZlbnRSYW5nZUtleSIsImdldFNlZ0FuY2hvckF0dHJzIiwiaHJlZiIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsImlzRGF0ZVNwYW5zRXF1YWwiLCJzcGFuMCIsInNwYW4xIiwiaXNTcGFuUHJvcHNFcXVhbCIsImJ1aWxkUmFuZ2VBcGkiLCJidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsInVucHJvbWlzaWZ5Iiwibm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjayIsIm5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2siLCJpc1Jlc29sdmVkIiwid3JhcHBlZFN1Y2Nlc3MiLCJ3cmFwcGVkRmFpbHVyZSIsImVycm9yIiwidGhlbiIsIkpzb25SZXF1ZXN0RXJyb3IiLCJtZXNzYWdlIiwicmVzcG9uc2UiLCJyZXF1ZXN0SnNvbiIsInBhcmFtcyIsInRvVXBwZXJDYXNlIiwiZmV0Y2hPcHRpb25zIiwiVVJMU2VhcmNoUGFyYW1zIiwiaGVhZGVycyIsImZldGNoIiwiZmV0Y2hSZXMiLCJvayIsImpzb24iLCJwYXJzZWRSZXNwb25zZSIsImNhblZHcm93V2l0aGluQ2VsbCIsImdldENhblZHcm93V2l0aGluQ2VsbCIsImNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJpbm5lckhUTUwiLCJkaXYiLCJwb3NzaWJsZSIsIm9mZnNldEhlaWdodCIsIkNhbGVuZGFyUm9vdCIsImZvclByaW50IiwiaGFuZGxlQmVmb3JlUHJpbnQiLCJoYW5kbGVBZnRlclByaW50IiwiaXNIZWlnaHRBdXRvIiwiSW50ZXJhY3Rpb24iLCJpc0hpdENvbWJvQWxsb3dlZCIsImRlc3Ryb3kiLCJwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MiLCJ1c2VFdmVudENlbnRlciIsImludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIiwidWlkIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIiwiTm93VGltZXIiLCJoYW5kbGVSZWZyZXNoIiwidGltaW5nIiwiY29tcHV0ZVRpbWluZyIsIndhaXRNcyIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJoaWRkZW4iLCJhZGRSZXNldExpc3RlbmVyIiwicHJldlByb3BzIiwicmVtb3ZlUmVzZXRMaXN0ZW5lciIsInVucm91bmRlZE5vdyIsImN1cnJlbnRVbml0U3RhcnQiLCJuZXh0VW5pdFN0YXJ0IiwiYnVpbGREYXlSYW5nZSIsIkNhbGVuZGFySW1wbCIsImN1cnJlbnREYXRhTWFuYWdlciIsImJhdGNoUmVuZGVyaW5nIiwidXBkYXRlU2l6ZSIsInNldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsImdldE9wdGlvbiIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImdldEF2YWlsYWJsZUxvY2FsZUNvZGVzIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsImhhbmRsZXJOYW1lIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzIiwiY2hhbmdlVmlldyIsInZpZXdUeXBlIiwiZGF0ZU9yUmFuZ2UiLCJkYXRlTWFya2VyIiwiem9vbVRvIiwic3BlYyIsInZpZXdTcGVjcyIsImdldFVuaXRWaWV3U3BlYyIsInRvb2xiYXJDb25maWciLCJ2aWV3VHlwZXMiLCJoZWFkZXIiLCJ2aWV3c1dpdGhCdXR0b25zIiwiZm9vdGVyIiwic2luZ2xlVW5pdCIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJuZXh0WWVhciIsInRvZGF5IiwiZ290b0RhdGUiLCJ6b25lZERhdGVJbnB1dCIsImluY3JlbWVudERhdGUiLCJmb3JtYXREYXRlIiwiZGF0ZU9yT2JqIiwiZW5kRGF0ZSIsInNlbGVjdGlvbklucHV0IiwiZGF0ZVNlbGVjdGlvbiIsImV2ZW50SW5wdXQiLCJzb3VyY2VJbnB1dCIsImN1cnJlbnREYXRhIiwidHJpZ2dlckV2ZW50QWRkIiwic291cmNlQXBpIiwiZ2V0RXZlbnRTb3VyY2VCeUlkIiwibmV3RXZlbnRBcGkiLCJnZXRFdmVudEJ5SWQiLCJnZXRFdmVudHMiLCJyZW1vdmVBbGxFdmVudHMiLCJnZXRFdmVudFNvdXJjZXMiLCJzb3VyY2VIYXNoIiwic291cmNlQXBpcyIsImludGVybmFsSWQiLCJhZGRFdmVudFNvdXJjZSIsInNvdXJjZXMiLCJyZW1vdmVBbGxFdmVudFNvdXJjZXMiLCJyZWZldGNoRXZlbnRzIiwic2Nyb2xsVG9UaW1lIiwidGltZUlucHV0IiwicG9pbnRJbnNpZGVSZWN0IiwicG9pbnQiLCJyZWN0IiwicmlnaHQiLCJib3R0b20iLCJpbnRlcnNlY3RSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJ0cmFuc2xhdGVSZWN0IiwiZGVsdGFYIiwiZGVsdGFZIiwiY29uc3RyYWluUG9pbnQiLCJnZXRSZWN0Q2VudGVyIiwiZGlmZlBvaW50cyIsInBvaW50MSIsInBvaW50MiIsIkVNUFRZX0VWRU5UX1NUT1JFIiwiU3BsaXR0ZXIiLCJnZXRLZXlzRm9yRXZlbnREZWZzIiwiX2dldEtleXNGb3JFdmVudERlZnMiLCJzcGxpdERhdGVTZWxlY3Rpb24iLCJfc3BsaXREYXRlU3BhbiIsInNwbGl0RXZlbnRTdG9yZSIsIl9zcGxpdEV2ZW50U3RvcmUiLCJzcGxpdEluZGl2aWR1YWxVaSIsIl9zcGxpdEluZGl2aWR1YWxVaSIsInNwbGl0RXZlbnREcmFnIiwiX3NwbGl0SW50ZXJhY3Rpb24iLCJzcGxpdEV2ZW50UmVzaXplIiwiZXZlbnRVaUJ1aWxkZXJzIiwic3BsaXRQcm9wcyIsImtleUluZm9zIiwiZ2V0S2V5SW5mbyIsImRlZktleXMiLCJkYXRlU2VsZWN0aW9ucyIsImluZGl2aWR1YWxVaSIsImV2ZW50U3RvcmVzIiwiZXZlbnREcmFncyIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplcyIsImV2ZW50UmVzaXplIiwiaW5mbyIsImJ1aWxkRXZlbnRVaUZvcktleSIsImtleUluZm8iLCJidWlsZEV2ZW50VWkiLCJldmVudFNlbGVjdGlvbiIsImRhdGVTcGFucyIsImdldEtleXNGb3JEYXRlU3BhbiIsImdldEtleXNGb3JFdmVudERlZiIsInNwbGl0U3RvcmVzIiwic3BsaXRIYXNoZXMiLCJpbnRlcmFjdGlvbiIsInNwbGl0U3RhdGVzIiwiYWZmZWN0ZWRTdG9yZXMiLCJhZmZlY3RlZEV2ZW50cyIsIm11dGF0ZWRLZXlzQnlEZWZJZCIsIm11dGF0ZWRFdmVudHMiLCJtdXRhdGVkU3RvcmVzIiwicG9wdWxhdGUiLCJpc0V2ZW50IiwiYWxsVWkiLCJldmVudFVpRm9yS2V5IiwiYmFzZVBhcnRzIiwic3R1ZmYiLCJnZXREYXRlTWV0YSIsImlzRGlzYWJsZWQiLCJpc090aGVyIiwiZ2V0RGF5Q2xhc3NOYW1lcyIsImdldFNsb3RDbGFzc05hbWVzIiwiREFZX0ZPUk1BVCIsIldFRUtfRk9STUFUIiwiYnVpbGROYXZMaW5rQXR0cnMiLCJpc1RhYmJhYmxlIiwiZGF0ZVN0ciIsInpvbmVkRGF0ZSIsImhhbmRsZUludGVyYWN0aW9uIiwiY3VzdG9tQWN0aW9uIiwiX2lzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJvdXRlckVsIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiaW5uZXJFbCIsIl9zY3JvbGxiYXJXaWR0aHMiLCJnZXRTY3JvbGxiYXJXaWR0aHMiLCJjb21wdXRlU2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsIiwieCIsImNsaWVudEhlaWdodCIsIm9mZnNldFdpZHRoIiwiY2xpZW50V2lkdGgiLCJjb21wdXRlRWRnZXMiLCJnZXRQYWRkaW5nIiwiY29tcHV0ZWRTdHlsZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJib3JkZXJMZWZ0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21XaWR0aCIsImJhZFNjcm9sbGJhcldpZHRocyIsInNjcm9sbGJhckxlZnRSaWdodCIsInNjcm9sbGJhckJvdHRvbSIsInNjcm9sbGJhckxlZnQiLCJzY3JvbGxiYXJSaWdodCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJjb21wdXRlSW5uZXJSZWN0IiwiZ29XaXRoaW5QYWRkaW5nIiwiZG9Gcm9tV2luZG93Vmlld3BvcnQiLCJvdXRlclJlY3QiLCJjb21wdXRlUmVjdCIsImVkZ2VzIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QiLCJjbGlwcGluZ1BhcmVudHMiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjbGlwcGluZ1BhcmVudCIsImludGVyc2VjdGlvbiIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIlBvc2l0aW9uQ2FjaGUiLCJvcmlnaW5FbCIsImVscyIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJvcmlnaW5DbGllbnRSZWN0IiwiYnVpbGRFbEhvcml6b250YWxzIiwiYnVpbGRFbFZlcnRpY2FscyIsIm9yaWdpbkNsaWVudExlZnQiLCJsZWZ0cyIsInJpZ2h0cyIsIm9yaWdpbkNsaWVudFRvcCIsInRvcHMiLCJib3R0b21zIiwibGVmdFRvSW5kZXgiLCJsZWZ0UG9zaXRpb24iLCJ0b3BUb0luZGV4IiwidG9wUG9zaXRpb24iLCJnZXRXaWR0aCIsImxlZnRJbmRleCIsImdldEhlaWdodCIsInRvcEluZGV4Iiwic2ltaWxhclRvIiwib3RoZXJDYWNoZSIsInNpbWlsYXJOdW1BcnJheXMiLCJTY3JvbGxDb250cm9sbGVyIiwiZ2V0TWF4U2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsSGVpZ2h0IiwiZ2V0Q2xpZW50SGVpZ2h0IiwiZ2V0TWF4U2Nyb2xsTGVmdCIsImdldFNjcm9sbFdpZHRoIiwiZ2V0Q2xpZW50V2lkdGgiLCJjYW5TY3JvbGxWZXJ0aWNhbGx5IiwiY2FuU2Nyb2xsSG9yaXpvbnRhbGx5IiwiY2FuU2Nyb2xsVXAiLCJnZXRTY3JvbGxUb3AiLCJjYW5TY3JvbGxEb3duIiwiY2FuU2Nyb2xsTGVmdCIsImdldFNjcm9sbExlZnQiLCJjYW5TY3JvbGxSaWdodCIsIkVsZW1lbnRTY3JvbGxDb250cm9sbGVyIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsInNldFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsIldpbmRvd1Njcm9sbENvbnRyb2xsZXIiLCJzY3JvbGwiLCJEYXRlQ29tcG9uZW50IiwicHJlcGFyZUhpdHMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwiZWxXaWR0aCIsImVsSGVpZ2h0IiwiaXNWYWxpZFNlZ0Rvd25FbCIsImlzVmFsaWREYXRlRG93bkVsIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJTZWdIaWVyYXJjaHkiLCJnZXRFbnRyeVRoaWNrbmVzcyIsImVudHJ5IiwidGhpY2tuZXNzIiwic3RyaWN0T3JkZXIiLCJhbGxvd1Jlc2xpY2luZyIsIm1heENvb3JkIiwibWF4U3RhY2tDbnQiLCJsZXZlbENvb3JkcyIsImVudHJpZXNCeUxldmVsIiwic3RhY2tDbnRzIiwiYWRkU2VncyIsImlucHV0cyIsImhpZGRlbkVudHJpZXMiLCJpbnNlcnRFbnRyeSIsImZpbmRJbnNlcnRpb24iLCJpc0luc2VydGlvblZhbGlkIiwiaW5zZXJ0RW50cnlBdCIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJsZXZlbENvb3JkIiwic3RhY2tDbnQiLCJ0b3VjaGluZ0VudHJ5IiwiaGlkZGVuRW50cnkiLCJpbnRlcnNlY3RTcGFucyIsInNwbGl0RW50cnkiLCJiYXJyaWVyIiwiZW50cnlTcGFuIiwiYmFycmllclNwYW4iLCJsYXRlcmFsIiwiaW5zZXJ0QXQiLCJsZXZlbCIsImJ1aWxkRW50cnlLZXkiLCJuZXdFbnRyeSIsImxldmVsQ250IiwiY2FuZGlkYXRlQ29vcmQiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidHJhY2tpbmdMZXZlbCIsInRyYWNraW5nQ29vcmQiLCJ0cmFja2luZ0VudHJpZXMiLCJ0cmFja2luZ0VudHJ5Iiwic2VhcmNoUmVzIiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwibGF0ZXJhbEluZGV4IiwidHJhY2tpbmdFbnRyeUJvdHRvbSIsImRlc3RMZXZlbCIsImRlc3RMYXRlcmFsIiwidG9SZWN0cyIsInJlY3RzIiwiZW50cmllcyIsImdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyIsIm1lcmdlcyIsImZpbHRlcmVkTWVyZ2VzIiwiaHVuZ3J5TWVyZ2UiLCJtZXJnZSIsImpvaW5TcGFucyIsInNlYXJjaFZhbCIsImdldEl0ZW1WYWwiLCJtaWRkbGVJbmRleCIsIm1pZGRsZVZhbCIsIkVsZW1lbnREcmFnZ2luZyIsInNldE1pcnJvcklzVmlzaWJsZSIsImJvb2wiLCJzZXRNaXJyb3JOZWVkc1JldmVydCIsInNldEF1dG9TY3JvbGxFbmFibGVkIiwiY29uZmlnIiwiRFJBR19NRVRBX1JFRklORVJTIiwicGFyc2VEcmFnTWV0YSIsImxlZnRvdmVyUHJvcHMiLCJjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsIkNMQVNTX05BTUUiLCJyZW5kZXJJbm5lciQxIiwidGV4dCIsIlRhYmxlRGF0ZUNlbGwiLCJkYXlNZXRhIiwibmF2TGlua0F0dHJzIiwiY29sQ250IiwicHVibGljRGF0ZSIsImV4dHJhUmVuZGVyUHJvcHMiLCJyb2xlIiwiY29sU3BhbiIsImV4dHJhRGF0YUF0dHJzIiwiSW5uZXJDb250YWluZXIiLCJpc1N0aWNreSIsIldFRUtEQVlfRk9STUFUIiwiVGFibGVEb3dDZWxsIiwiZGF0ZU1ldGEiLCJEYXlIZWFkZXIiLCJjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIiLCJkYXRlcyIsInJlbmRlckludHJvIiwiZXhwbGljaXRGb3JtYXQiLCJkYXRlQ250IiwiRGF5U2VyaWVzTW9kZWwiLCJpbmRpY2VzIiwiZGF5SW5kZXgiLCJjbnQiLCJzbGljZVJhbmdlIiwiZmlyc3RJbmRleCIsImdldERhdGVEYXlJbmRleCIsImxhc3RJbmRleCIsImNsaXBwZWRGaXJzdEluZGV4IiwiY2xpcHBlZExhc3RJbmRleCIsImNlaWwiLCJkYXlPZmZzZXQiLCJEYXlUYWJsZU1vZGVsIiwiZGF5U2VyaWVzIiwiYnJlYWtPbldlZWtzIiwiZGF5c1BlclJvdyIsInJvd0NudCIsImNlbGxzIiwiYnVpbGRDZWxscyIsImhlYWRlckRhdGVzIiwiYnVpbGRIZWFkZXJEYXRlcyIsInJvd3MiLCJyb3ciLCJjb2wiLCJidWlsZENlbGwiLCJzZXJpZXNTZWciLCJuZXh0SW5kZXgiLCJmaXJzdENvbCIsImxhc3RDb2wiLCJTbGljZXIiLCJzbGljZUJ1c2luZXNzSG91cnMiLCJfc2xpY2VCdXNpbmVzc0hvdXJzIiwic2xpY2VEYXRlU2VsZWN0aW9uIiwiX3NsaWNlRGF0ZVNwYW4iLCJfc2xpY2VFdmVudFN0b3JlIiwic2xpY2VFdmVudERyYWciLCJfc2xpY2VJbnRlcmFjdGlvbiIsInNsaWNlRXZlbnRSZXNpemUiLCJmb3JjZURheUlmTGlzdEl0ZW0iLCJzbGljZVByb3BzIiwiZXh0cmFBcmdzIiwiZXZlbnRTZWdzIiwiZGF0ZVNlbGVjdGlvblNlZ3MiLCJidXNpbmVzc0hvdXJTZWdzIiwiZmdFdmVudFNlZ3MiLCJiZ0V2ZW50U2VncyIsInNsaWNlTm93RGF0ZSIsImNvbXB1dGVBY3RpdmVSYW5nZSIsInJhbmdlUmVzIiwic2xpY2VFdmVudFJhbmdlcyIsImFmZmVjdGVkSW5zdGFuY2VzIiwiYWN0aXZlRGF0ZVNwYW5SYW5nZSIsImV2ZW50UmFuZ2VzIiwic2xpY2VFdmVudFJhbmdlIiwiaXNDb21wb25lbnRBbGxEYXkiLCJpc0ludGVyYWN0aW9uVmFsaWQiLCJpc05ld1Byb3BzVmFsaWQiLCJpc0RhdGVTZWxlY3Rpb25WYWxpZCIsImNhbGVuZGFyU3RhdGUiLCJpc1Byb3BzVmFsaWQiLCJkYXRlU3Bhbk1ldGEiLCJmaWx0ZXJDb25maWciLCJpc0ludGVyYWN0aW9uUHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQiLCJjdXJyZW50U3RhdGUiLCJzdWJqZWN0RXZlbnRTdG9yZSIsInN1YmplY3REZWZzIiwic3ViamVjdEluc3RhbmNlcyIsInN1YmplY3RDb25maWdzIiwic2VsZWN0aW9uQ29uZmlnIiwib3RoZXJFdmVudFN0b3JlIiwib3RoZXJEZWZzIiwib3RoZXJJbnN0YW5jZXMiLCJvdGhlckNvbmZpZ3MiLCJzdWJqZWN0SW5zdGFuY2VJZCIsInN1YmplY3RJbnN0YW5jZSIsInN1YmplY3RSYW5nZSIsInN1YmplY3RDb25maWciLCJzdWJqZWN0RGVmIiwiYWxsQ29uc3RyYWludHNQYXNzIiwiZXZlbnRPdmVybGFwRnVuYyIsIm90aGVySW5zdGFuY2VJZCIsIm90aGVySW5zdGFuY2UiLCJvdGhlck92ZXJsYXAiLCJjYWxlbmRhckV2ZW50U3RvcmUiLCJzdWJqZWN0QWxsb3ciLCJzdWJqZWN0RGF0ZVNwYW4iLCJvcmlnRGVmIiwib3JpZ0luc3RhbmNlIiwicmVsZXZhbnRFdmVudFN0b3JlIiwicmVsZXZhbnREZWZzIiwicmVsZXZhbnRJbnN0YW5jZXMiLCJzZWxlY3Rpb25SYW5nZSIsInNlbGVjdE92ZXJsYXBGdW5jIiwicmVsZXZhbnRJbnN0YW5jZUlkIiwicmVsZXZhbnRJbnN0YW5jZSIsInNlbGVjdGlvbkFsbG93IiwiZnVsbERhdGVTcGFuIiwiYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQiLCJhbnlSYW5nZXNDb250YWluUmFuZ2UiLCJjb25zdHJhaW50VG9SYW5nZXMiLCJldmVudFN0b3JlVG9SYW5nZXMiLCJvdXRlclJhbmdlcyIsIlZJU0lCTEVfSElEREVOX1JFIiwiU2Nyb2xsZXIiLCJsaXF1aWQiLCJsaXF1aWRJc0Fic29sdXRlIiwiaXNBYnNvbHV0ZSIsIm92ZXJjb21lTGVmdCIsIm92ZXJjb21lUmlnaHQiLCJvdmVyY29tZUJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1heEhlaWdodCIsIm5lZWRzWFNjcm9sbGluZyIsInJlYWxDbGllbnRXaWR0aCIsImdldFlTY3JvbGxiYXJXaWR0aCIsImNoaWxkRWwiLCJuZWVkc1lTY3JvbGxpbmciLCJyZWFsQ2xpZW50SGVpZ2h0IiwiZ2V0WFNjcm9sbGJhcldpZHRoIiwiUmVmTWFwIiwibWFzdGVyQ2FsbGJhY2siLCJjdXJyZW50TWFwIiwiZGVwdGhzIiwiY2FsbGJhY2tNYXAiLCJoYW5kbGVWYWx1ZSIsInJlbW92ZWQiLCJhZGRlZCIsImNyZWF0ZVJlZiIsInJlZkNhbGxiYWNrIiwiY29sbGVjdCIsImdldEFsbCIsImNvbXB1dGVTaHJpbmtXaWR0aCIsImNodW5rRWxzIiwic2hyaW5rQ2VsbHMiLCJsYXJnZXN0V2lkdGgiLCJzaHJpbmtDZWxsIiwiZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCIsInNlY3Rpb25Db25maWciLCJnZXRBbGxvd1lTY3JvbGxpbmciLCJyZW5kZXJDaHVua0NvbnRlbnQiLCJjaHVua0NvbmZpZyIsImlzSGVhZGVyIiwidGFibGVDbGFzc05hbWUiLCJzeW5jUm93SGVpZ2h0cyIsIm1pbldpZHRoIiwidGFibGVNaW5XaWR0aCIsInRhYmxlQ29sR3JvdXBOb2RlIiwicm93Q29udGVudCIsImlzQ29sUHJvcHNFcXVhbCIsImNvbHMwIiwiY29sczEiLCJyZW5kZXJNaWNyb0NvbEdyb3VwIiwiY29scyIsInNocmlua1dpZHRoIiwiY29sTm9kZXMiLCJjb2xQcm9wcyIsInNhbml0aXplU2hyaW5rV2lkdGgiLCJoYXNTaHJpbmtXaWR0aCIsImdldFNjcm9sbEdyaWRDbGFzc05hbWVzIiwiZ2V0U2VjdGlvbkNsYXNzTmFtZXMiLCJ3aG9sZVRhYmxlVkdyb3ciLCJyZW5kZXJTY3JvbGxTaGltIiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJTaW1wbGVTY3JvbGxHcmlkIiwicHJvY2Vzc0NvbHMiLCJzY3JvbGxlclJlZnMiLCJzY3JvbGxlckVsUmVmcyIsIl9oYW5kbGVTY3JvbGxlckVsIiwiZm9yY2VZU2Nyb2xsYmFycyIsInNjcm9sbGVyQ2xpZW50V2lkdGhzIiwic2Nyb2xsZXJDbGllbnRIZWlnaHRzIiwiaGFuZGxlU2l6aW5nIiwiY29tcHV0ZVNjcm9sbGVyRGltcyIsInNlY3Rpb25Db25maWdzIiwic2VjdGlvbnMiLCJtaWNyb0NvbEdyb3VwTm9kZSIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb25maWdDbnQiLCJjb25maWdJIiwiY3VycmVudENvbmZpZyIsImhlYWRTZWN0aW9uTm9kZXMiLCJib2R5U2VjdGlvbk5vZGVzIiwiZm9vdFNlY3Rpb25Ob2RlcyIsInJlbmRlclNlY3Rpb24iLCJpc0J1Z2d5Iiwicm9sZUF0dHJzIiwib3V0ZXJDb250ZW50IiwicmVuZGVyQ2h1bmtUZCIsImNodW5rIiwiaXNMaXF1aWQiLCJzZWN0aW9uS2V5Iiwicm93U3luY0hlaWdodHMiLCJyZXBvcnRSb3dIZWlnaHRDaGFuZ2UiLCJzY3JvbGxlckVsIiwic2VjdGlvbiIsImdldFNlY3Rpb25CeUtleSIsInNjcm9sbGVyRWxSZWYiLCJzY3JvbGxiYXJXaWR0aCIsInNjcm9sbGVyIiwiaGFybmVzc0VsIiwiRXZlbnRDb250YWluZXIiLCJ0aW1lVGV4dCIsImRpc2FibGVEcmFnZ2luZyIsImRpc2FibGVSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsIlN0YW5kYXJkRXZlbnQiLCJkZWZhdWx0VGltZUZvcm1hdCIsInJlbmRlcklubmVyQ29udGVudCQxIiwiZXZlbnRDb250ZW50QXJnIiwiaW5uZXJQcm9wcyIsIk5vd0luZGljYXRvckNvbnRhaW5lciIsIkNvbnN1bWVyIiwiaXNBeGlzIiwiREFZX05VTV9GT1JNQVQiLCJEYXlDZWxsQ29udGFpbmVyIiwicmVmaW5lUmVuZGVyUHJvcHMiLCJpc01vbnRoU3RhcnQiLCJzaG93RGF5TnVtYmVyIiwiaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQiLCJkYXlOdW1iZXJUZXh0IiwiQmdFdmVudCIsInJlbmRlcklubmVyQ29udGVudCIsInJlbmRlckZpbGwiLCJmaWxsVHlwZSIsIldlZWtOdW1iZXJDb250YWluZXIiLCJkZWZhdWx0Rm9ybWF0IiwicmVuZGVySW5uZXIiLCJQQURESU5HX0ZST01fVklFV1BPUlQiLCJQb3BvdmVyIiwidGl0bGVJZCIsImhhbmRsZVJvb3RFbCIsInJvb3RFbCIsImhhbmRsZURvY3VtZW50TW91c2VEb3duIiwiaGFuZGxlQ2xvc2VDbGljayIsImhhbmRsZURvY3VtZW50S2V5RG93biIsIm9uQ2xvc2UiLCJleHRyYUF0dHJzIiwiYWxpZ25tZW50RWwiLCJhbGlnbkdyaWRUb3AiLCJhbGlnbm1lbnRSZWN0IiwicG9wb3ZlckRpbXMiLCJwb3BvdmVyVG9wIiwicG9wb3ZlckxlZnQiLCJvcmlnaW4iLCJvZmZzZXRQYXJlbnQiLCJNb3JlUG9wb3ZlciIsInN0YXJ0RGF0ZSIsImZvcmNlVGltZWQiLCJleHRyYURhdGVTcGFuIiwiZGF5RWwiLCJsYXllciIsIk1vcmVMaW5rQ29udGFpbmVyIiwiaXNQb3BvdmVyT3BlbiIsInBvcG92ZXJJZCIsImhhbmRsZUxpbmtFbCIsImxpbmtFbCIsImhhbmRsZUNsaWNrIiwiY29tcHV0ZVJhbmdlIiwiYnVpbGRQdWJsaWNTZWciLCJhbGxEYXlEYXRlIiwiYWxsU2VncyIsImhpZGRlblNlZ3MiLCJoYW5kbGVQb3BvdmVyQ2xvc2UiLCJtb3JlQ250IiwiaGludCIsInNob3J0VGV4dCIsInJlbmRlck1vcmVMaW5rSW5uZXIiLCJhbGlnbm1lbnRFbFJlZiIsInBvcG92ZXJDb250ZW50IiwidXBkYXRlUGFyZW50RWwiLCJjb21wdXRlRWFybGllc3RTZWdTdGFydCIsImNvbXB1dGVMYXRlc3RTZWdFbmQiLCJwaWNrRWFybGllc3RTdGFydCIsInNlZzAiLCJzZWcxIiwicGlja0xhdGVzdEVuZCIsIlN0b3JlIiwiY3VycmVudFZhbHVlIiwic3Vic2NyaWJlIiwiQ3VzdG9tUmVuZGVyaW5nU3RvcmUiLCJoYW5kbGUiLCJjdXN0b21SZW5kZXJpbmciLCJ1cGRhdGVkIiwiaGFzIiwiZGVsZXRlIiwiJCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiVSIsIlYiLCJXIiwiWCIsIlkiLCJaIiwiXyIsImEkIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFBIiwiYUIiLCJhQyIsImFEIiwiYUUiLCJhRiIsImFHIiwiYUgiLCJhSSIsImFKIiwiYUsiLCJhTCIsImFNIiwiYU4iLCJhTyIsImFQIiwiYVEiLCJhUiIsImFTIiwiYVQiLCJhVSIsImFWIiwiYVciLCJhWCIsImFZIiwiYVoiLCJhXyIsImFhIiwiYWIiLCJhYyIsImFkIiwiYWUiLCJhZiIsImFnIiwiYWgiLCJhaSIsImFqIiwiYWsiLCJhbCIsImFtIiwiYW4iLCJhbyIsImFwIiwiYXEiLCJhciIsImFzIiwiYXQiLCJhdSIsImF2IiwiYXciLCJheCIsImF5IiwiYXoiLCJiJCIsImIwIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImI5IiwiYkEiLCJiQiIsImJDIiwiYkQiLCJiRSIsImJGIiwiYkciLCJiSCIsImJJIiwiYkoiLCJiSyIsImJMIiwiYk0iLCJiTiIsImJPIiwiYlAiLCJiUSIsImJSIiwiYlMiLCJiVCIsImJVIiwiYlYiLCJiVyIsImJYIiwiYlkiLCJiWiIsImJfIiwiYmEiLCJiYiIsImJjIiwiYmQiLCJiZSIsImJmIiwiYmgiLCJiaSIsImJqIiwiYmsiLCJibCIsImJtIiwiYm4iLCJibyIsImJwIiwiYnEiLCJiciIsImJzIiwiYnQiLCJidSIsImJ2IiwiYnciLCJieCIsImJ5IiwiYnoiLCJjMCIsImMxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsImM3IiwiYzgiLCJjOSIsImNiIiwiY2MiLCJjZCIsImNlIiwiY2YiLCJjZyIsImNoIiwiY2kiLCJjaiIsImNrIiwiY2wiLCJjbSIsImNuIiwiY28iLCJjcCIsImNxIiwiY3IiLCJjcyIsImN0IiwiY3UiLCJjdiIsImUiLCJmIiwiZyIsImgiLCJrIiwibCIsIm8iLCJwIiwicSIsInIiLCJ0IiwidSIsInYiLCJ6Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/core/internal-common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/daygrid/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/index.js */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal.js */ \"(ssr)/./node_modules/@fullcalendar/daygrid/internal.js\");\n\n\n\n\nvar index = (0,_fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    name: \"@fullcalendar/daygrid\",\n    initialView: \"dayGridMonth\",\n    views: {\n        dayGrid: {\n            component: _internal_js__WEBPACK_IMPORTED_MODULE_1__.DayGridView,\n            dateProfileGeneratorClass: _internal_js__WEBPACK_IMPORTED_MODULE_1__.TableDateProfileGenerator\n        },\n        dayGridDay: {\n            type: \"dayGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        dayGridWeek: {\n            type: \"dayGrid\",\n            duration: {\n                weeks: 1\n            }\n        },\n        dayGridMonth: {\n            type: \"dayGrid\",\n            duration: {\n                months: 1\n            },\n            fixedWeekCount: true\n        },\n        dayGridYear: {\n            type: \"dayGrid\",\n            duration: {\n                years: 1\n            }\n        }\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRDtBQUM0QjtBQUMvQztBQUNGO0FBRXRDLElBQUlJLFFBQVFKLHlFQUFZQSxDQUFDO0lBQ3JCSyxNQUFNO0lBQ05DLGFBQWE7SUFDYkMsT0FBTztRQUNIQyxTQUFTO1lBQ0xDLFdBQVdQLHFEQUFZQTtZQUN2QlEsMkJBQTJCUCxtRUFBeUJBO1FBQ3hEO1FBQ0FRLFlBQVk7WUFDUkMsTUFBTTtZQUNOQyxVQUFVO2dCQUFFQyxNQUFNO1lBQUU7UUFDeEI7UUFDQUMsYUFBYTtZQUNUSCxNQUFNO1lBQ05DLFVBQVU7Z0JBQUVHLE9BQU87WUFBRTtRQUN6QjtRQUNBQyxjQUFjO1lBQ1ZMLE1BQU07WUFDTkMsVUFBVTtnQkFBRUssUUFBUTtZQUFFO1lBQ3RCQyxnQkFBZ0I7UUFDcEI7UUFDQUMsYUFBYTtZQUNUUixNQUFNO1lBQ05DLFVBQVU7Z0JBQUVRLE9BQU87WUFBRTtRQUN6QjtJQUNKO0FBQ0o7QUFFNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGFuZXIvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzP2MxYzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCB7IERheUdyaWRWaWV3IGFzIERheVRhYmxlVmlldywgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9kYXlncmlkJyxcbiAgICBpbml0aWFsVmlldzogJ2RheUdyaWRNb250aCcsXG4gICAgdmlld3M6IHtcbiAgICAgICAgZGF5R3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUYWJsZVZpZXcsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRZZWFyOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyczogMSB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZVBsdWdpbiIsIkRheUdyaWRWaWV3IiwiRGF5VGFibGVWaWV3IiwiVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciIsImluZGV4IiwibmFtZSIsImluaXRpYWxWaWV3Iiwidmlld3MiLCJkYXlHcmlkIiwiY29tcG9uZW50IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsImRheUdyaWREYXkiLCJ0eXBlIiwiZHVyYXRpb24iLCJkYXlzIiwiZGF5R3JpZFdlZWsiLCJ3ZWVrcyIsImRheUdyaWRNb250aCIsIm1vbnRocyIsImZpeGVkV2Vla0NvdW50IiwiZGF5R3JpZFllYXIiLCJ5ZWFycyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/daygrid/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/daygrid/internal.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/internal.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DayGridView: () => (/* binding */ DayTableView),\n/* harmony export */   DayTable: () => (/* binding */ DayTable),\n/* harmony export */   DayTableSlicer: () => (/* binding */ DayTableSlicer),\n/* harmony export */   Table: () => (/* binding */ Table),\n/* harmony export */   TableDateProfileGenerator: () => (/* binding */ TableDateProfileGenerator),\n/* harmony export */   TableRows: () => (/* binding */ TableRows),\n/* harmony export */   TableView: () => (/* binding */ TableView),\n/* harmony export */   buildDayTableModel: () => (/* binding */ buildDayTableModel),\n/* harmony export */   buildDayTableRenderRange: () => (/* binding */ buildDayTableRenderRange)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/internal.js */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var _fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/core/preact.js */ \"(ssr)/./node_modules/preact/dist/preact.mjs\");\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nclass TableView extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor(){\n        super(...arguments);\n        this.headerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    renderSimpleLayout(headerRowContent, bodyContent) {\n        let { props, context } = this;\n        let sections = [];\n        let stickyHeaderDates = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunk: {\n                content: bodyContent\n            }\n        });\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, {\n            elClasses: [\n                \"fc-daygrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bZ, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            collapsibleWidth: props.forPrint,\n            cols: [],\n            sections: sections\n        }));\n    }\n    renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n        let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        let { props, context } = this;\n        let stickyHeaderDates = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca)(context.options);\n        let stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.c9)(context.options);\n        let sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunks: [\n                    {\n                        key: \"main\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunks: [\n                {\n                    key: \"main\",\n                    content: bodyContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: \"footer\",\n                key: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"main\",\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.c8\n                    }\n                ]\n            });\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, {\n            elClasses: [\n                \"fc-daygrid\"\n            ],\n            viewSpec: context.viewSpec\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n            liquid: !props.isHeightAuto && !props.forPrint,\n            forPrint: props.forPrint,\n            collapsibleWidth: props.forPrint,\n            colGroups: [\n                {\n                    cols: [\n                        {\n                            span: colCnt,\n                            minWidth: dayMinWidth\n                        }\n                    ]\n                }\n            ],\n            sections: sections\n        }));\n    }\n}\nfunction splitSegsByRow(segs, rowCnt) {\n    let byRow = [];\n    for(let i = 0; i < rowCnt; i += 1){\n        byRow[i] = [];\n    }\n    for (let seg of segs){\n        byRow[seg.row].push(seg);\n    }\n    return byRow;\n}\nfunction splitSegsByFirstCol(segs, colCnt) {\n    let byCol = [];\n    for(let i = 0; i < colCnt; i += 1){\n        byCol[i] = [];\n    }\n    for (let seg of segs){\n        byCol[seg.firstCol].push(seg);\n    }\n    return byCol;\n}\nfunction splitInteractionByRow(ui, rowCnt) {\n    let byRow = [];\n    if (!ui) {\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for (let seg of ui.segs){\n            byRow[seg.row].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nconst DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"narrow\"\n});\nfunction hasListItemDisplay(seg) {\n    let { display } = seg.eventRange.ui;\n    return display === \"list-item\" || display === \"auto\" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n    seg.isStart && // \"\n    seg.isEnd // \"\n    ;\n}\nclass TableBlockEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cg, Object.assign({}, props, {\n            elClasses: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-block-event\",\n                \"fc-h-event\"\n            ],\n            defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n            defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n            disableResizing: !props.seg.eventRange.def.allDay\n        }));\n    }\n}\nclass TableListItemEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n        let timeText = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bO)(seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ck, Object.assign({}, props, {\n            elTag: \"a\",\n            elClasses: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-dot-event\"\n            ],\n            elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(props.seg, context),\n            defaultGenerator: renderInnerContent,\n            timeText: timeText,\n            isResizing: false,\n            isDateSelecting: false\n        }));\n    }\n}\nfunction renderInnerContent(renderProps) {\n    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-event-dot\",\n        style: {\n            borderColor: renderProps.borderColor || renderProps.backgroundColor\n        }\n    }), renderProps.timeText && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, renderProps.timeText), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, renderProps.event.title || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\")));\n}\nclass TableCellMoreLink extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor(){\n        super(...arguments);\n        this.compileSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(compileSegs);\n    }\n    render() {\n        let { props } = this;\n        let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.co, {\n            elClasses: [\n                \"fc-daygrid-more-link\"\n            ],\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            allDayDate: props.allDayDate,\n            moreCnt: props.moreCnt,\n            allSegs: allSegs,\n            hiddenSegs: invisibleSegs,\n            alignmentElRef: props.alignmentElRef,\n            alignGridTop: props.alignGridTop,\n            extraDateSpan: props.extraDateSpan,\n            popoverContent: ()=>{\n                let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, allSegs.map((seg)=>{\n                    let instanceId = seg.eventRange.instance.instanceId;\n                    return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                        className: \"fc-daygrid-event-harness\",\n                        key: instanceId,\n                        style: {\n                            visibility: isForcedInvisible[instanceId] ? \"hidden\" : \"\"\n                        }\n                    }, hasListItemDisplay(seg) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({\n                        seg: seg,\n                        isDragging: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, props.todayRange))) : (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({\n                        seg: seg,\n                        isDragging: false,\n                        isResizing: false,\n                        isDateSelecting: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, props.todayRange))));\n                }));\n            }\n        });\n    }\n}\nfunction compileSegs(singlePlacements) {\n    let allSegs = [];\n    let invisibleSegs = [];\n    for (let placement of singlePlacements){\n        allSegs.push(placement.seg);\n        if (!placement.isVisible) {\n            invisibleSegs.push(placement.seg);\n        }\n    }\n    return {\n        allSegs,\n        invisibleSegs\n    };\n}\nconst DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    week: \"narrow\"\n});\nclass TableCell extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor(){\n        super(...arguments);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            dayNumberId: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a3)()\n        };\n        this.handleRootEl = (el)=>{\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.W)(this.rootElRef, el);\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.W)(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { context, props, state, rootElRef } = this;\n        let { options, dateEnv } = context;\n        let { date, dateProfile } = props;\n        // TODO: memoize this?\n        const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ci, {\n            elTag: \"td\",\n            elRef: this.handleRootEl,\n            elClasses: [\n                \"fc-daygrid-day\",\n                ...props.extraClassNames || []\n            ],\n            elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? {\n                \"aria-labelledby\": state.dayNumberId\n            } : {}), {\n                role: \"gridcell\"\n            }),\n            defaultGenerator: renderTopInner,\n            date: date,\n            dateProfile: dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            isMonthStart: isMonthStart,\n            extraRenderProps: props.extraRenderProps\n        }, (InnerContent, renderProps)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                ref: props.innerElRef,\n                className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                style: {\n                    minHeight: props.minHeight\n                }\n            }, props.showWeekNumber && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cn, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-daygrid-week-number\"\n                ],\n                elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a_)(context, date, \"week\"),\n                date: date,\n                defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n            }), !renderProps.isDisabled && (props.showDayNumber || (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cj)(options) || props.forceDayTop) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-top\"\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, {\n                elTag: \"a\",\n                elClasses: [\n                    \"fc-daygrid-day-number\",\n                    isMonthStart && \"fc-daygrid-month-start\"\n                ],\n                elAttrs: Object.assign(Object.assign({}, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a_)(context, date)), {\n                    id: state.dayNumberId\n                })\n            })) : props.showDayNumber ? // for creating correct amount of space (see issue #7162)\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-top\",\n                style: {\n                    visibility: \"hidden\"\n                }\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n                className: \"fc-daygrid-day-number\"\n            }, \"\\xa0\")) : undefined, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-events\",\n                ref: props.fgContentElRef\n            }, props.fgContent, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bottom\",\n                style: {\n                    marginTop: props.moreMarginTop\n                }\n            }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellMoreLink, {\n                allDayDate: date,\n                singlePlacements: props.singlePlacements,\n                moreCnt: props.moreCnt,\n                alignmentElRef: rootElRef,\n                alignGridTop: !props.showDayNumber,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange\n            }))), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bg\"\n            }, props.bgContent)));\n    }\n}\nfunction renderTopInner(props) {\n    return props.dayNumberText || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\");\n}\nfunction shouldDisplayMonthStart(date, currentRange, dateEnv) {\n    const { start: currentStart, end: currentEnd } = currentRange;\n    const currentEndIncl = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be)(currentEnd, -1);\n    const currentFirstYear = dateEnv.getYear(currentStart);\n    const currentFirstMonth = dateEnv.getMonth(currentStart);\n    const currentLastYear = dateEnv.getYear(currentEndIncl);\n    const currentLastMonth = dateEnv.getMonth(currentEndIncl);\n    // spans more than one month?\n    return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(// first date in current view?\n    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?\n    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf());\n}\nfunction generateSegKey(seg) {\n    return seg.eventRange.instance.instanceId + \":\" + seg.firstCol;\n}\nfunction generateSegUid(seg) {\n    return generateSegKey(seg) + \":\" + seg.lastCol;\n}\nfunction computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {\n    let hierarchy = new DayGridSegHierarchy((segEntry)=>{\n        // TODO: more DRY with generateSegUid\n        let segUid = segs[segEntry.index].eventRange.instance.instanceId + \":\" + segEntry.span.start + \":\" + (segEntry.span.end - 1);\n        // if no thickness known, assume 1 (if 0, so small it always fits)\n        return segHeights[segUid] || 1;\n    });\n    hierarchy.allowReslicing = true;\n    hierarchy.strictOrder = strictOrder;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n        hierarchy.maxCoord = maxContentHeight;\n        hierarchy.hiddenConsumes = true;\n    } else if (typeof dayMaxEvents === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEvents;\n    } else if (typeof dayMaxEventRows === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEventRows;\n        hierarchy.hiddenConsumes = true;\n    }\n    // create segInputs only for segs with known heights\n    let segInputs = [];\n    let unknownHeightSegs = [];\n    for(let i = 0; i < segs.length; i += 1){\n        let seg = segs[i];\n        let segUid = generateSegUid(seg);\n        let eventHeight = segHeights[segUid];\n        if (eventHeight != null) {\n            segInputs.push({\n                index: i,\n                span: {\n                    start: seg.firstCol,\n                    end: seg.lastCol + 1\n                }\n            });\n        } else {\n            unknownHeightSegs.push(seg);\n        }\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let segRects = hierarchy.toRects();\n    let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);\n    let moreCnts = [];\n    let moreMarginTops = [];\n    // add segs with unknown heights\n    for (let seg of unknownHeightSegs){\n        multiColPlacements[seg.firstCol].push({\n            seg,\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(let col = seg.firstCol; col <= seg.lastCol; col += 1){\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // add the hidden entries\n    for(let col = 0; col < cells.length; col += 1){\n        moreCnts.push(0);\n    }\n    for (let hiddenEntry of hiddenEntries){\n        let seg = segs[hiddenEntry.index];\n        let hiddenSpan = hiddenEntry.span;\n        multiColPlacements[hiddenSpan.start].push({\n            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(let col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n            moreCnts[col] += 1;\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // deal with leftover margins\n    for(let col = 0; col < cells.length; col += 1){\n        moreMarginTops.push(leftoverMargins[col]);\n    }\n    return {\n        singleColPlacements,\n        multiColPlacements,\n        moreCnts,\n        moreMarginTops\n    };\n}\n// rects ordered by top coord, then left\nfunction placeRects(allRects, segs, cells) {\n    let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n    let singleColPlacements = [];\n    let multiColPlacements = [];\n    let leftoverMargins = [];\n    for(let col = 0; col < cells.length; col += 1){\n        let rects = rectsByEachCol[col];\n        // compute all static segs in singlePlacements\n        let singlePlacements = [];\n        let currentHeight = 0;\n        let currentMarginTop = 0;\n        for (let rect of rects){\n            let seg = segs[rect.index];\n            singlePlacements.push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: true,\n                isAbsolute: false,\n                absoluteTop: rect.levelCoord,\n                marginTop: rect.levelCoord - currentHeight\n            });\n            currentHeight = rect.levelCoord + rect.thickness;\n        }\n        // compute mixed static/absolute segs in multiPlacements\n        let multiPlacements = [];\n        currentHeight = 0;\n        currentMarginTop = 0;\n        for (let rect of rects){\n            let seg = segs[rect.index];\n            let isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n            let isFirstCol = rect.span.start === col;\n            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n            if (isAbsolute) {\n                currentMarginTop += rect.thickness;\n                if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: true,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: 0\n                    });\n                }\n            } else if (isFirstCol) {\n                multiPlacements.push({\n                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: currentMarginTop\n                });\n                currentMarginTop = 0;\n            }\n        }\n        singleColPlacements.push(singlePlacements);\n        multiColPlacements.push(multiPlacements);\n        leftoverMargins.push(currentMarginTop);\n    }\n    return {\n        singleColPlacements,\n        multiColPlacements,\n        leftoverMargins\n    };\n}\nfunction groupRectsByEachCol(rects, colCnt) {\n    let rectsByEachCol = [];\n    for(let col = 0; col < colCnt; col += 1){\n        rectsByEachCol.push([]);\n    }\n    for (let rect of rects){\n        for(let col = rect.span.start; col < rect.span.end; col += 1){\n            rectsByEachCol[col].push(rect);\n        }\n    }\n    return rectsByEachCol;\n}\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n        return seg;\n    }\n    let eventRange = seg.eventRange;\n    let origRange = eventRange.range;\n    let slicedRange = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.o)(origRange, {\n        start: cells[spanStart].date,\n        end: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(cells[spanEnd - 1].date, 1)\n    });\n    return Object.assign(Object.assign({}, seg), {\n        firstCol: spanStart,\n        lastCol: spanEnd - 1,\n        eventRange: {\n            def: eventRange.def,\n            ui: Object.assign(Object.assign({}, eventRange.ui), {\n                durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n    });\n}\nclass DayGridSegHierarchy extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.by {\n    constructor(){\n        super(...arguments);\n        // config\n        this.hiddenConsumes = false;\n        // allows us to keep hidden entries in the hierarchy so they take up space\n        this.forceHidden = {};\n    }\n    addSegs(segInputs) {\n        const hiddenSegs = super.addSegs(segInputs);\n        const { entriesByLevel } = this;\n        const excludeHidden = (entry)=>!this.forceHidden[(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bz)(entry)];\n        // remove the forced-hidden segs\n        for(let level = 0; level < entriesByLevel.length; level += 1){\n            entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n        }\n        return hiddenSegs;\n    }\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        const { entriesByLevel, forceHidden } = this;\n        const { touchingEntry, touchingLevel, touchingLateral } = insertion;\n        // the entry that the new insertion is touching must be hidden\n        if (this.hiddenConsumes && touchingEntry) {\n            const touchingEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bz)(touchingEntry);\n            if (!forceHidden[touchingEntryId]) {\n                if (this.allowReslicing) {\n                    // split up the touchingEntry, reinsert it\n                    const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), {\n                        span: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bD)(touchingEntry.span, entry.span)\n                    });\n                    // reinsert the area that turned into a \"more\" link (so no other entries try to\n                    // occupy the space) but mark it forced-hidden\n                    const hiddenEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bz)(hiddenEntry);\n                    forceHidden[hiddenEntryId] = true;\n                    entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;\n                    hiddenEntries.push(hiddenEntry);\n                    this.splitEntry(touchingEntry, entry, hiddenEntries);\n                } else {\n                    forceHidden[touchingEntryId] = true;\n                    hiddenEntries.push(touchingEntry);\n                }\n            }\n        }\n        // will try to reslice...\n        super.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    }\n}\nclass TableRow extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor(){\n        super(...arguments);\n        this.cellElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cd(); // the <td>\n        this.frameElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cd(); // the fc-daygrid-day-frame\n        this.fgElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cd(); // the fc-daygrid-day-events\n        this.segHarnessRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cd(); // indexed by \"instanceId:firstCol\"\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            framePositions: null,\n            maxContentHeight: null,\n            segHeights: {}\n        };\n        this.handleResize = (isForced)=>{\n            if (isForced) {\n                this.updateSizing(true); // isExternal=true\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let colCnt = props.cells.length;\n        let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n        let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n        let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n        let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n        let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bP)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);\n        let isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n            ref: this.rootElRef,\n            role: \"row\"\n        }, props.renderIntro && props.renderIntro(), props.cells.map((cell, col)=>{\n            let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n            let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n            return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCell, {\n                key: cell.key,\n                elRef: this.cellElRefs.createRef(cell.key),\n                innerElRef: this.frameElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                showDayNumber: props.showDayNumbers,\n                showWeekNumber: props.showWeekNumbers && col === 0,\n                forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                todayRange: props.todayRange,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                extraRenderProps: cell.extraRenderProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                moreCnt: moreCnts[col],\n                moreMarginTop: moreMarginTops[col],\n                singlePlacements: singleColPlacements[col],\n                fgContentElRef: this.fgElRefs.createRef(cell.key),\n                fgContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, normalFgNodes), (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, mirrorFgNodes)),\n                bgContent: (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.renderFillSegs(highlightSegsByCol[col], \"highlight\"), this.renderFillSegs(businessHoursByCol[col], \"non-business\"), this.renderFillSegs(bgEventSegsByCol[col], \"bg-event\")),\n                minHeight: props.cellMinHeight\n            });\n        }));\n    }\n    componentDidMount() {\n        this.updateSizing(true);\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        let currentProps = this.props;\n        this.updateSizing(!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E)(prevProps, currentProps));\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    getHighlightSegs() {\n        let { props } = this;\n        if (props.eventDrag && props.eventDrag.segs.length) {\n            return props.eventDrag.segs;\n        }\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return props.dateSelectionSegs;\n    }\n    getMirrorSegs() {\n        let { props } = this;\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return [];\n    }\n    renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        let { context } = this;\n        let { eventSelection } = this.props;\n        let { framePositions } = this.state;\n        let defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        let nodes = [];\n        if (framePositions) {\n            for (let placement of segPlacements){\n                let { seg } = placement;\n                let { instanceId } = seg.eventRange.instance;\n                let isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                let isAbsolute = placement.isAbsolute;\n                let left = \"\";\n                let right = \"\";\n                if (isAbsolute) {\n                    if (context.isRtl) {\n                        right = 0;\n                        left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                    } else {\n                        left = 0;\n                        right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                    }\n                }\n                /*\n                known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                todo: in print view, for multi-day events, don't display title within non-start/end segs\n                */ nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    className: \"fc-daygrid-event-harness\" + (isAbsolute ? \" fc-daygrid-event-harness-abs\" : \"\"),\n                    key: generateSegKey(seg),\n                    ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)),\n                    style: {\n                        visibility: isVisible ? \"\" : \"hidden\",\n                        marginTop: isAbsolute ? \"\" : placement.marginTop,\n                        top: isAbsolute ? placement.absoluteTop : \"\",\n                        left,\n                        right\n                    }\n                }, hasListItemDisplay(seg) ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, todayRange))) : (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, todayRange)))));\n            }\n        }\n        return nodes;\n    }\n    renderFillSegs(segs, fillType) {\n        let { isRtl } = this.context;\n        let { todayRange } = this.props;\n        let { framePositions } = this.state;\n        let nodes = [];\n        if (framePositions) {\n            for (let seg of segs){\n                let leftRightCss = isRtl ? {\n                    right: 0,\n                    left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                } : {\n                    left: 0,\n                    right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                };\n                nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bR)(seg.eventRange),\n                    className: \"fc-daygrid-bg-harness\",\n                    style: leftRightCss\n                }, fillType === \"bg-event\" ? (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cm, Object.assign({\n                    seg: seg\n                }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, todayRange))) : (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cl)(fillType)));\n            }\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...nodes);\n    }\n    updateSizing(isExternalSizingChange) {\n        let { props, state, frameElRefs } = this;\n        if (!props.forPrint && props.clientWidth !== null // positioning ready?\n        ) {\n            if (isExternalSizingChange) {\n                let frameEls = props.cells.map((cell)=>frameElRefs.currentMap[cell.key]);\n                if (frameEls.length) {\n                    let originEl = this.rootElRef.current;\n                    let newPositionCache = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b8(originEl, frameEls, true, false);\n                    if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {\n                        this.setState({\n                            framePositions: new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b8(originEl, frameEls, true, false)\n                        });\n                    }\n                }\n            }\n            const oldSegHeights = this.state.segHeights;\n            const newSegHeights = this.querySegHeights();\n            const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n            this.safeSetState({\n                // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                // Essentially, once you compute an element's height, never null-out.\n                // TODO: always display all events, as visibility:hidden?\n                segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),\n                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n            });\n        }\n    }\n    querySegHeights() {\n        let segElMap = this.segHarnessRefs.currentMap;\n        let segHeights = {};\n        // get the max height amongst instance segs\n        for(let segUid in segElMap){\n            let height = Math.round(segElMap[segUid].getBoundingClientRect().height);\n            segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);\n        }\n        return segHeights;\n    }\n    computeMaxContentHeight() {\n        let firstKey = this.props.cells[0].key;\n        let cellEl = this.cellElRefs.currentMap[firstKey];\n        let fcContainerEl = this.fgElRefs.currentMap[firstKey];\n        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    }\n    getCellEls() {\n        let elMap = this.cellElRefs.currentMap;\n        return this.props.cells.map((cell)=>elMap[cell.key]);\n    }\n}\nTableRow.addStateEquality({\n    segHeights: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E\n});\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n    if (!mirrorSegs.length) {\n        return [];\n    }\n    let topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map((seg)=>({\n            seg,\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n            marginTop: 0\n        }));\n}\nfunction buildAbsoluteTopHash(colPlacements) {\n    let topsByInstanceId = {};\n    for (let placements of colPlacements){\n        for (let placement of placements){\n            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n    }\n    return topsByInstanceId;\n}\nclass TableRows extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor(){\n        super(...arguments);\n        this.splitBusinessHourSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitBgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitFgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitDateSelectionSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitEventDrag = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.splitEventResize = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.rowRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cd();\n    }\n    render() {\n        let { props, context } = this;\n        let rowCnt = props.cells.length;\n        let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n        let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n        let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n        let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n        let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n        let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n        // for DayGrid view with many rows, force a min-height on cells so doesn't appear squished\n        // choose 7 because a month view will have max 6 rows\n        let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a6, {\n            unit: \"day\"\n        }, (nowDate, todayRange)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, props.cells.map((cells, row)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRow, {\n                    ref: this.rowRefs.createRef(row),\n                    key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                    ,\n                    showDayNumbers: rowCnt > 1,\n                    showWeekNumbers: props.showWeekNumbers,\n                    todayRange: todayRange,\n                    dateProfile: props.dateProfile,\n                    cells: cells,\n                    renderIntro: props.renderRowIntro,\n                    businessHourSegs: businessHourSegsByRow[row],\n                    eventSelection: props.eventSelection,\n                    bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                    fgEventSegs: fgEventSegsByRow[row],\n                    dateSelectionSegs: dateSelectionSegsByRow[row],\n                    eventDrag: eventDragByRow[row],\n                    eventResize: eventResizeByRow[row],\n                    dayMaxEvents: props.dayMaxEvents,\n                    dayMaxEventRows: props.dayMaxEventRows,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    cellMinHeight: cellMinHeight,\n                    forPrint: props.forPrint\n                }))));\n    }\n    componentDidMount() {\n        this.registerInteractiveComponent();\n    }\n    componentDidUpdate() {\n        // for if started with zero cells\n        this.registerInteractiveComponent();\n    }\n    registerInteractiveComponent() {\n        if (!this.rootEl) {\n            // HACK: need a daygrid wrapper parent to do positioning\n            // NOTE: a daygrid resource view w/o resources can have zero cells\n            const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];\n            const rootEl = firstCellEl ? firstCellEl.closest(\".fc-daygrid-body\") : null;\n            if (rootEl) {\n                this.rootEl = rootEl;\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    isHitComboAllowed: this.props.isHitComboAllowed\n                });\n            }\n        }\n    }\n    componentWillUnmount() {\n        if (this.rootEl) {\n            this.context.unregisterInteractiveComponent(this);\n            this.rootEl = null;\n        }\n    }\n    // Hit System\n    // ----------------------------------------------------------------------------------------------------\n    prepareHits() {\n        this.rowPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b8(this.rootEl, this.rowRefs.collect().map((rowObj)=>rowObj.getCellEls()[0]), false, true);\n        this.colPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b8(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n    }\n    queryHit(positionLeft, positionTop) {\n        let { colPositions, rowPositions } = this;\n        let col = colPositions.leftToIndex(positionLeft);\n        let row = rowPositions.topToIndex(positionTop);\n        if (row != null && col != null) {\n            let cell = this.props.cells[row][col];\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: Object.assign({\n                    range: this.getCellRange(row, col),\n                    allDay: true\n                }, cell.extraDateSpan),\n                dayEl: this.getCellEl(row, col),\n                rect: {\n                    left: colPositions.lefts[col],\n                    right: colPositions.rights[col],\n                    top: rowPositions.tops[row],\n                    bottom: rowPositions.bottoms[row]\n                },\n                layer: 0\n            };\n        }\n        return null;\n    }\n    getCellEl(row, col) {\n        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    }\n    getCellRange(row, col) {\n        let start = this.props.cells[row][col].date;\n        let end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(start, 1);\n        return {\n            start,\n            end\n        };\n    }\n}\nfunction isSegAllDay(seg) {\n    return seg.eventRange.def.allDay;\n}\nclass Table extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor(){\n        super(...arguments);\n        this.elRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.needsScrollReset = false;\n    }\n    render() {\n        let { props } = this;\n        let { dayMaxEventRows, dayMaxEvents, expandRows } = props;\n        let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n        // if rows can't expand to fill fixed height, can't do balanced-height event limit\n        // TODO: best place to normalize these options?\n        if (limitViaBalanced && !expandRows) {\n            limitViaBalanced = false;\n            dayMaxEventRows = null;\n            dayMaxEvents = null;\n        }\n        let classNames = [\n            \"fc-daygrid-body\",\n            limitViaBalanced ? \"fc-daygrid-body-balanced\" : \"fc-daygrid-body-unbalanced\",\n            expandRows ? \"\" : \"fc-daygrid-body-natural\"\n        ];\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            ref: this.elRef,\n            className: classNames.join(\" \"),\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            role: \"presentation\",\n            className: \"fc-scrollgrid-sync-table\",\n            style: {\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth,\n                height: expandRows ? props.clientHeight : \"\"\n            }\n        }, props.colGroupNode, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", {\n            role: \"presentation\"\n        }, (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRows, {\n            dateProfile: props.dateProfile,\n            cells: props.cells,\n            renderRowIntro: props.renderRowIntro,\n            showWeekNumbers: props.showWeekNumbers,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            businessHourSegs: props.businessHourSegs,\n            bgEventSegs: props.bgEventSegs,\n            fgEventSegs: props.fgEventSegs,\n            dateSelectionSegs: props.dateSelectionSegs,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            dayMaxEvents: dayMaxEvents,\n            dayMaxEventRows: dayMaxEventRows,\n            forPrint: props.forPrint,\n            isHitComboAllowed: props.isHitComboAllowed\n        }))));\n    }\n    componentDidMount() {\n        this.requestScrollReset();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.dateProfile !== this.props.dateProfile) {\n            this.requestScrollReset();\n        } else {\n            this.flushScrollReset();\n        }\n    }\n    requestScrollReset() {\n        this.needsScrollReset = true;\n        this.flushScrollReset();\n    }\n    flushScrollReset() {\n        if (this.needsScrollReset && this.props.clientWidth // sizes computed?\n        ) {\n            const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);\n            if (subjectEl) {\n                const originEl = subjectEl.closest(\".fc-daygrid-body\");\n                const scrollEl = originEl.closest(\".fc-scroller\");\n                const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;\n                scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0; // overcome border\n            }\n            this.needsScrollReset = false;\n        }\n    }\n}\nfunction getScrollSubjectEl(containerEl, dateProfile) {\n    let el;\n    if (dateProfile.currentRangeUnit.match(/year|month/)) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bv)(dateProfile.currentDate)}-01\"]`);\n    // even if view is month-based, first-of-month might be hidden...\n    }\n    if (!el) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bt)(dateProfile.currentDate)}\"]`);\n    // could still be hidden if an interior-view hidden day\n    }\n    return el;\n}\nclass DayTableSlicer extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bU {\n    constructor(){\n        super(...arguments);\n        this.forceDayIfListItem = true;\n    }\n    sliceRange(dateRange, dayTableModel) {\n        return dayTableModel.sliceRange(dateRange);\n    }\n}\nclass DayTable extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor(){\n        super(...arguments);\n        this.slicer = new DayTableSlicer();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    render() {\n        let { props, context } = this;\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Table, Object.assign({\n            ref: this.tableRef\n        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n            dateProfile: props.dateProfile,\n            cells: props.dayTableModel.cells,\n            colGroupNode: props.colGroupNode,\n            tableMinWidth: props.tableMinWidth,\n            renderRowIntro: props.renderRowIntro,\n            dayMaxEvents: props.dayMaxEvents,\n            dayMaxEventRows: props.dayMaxEventRows,\n            showWeekNumbers: props.showWeekNumbers,\n            expandRows: props.expandRows,\n            headerAlignElRef: props.headerAlignElRef,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            forPrint: props.forPrint\n        }));\n    }\n}\nclass DayTableView extends TableView {\n    constructor(){\n        super(...arguments);\n        this.buildDayTableModel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDayTableModel);\n        this.headerRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    // can't override any lifecycle methods from parent\n    }\n    render() {\n        let { options, dateProfileGenerator } = this.context;\n        let { props } = this;\n        let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n        let headerContent = options.dayHeaders && (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bI, {\n            ref: this.headerRef,\n            dateProfile: props.dateProfile,\n            dates: dayTableModel.headerDates,\n            datesRepDistinctDays: dayTableModel.rowCnt === 1\n        });\n        let bodyContent = (contentArg)=>(0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTable, {\n                ref: this.tableRef,\n                dateProfile: props.dateProfile,\n                dayTableModel: dayTableModel,\n                businessHours: props.businessHours,\n                dateSelection: props.dateSelection,\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                nextDayThreshold: options.nextDayThreshold,\n                colGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                dayMaxEvents: options.dayMaxEvents,\n                dayMaxEventRows: options.dayMaxEventRows,\n                showWeekNumbers: options.weekNumbers,\n                expandRows: !props.isHeightAuto,\n                headerAlignElRef: this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            });\n        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n    }\n}\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n    let daySeries = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bM(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bT(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\nclass TableDateProfileGenerator extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.R {\n    // Computes the date range that will be rendered\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);\n        let { props } = this;\n        return buildDayTableRenderRange({\n            currentRange: renderRange,\n            snapToWeek: /^(year|month)$/.test(currentRangeUnit),\n            fixedWeekCount: props.fixedWeekCount,\n            dateEnv: props.dateEnv\n        });\n    }\n}\nfunction buildDayTableRenderRange(props) {\n    let { dateEnv, currentRange } = props;\n    let { start, end } = currentRange;\n    let endOfWeek;\n    // year and month views should be aligned with weeks. this is already done for week\n    if (props.snapToWeek) {\n        start = dateEnv.startOfWeek(start);\n        // make end-of-week if not already\n        endOfWeek = dateEnv.startOfWeek(end);\n        if (endOfWeek.valueOf() !== end.valueOf()) {\n            end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bf)(endOfWeek, 1);\n        }\n    }\n    // ensure 6 weeks\n    if (props.fixedWeekCount) {\n        // TODO: instead of these date-math gymnastics (for multimonth view),\n        // compute dateprofiles of all months, then use start of first and end of last.\n        let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(currentRange.end, -1)));\n        let rowCnt = Math.ceil((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bg)(lastMonthRenderStart, end));\n        end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bf)(end, 6 - rowCnt);\n    }\n    return {\n        start,\n        end\n    };\n}\nvar css_248z = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';\n(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct)(css_248z);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTZ0QjtBQUMzb0I7QUFFbEY7c0hBQ3NILEdBQ3RILGtGQUFrRjtBQUNsRiwrQ0FBK0M7QUFDL0MsTUFBTWdELGtCQUFrQmhELDhEQUFhQTtJQUNqQ2lELGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxXQUFXLEdBQUdOLHVFQUFTQTtJQUNoQztJQUNBTyxtQkFBbUJDLGdCQUFnQixFQUFFQyxXQUFXLEVBQUU7UUFDOUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDN0IsSUFBSUMsV0FBVyxFQUFFO1FBQ2pCLElBQUlDLG9CQUFvQnpELGtFQUFvQkEsQ0FBQ3VELFFBQVFHLE9BQU87UUFDNUQsSUFBSU4sa0JBQWtCO1lBQ2xCSSxTQUFTRyxJQUFJLENBQUM7Z0JBQ1ZDLE1BQU07Z0JBQ05DLEtBQUs7Z0JBQ0xDLFVBQVVMO2dCQUNWTSxPQUFPO29CQUNIQyxPQUFPLElBQUksQ0FBQ2QsV0FBVztvQkFDdkJlLGdCQUFnQjtvQkFDaEJDLFlBQVlkO2dCQUNoQjtZQUNKO1FBQ0o7UUFDQUksU0FBU0csSUFBSSxDQUFDO1lBQ1ZDLE1BQU07WUFDTkMsS0FBSztZQUNMTSxRQUFRO1lBQ1JKLE9BQU87Z0JBQUVLLFNBQVNmO1lBQVk7UUFDbEM7UUFDQSxPQUFRUiwyRUFBYUEsQ0FBQzVDLDhEQUFhQSxFQUFFO1lBQUVvRSxXQUFXO2dCQUFDO2FBQWE7WUFBRUMsVUFBVWYsUUFBUWUsUUFBUTtRQUFDLEdBQ3pGekIsMkVBQWFBLENBQUMzQyw4REFBZ0JBLEVBQUU7WUFBRWlFLFFBQVEsQ0FBQ2IsTUFBTWlCLFlBQVksSUFBSSxDQUFDakIsTUFBTWtCLFFBQVE7WUFBRUMsa0JBQWtCbkIsTUFBTWtCLFFBQVE7WUFBRUUsTUFBTSxFQUFFO1lBQTZCbEIsVUFBVUE7UUFB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QUFTa1MseUJBQXlCeFosS0FBSztJQUNuQyxJQUFJLEVBQUVzSCxPQUFPLEVBQUVLLFlBQVksRUFBRSxHQUFHM0g7SUFDaEMsSUFBSSxFQUFFaUosS0FBSyxFQUFFRSxHQUFHLEVBQUUsR0FBR3hCO0lBQ3JCLElBQUlnUztJQUNKLG1GQUFtRjtJQUNuRixJQUFJM1osTUFBTXlaLFVBQVUsRUFBRTtRQUNsQnhRLFFBQVEzQixRQUFRc1MsV0FBVyxDQUFDM1E7UUFDNUIsa0NBQWtDO1FBQ2xDMFEsWUFBWXJTLFFBQVFzUyxXQUFXLENBQUN6UTtRQUNoQyxJQUFJd1EsVUFBVTlQLE9BQU8sT0FBT1YsSUFBSVUsT0FBTyxJQUFJO1lBQ3ZDVixNQUFNaEssa0VBQVFBLENBQUN3YSxXQUFXO1FBQzlCO0lBQ0o7SUFDQSxpQkFBaUI7SUFDakIsSUFBSTNaLE1BQU0wWixjQUFjLEVBQUU7UUFDdEIscUVBQXFFO1FBQ3JFLCtFQUErRTtRQUMvRSxJQUFJRyx1QkFBdUJ2UyxRQUFRc1MsV0FBVyxDQUFDdFMsUUFBUXdTLFlBQVksQ0FBQzliLGlFQUFPQSxDQUFDMkosYUFBYXdCLEdBQUcsRUFBRSxDQUFDO1FBQy9GLElBQUloSCxTQUFTb1EsS0FBS3dILElBQUksQ0FDdEIzYSxrRUFBU0EsQ0FBQ3lhLHNCQUFzQjFRO1FBQ2hDQSxNQUFNaEssa0VBQVFBLENBQUNnSyxLQUFLLElBQUloSDtJQUM1QjtJQUNBLE9BQU87UUFBRThHO1FBQU9FO0lBQUk7QUFDeEI7QUFFQSxJQUFJNlEsV0FBVztBQUNmM2Esa0VBQVlBLENBQUMyYTtBQUUwSiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYW5lci8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvaW50ZXJuYWwuanM/OTUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRlQ29tcG9uZW50LCBnZXRTdGlja3lIZWFkZXJEYXRlcywgVmlld0NvbnRhaW5lciwgU2ltcGxlU2Nyb2xsR3JpZCwgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyLCByZW5kZXJTY3JvbGxTaGltLCBjcmVhdGVGb3JtYXR0ZXIsIEJhc2VDb21wb25lbnQsIFN0YW5kYXJkRXZlbnQsIGJ1aWxkU2VnVGltZVRleHQsIEV2ZW50Q29udGFpbmVyLCBnZXRTZWdBbmNob3JBdHRycywgbWVtb2l6ZSwgTW9yZUxpbmtDb250YWluZXIsIGdldFNlZ01ldGEsIGdldFVuaXF1ZURvbUlkLCBzZXRSZWYsIERheUNlbGxDb250YWluZXIsIFdlZWtOdW1iZXJDb250YWluZXIsIGJ1aWxkTmF2TGlua0F0dHJzLCBoYXNDdXN0b21EYXlDZWxsQ29udGVudCwgYWRkTXMsIGludGVyc2VjdFJhbmdlcywgYWRkRGF5cywgU2VnSGllcmFyY2h5LCBidWlsZEVudHJ5S2V5LCBpbnRlcnNlY3RTcGFucywgUmVmTWFwLCBzb3J0RXZlbnRTZWdzLCBpc1Byb3BzRXF1YWwsIGJ1aWxkRXZlbnRSYW5nZUtleSwgQmdFdmVudCwgcmVuZGVyRmlsbCwgUG9zaXRpb25DYWNoZSwgTm93VGltZXIsIGZvcm1hdElzb01vbnRoU3RyLCBmb3JtYXREYXlTdHJpbmcsIFNsaWNlciwgRGF5SGVhZGVyLCBEYXlTZXJpZXNNb2RlbCwgRGF5VGFibGVNb2RlbCwgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGFkZFdlZWtzLCBkaWZmV2Vla3MsIGluamVjdFN0eWxlcyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZWYsIGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgZGF5Z3JpZCB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgVGFibGUgc3ViY29tcG9uZW50LCB3aGljaCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmcuXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxuY2xhc3MgVGFibGVWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGVhZGVyRWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50KSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFtdIC8qIFRPRE86IG1ha2Ugb3B0aW9uYWw/ICovLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVySFNjcm9sbExheW91dChoZWFkZXJSb3dDb250ZW50LCBib2R5Q29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCkge1xuICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBib2R5Q29udGVudCxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sR3JvdXBzOiBbeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeVJvdyhzZWdzLCByb3dDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Um93W2ldID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGJ5Um93W3NlZy5yb3ddLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuZnVuY3Rpb24gc3BsaXRTZWdzQnlGaXJzdENvbChzZWdzLCBjb2xDbnQpIHtcbiAgICBsZXQgYnlDb2wgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Q29sW2ldID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGJ5Q29sW3NlZy5maXJzdENvbF0ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlSb3codWksIHJvd0NudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHVpLnNlZ3MpIHtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5yb3ddLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxuY29uc3QgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxuICAgIG1lcmlkaWVtOiAnbmFycm93Jyxcbn0pO1xuZnVuY3Rpb24gaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykge1xuICAgIGxldCB7IGRpc3BsYXkgfSA9IHNlZy5ldmVudFJhbmdlLnVpO1xuICAgIHJldHVybiBkaXNwbGF5ID09PSAnbGlzdC1pdGVtJyB8fCAoZGlzcGxheSA9PT0gJ2F1dG8nICYmXG4gICAgICAgICFzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5ICYmXG4gICAgICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgJiYgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XG4gICAgICAgIHNlZy5pc1N0YXJ0ICYmIC8vIFwiXG4gICAgICAgIHNlZy5pc0VuZCAvLyBcIlxuICAgICk7XG59XG5cbmNsYXNzIFRhYmxlQmxvY2tFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChTdGFuZGFyZEV2ZW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWJsb2NrLWV2ZW50JywgJ2ZjLWgtZXZlbnQnXSwgZGVmYXVsdFRpbWVGb3JtYXQ6IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQsIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIGRpc2FibGVSZXNpemluZzogIXByb3BzLnNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlTGlzdEl0ZW1FdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVDtcbiAgICAgICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRydWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtZXZlbnQnLCAnZmMtZGF5Z3JpZC1kb3QtZXZlbnQnXSwgZWxBdHRyczogZ2V0U2VnQW5jaG9yQXR0cnMocHJvcHMuc2VnLCBjb250ZXh0KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50LCB0aW1lVGV4dDogdGltZVRleHQsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlIH0pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtZG90XCIsIHN0eWxlOiB7IGJvcmRlckNvbG9yOiByZW5kZXJQcm9wcy5ib3JkZXJDb2xvciB8fCByZW5kZXJQcm9wcy5iYWNrZ3JvdW5kQ29sb3IgfSB9KSxcbiAgICAgICAgcmVuZGVyUHJvcHMudGltZVRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGltZVwiIH0sIHJlbmRlclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCByZW5kZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XG59XG5cbmNsYXNzIFRhYmxlQ2VsbE1vcmVMaW5rIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcGlsZVNlZ3MgPSBtZW1vaXplKGNvbXBpbGVTZWdzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9ID0gdGhpcy5jb21waWxlU2Vncyhwcm9wcy5zaW5nbGVQbGFjZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLW1vcmUtbGluayddLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGFsbERheURhdGU6IHByb3BzLmFsbERheURhdGUsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsbFNlZ3M6IGFsbFNlZ3MsIGhpZGRlblNlZ3M6IGludmlzaWJsZVNlZ3MsIGFsaWdubWVudEVsUmVmOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBvcG92ZXJDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzRm9yY2VkSW52aXNpYmxlID0gKHByb3BzLmV2ZW50RHJhZyA/IHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBhbGxTZWdzLm1hcCgoc2VnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtaGFybmVzc1wiLCBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfSB9KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3Moc2luZ2xlUGxhY2VtZW50cykge1xuICAgIGxldCBhbGxTZWdzID0gW107XG4gICAgbGV0IGludmlzaWJsZVNlZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygc2luZ2xlUGxhY2VtZW50cykge1xuICAgICAgICBhbGxTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIGlmICghcGxhY2VtZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaW52aXNpYmxlU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGFsbFNlZ3MsIGludmlzaWJsZVNlZ3MgfTtcbn1cblxuY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbmFycm93JyB9KTtcbmNsYXNzIFRhYmxlQ2VsbCBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGF5TnVtYmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5yb290RWxSZWYsIGVsKTtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMsIHN0YXRlLCByb290RWxSZWYgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgLy8gVE9ETzogbWVtb2l6ZSB0aGlzP1xuICAgICAgICBjb25zdCBpc01vbnRoU3RhcnQgPSBwcm9wcy5zaG93RGF5TnVtYmVyICYmXG4gICAgICAgICAgICBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGVFbnYpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheScsXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCAocHJvcHMuc2hvd0RheU51bWJlciA/IHsgJ2FyaWEtbGFiZWxsZWRieSc6IHN0YXRlLmRheU51bWJlcklkIH0gOiB7fSkpLCB7IHJvbGU6ICdncmlkY2VsbCcgfSksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlclRvcElubmVyLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsIGlzTW9udGhTdGFydDogaXNNb250aFN0YXJ0LCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzKSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcHJvcHMuaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCBzdHlsZTogeyBtaW5IZWlnaHQ6IHByb3BzLm1pbkhlaWdodCB9IH0sXG4gICAgICAgICAgICBwcm9wcy5zaG93V2Vla051bWJlciAmJiAoY3JlYXRlRWxlbWVudChXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXSwgZWxBdHRyczogYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKSwgZGF0ZTogZGF0ZSwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgfSkpLFxuICAgICAgICAgICAgIXJlbmRlclByb3BzLmlzRGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAocHJvcHMuc2hvd0RheU51bWJlciB8fCBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSB8fCBwcm9wcy5mb3JjZURheVRvcCkgPyAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtZGF5Z3JpZC1kYXktbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTW9udGhTdGFydCAmJiAnZmMtZGF5Z3JpZC1tb250aC1zdGFydCcsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSkpLCB7IGlkOiBzdGF0ZS5kYXlOdW1iZXJJZCB9KSB9KSkpIDogcHJvcHMuc2hvd0RheU51bWJlciA/IChcbiAgICAgICAgICAgIC8vIGZvciBjcmVhdGluZyBjb3JyZWN0IGFtb3VudCBvZiBzcGFjZSAoc2VlIGlzc3VlICM3MTYyKVxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiwgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LW51bWJlclwiIH0sIFwiXFx1MDBBMFwiKSkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ldmVudHNcIiwgcmVmOiBwcm9wcy5mZ0NvbnRlbnRFbFJlZiB9LFxuICAgICAgICAgICAgICAgIHByb3BzLmZnQ29udGVudCxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJvdHRvbVwiLCBzdHlsZTogeyBtYXJnaW5Ub3A6IHByb3BzLm1vcmVNYXJnaW5Ub3AgfSB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbE1vcmVMaW5rLCB7IGFsbERheURhdGU6IGRhdGUsIHNpbmdsZVBsYWNlbWVudHM6IHByb3BzLnNpbmdsZVBsYWNlbWVudHMsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsaWdubWVudEVsUmVmOiByb290RWxSZWYsIGFsaWduR3JpZFRvcDogIXByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlIH0pKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJnXCIgfSwgcHJvcHMuYmdDb250ZW50KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyVG9wSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuZGF5TnVtYmVyVGV4dCB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIik7XG59XG5mdW5jdGlvbiBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBjdXJyZW50UmFuZ2UsIGRhdGVFbnYpIHtcbiAgICBjb25zdCB7IHN0YXJ0OiBjdXJyZW50U3RhcnQsIGVuZDogY3VycmVudEVuZCB9ID0gY3VycmVudFJhbmdlO1xuICAgIGNvbnN0IGN1cnJlbnRFbmRJbmNsID0gYWRkTXMoY3VycmVudEVuZCwgLTEpO1xuICAgIGNvbnN0IGN1cnJlbnRGaXJzdFllYXIgPSBkYXRlRW52LmdldFllYXIoY3VycmVudFN0YXJ0KTtcbiAgICBjb25zdCBjdXJyZW50Rmlyc3RNb250aCA9IGRhdGVFbnYuZ2V0TW9udGgoY3VycmVudFN0YXJ0KTtcbiAgICBjb25zdCBjdXJyZW50TGFzdFllYXIgPSBkYXRlRW52LmdldFllYXIoY3VycmVudEVuZEluY2wpO1xuICAgIGNvbnN0IGN1cnJlbnRMYXN0TW9udGggPSBkYXRlRW52LmdldE1vbnRoKGN1cnJlbnRFbmRJbmNsKTtcbiAgICAvLyBzcGFucyBtb3JlIHRoYW4gb25lIG1vbnRoP1xuICAgIHJldHVybiAhKGN1cnJlbnRGaXJzdFllYXIgPT09IGN1cnJlbnRMYXN0WWVhciAmJiBjdXJyZW50Rmlyc3RNb250aCA9PT0gY3VycmVudExhc3RNb250aCkgJiZcbiAgICAgICAgQm9vbGVhbihcbiAgICAgICAgLy8gZmlyc3QgZGF0ZSBpbiBjdXJyZW50IHZpZXc/XG4gICAgICAgIGRhdGUudmFsdWVPZigpID09PSBjdXJyZW50U3RhcnQudmFsdWVPZigpIHx8XG4gICAgICAgICAgICAvLyBhIG1vbnRoLXN0YXJ0IHRoYXQncyB3aXRoaW4gdGhlIGN1cnJlbnQgcmFuZ2U/XG4gICAgICAgICAgICAoZGF0ZUVudi5nZXREYXkoZGF0ZSkgPT09IDEgJiYgZGF0ZS52YWx1ZU9mKCkgPCBjdXJyZW50RW5kLnZhbHVlT2YoKSkpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ0tleShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCArICc6JyArIHNlZy5maXJzdENvbDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnVWlkKHNlZykge1xuICAgIHJldHVybiBnZW5lcmF0ZVNlZ0tleShzZWcpICsgJzonICsgc2VnLmxhc3RDb2w7XG59XG5mdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc2VncywgLy8gYXNzdW1lZCBhbHJlYWR5IHNvcnRlZFxuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MsIHN0cmljdE9yZGVyLCBzZWdIZWlnaHRzLCBtYXhDb250ZW50SGVpZ2h0LCBjZWxscykge1xuICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgRGF5R3JpZFNlZ0hpZXJhcmNoeSgoc2VnRW50cnkpID0+IHtcbiAgICAgICAgLy8gVE9ETzogbW9yZSBEUlkgd2l0aCBnZW5lcmF0ZVNlZ1VpZFxuICAgICAgICBsZXQgc2VnVWlkID0gc2Vnc1tzZWdFbnRyeS5pbmRleF0uZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkICtcbiAgICAgICAgICAgICc6JyArIHNlZ0VudHJ5LnNwYW4uc3RhcnQgK1xuICAgICAgICAgICAgJzonICsgKHNlZ0VudHJ5LnNwYW4uZW5kIC0gMSk7XG4gICAgICAgIC8vIGlmIG5vIHRoaWNrbmVzcyBrbm93biwgYXNzdW1lIDEgKGlmIDAsIHNvIHNtYWxsIGl0IGFsd2F5cyBmaXRzKVxuICAgICAgICByZXR1cm4gc2VnSGVpZ2h0c1tzZWdVaWRdIHx8IDE7XG4gICAgfSk7XG4gICAgaGllcmFyY2h5LmFsbG93UmVzbGljaW5nID0gdHJ1ZTtcbiAgICBoaWVyYXJjaHkuc3RyaWN0T3JkZXIgPSBzdHJpY3RPcmRlcjtcbiAgICBpZiAoZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZSkge1xuICAgICAgICBoaWVyYXJjaHkubWF4Q29vcmQgPSBtYXhDb250ZW50SGVpZ2h0O1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudFJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50Um93cztcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIHNlZ0lucHV0cyBvbmx5IGZvciBzZWdzIHdpdGgga25vd24gaGVpZ2h0c1xuICAgIGxldCBzZWdJbnB1dHMgPSBbXTtcbiAgICBsZXQgdW5rbm93bkhlaWdodFNlZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaV07XG4gICAgICAgIGxldCBzZWdVaWQgPSBnZW5lcmF0ZVNlZ1VpZChzZWcpO1xuICAgICAgICBsZXQgZXZlbnRIZWlnaHQgPSBzZWdIZWlnaHRzW3NlZ1VpZF07XG4gICAgICAgIGlmIChldmVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnLmZpcnN0Q29sLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIGxldCBzZWdSZWN0cyA9IGhpZXJhcmNoeS50b1JlY3RzKCk7XG4gICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfSA9IHBsYWNlUmVjdHMoc2VnUmVjdHMsIHNlZ3MsIGNlbGxzKTtcbiAgICBsZXQgbW9yZUNudHMgPSBbXTtcbiAgICBsZXQgbW9yZU1hcmdpblRvcHMgPSBbXTtcbiAgICAvLyBhZGQgc2VncyB3aXRoIHVua25vd24gaGVpZ2h0c1xuICAgIGZvciAobGV0IHNlZyBvZiB1bmtub3duSGVpZ2h0U2Vncykge1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbc2VnLmZpcnN0Q29sXS5wdXNoKHtcbiAgICAgICAgICAgIHNlZyxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgaGlkZGVuIGVudHJpZXNcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVDbnRzLnB1c2goMCk7XG4gICAgfVxuICAgIGZvciAobGV0IGhpZGRlbkVudHJ5IG9mIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaGlkZGVuRW50cnkuaW5kZXhdO1xuICAgICAgICBsZXQgaGlkZGVuU3BhbiA9IGhpZGRlbkVudHJ5LnNwYW47XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1toaWRkZW5TcGFuLnN0YXJ0XS5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGhpZGRlblNwYW4uc3RhcnQsIGhpZGRlblNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gaGlkZGVuU3Bhbi5zdGFydDsgY29sIDwgaGlkZGVuU3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBtb3JlQ250c1tjb2xdICs9IDE7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWFsIHdpdGggbGVmdG92ZXIgbWFyZ2luc1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZU1hcmdpblRvcHMucHVzaChsZWZ0b3Zlck1hcmdpbnNbY29sXSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH07XG59XG4vLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XG5mdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzLCBzZWdzLCBjZWxscykge1xuICAgIGxldCByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aCk7XG4gICAgbGV0IHNpbmdsZUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICBsZXQgbXVsdGlDb2xQbGFjZW1lbnRzID0gW107XG4gICAgbGV0IGxlZnRvdmVyTWFyZ2lucyA9IFtdO1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXTtcbiAgICAgICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xuICAgICAgICBsZXQgc2luZ2xlUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgbWl4ZWQgc3RhdGljL2Fic29sdXRlIHNlZ3MgaW4gbXVsdGlQbGFjZW1lbnRzXG4gICAgICAgIGxldCBtdWx0aVBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDE7IC8vIG11bHRpLWNvbHVtbj9cbiAgICAgICAgICAgIGxldCBpc0ZpcnN0Q29sID0gcmVjdC5zcGFuLnN0YXJ0ID09PSBjb2w7XG4gICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBzaW5jZSBib3R0b20gb2YgcHJldmlvdXMgc2VnXG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7IC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpO1xuICAgICAgICBsZWZ0b3Zlck1hcmdpbnMucHVzaChjdXJyZW50TWFyZ2luVG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfTtcbn1cbmZ1bmN0aW9uIGdyb3VwUmVjdHNCeUVhY2hDb2wocmVjdHMsIGNvbENudCkge1xuICAgIGxldCByZWN0c0J5RWFjaENvbCA9IFtdO1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgcmVjdHNCeUVhY2hDb2wucHVzaChbXSk7XG4gICAgfVxuICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0c0J5RWFjaENvbDtcbn1cbmZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnLCBzcGFuU3RhcnQsIHNwYW5FbmQsIGNlbGxzKSB7XG4gICAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xuICAgICAgICByZXR1cm4gc2VnO1xuICAgIH1cbiAgICBsZXQgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhvcmlnUmFuZ2UsIHtcbiAgICAgICAgc3RhcnQ6IGNlbGxzW3NwYW5TdGFydF0uZGF0ZSxcbiAgICAgICAgZW5kOiBhZGREYXlzKGNlbGxzW3NwYW5FbmQgLSAxXS5kYXRlLCAxKSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWcpLCB7IGZpcnN0Q29sOiBzcGFuU3RhcnQsIGxhc3RDb2w6IHNwYW5FbmQgLSAxLCBldmVudFJhbmdlOiB7XG4gICAgICAgICAgICBkZWY6IGV2ZW50UmFuZ2UuZGVmLFxuICAgICAgICAgICAgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xufVxuY2xhc3MgRGF5R3JpZFNlZ0hpZXJhcmNoeSBleHRlbmRzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLmhpZGRlbkNvbnN1bWVzID0gZmFsc2U7XG4gICAgICAgIC8vIGFsbG93cyB1cyB0byBrZWVwIGhpZGRlbiBlbnRyaWVzIGluIHRoZSBoaWVyYXJjaHkgc28gdGhleSB0YWtlIHVwIHNwYWNlXG4gICAgICAgIHRoaXMuZm9yY2VIaWRkZW4gPSB7fTtcbiAgICB9XG4gICAgYWRkU2VncyhzZWdJbnB1dHMpIHtcbiAgICAgICAgY29uc3QgaGlkZGVuU2VncyA9IHN1cGVyLmFkZFNlZ3Moc2VnSW5wdXRzKTtcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhjbHVkZUhpZGRlbiA9IChlbnRyeSkgPT4gIXRoaXMuZm9yY2VIaWRkZW5bYnVpbGRFbnRyeUtleShlbnRyeSldO1xuICAgICAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5TZWdzO1xuICAgIH1cbiAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdG91Y2hpbmdFbnRyeSwgdG91Y2hpbmdMZXZlbCwgdG91Y2hpbmdMYXRlcmFsIH0gPSBpbnNlcnRpb247XG4gICAgICAgIC8vIHRoZSBlbnRyeSB0aGF0IHRoZSBuZXcgaW5zZXJ0aW9uIGlzIHRvdWNoaW5nIG11c3QgYmUgaGlkZGVuXG4gICAgICAgIGlmICh0aGlzLmhpZGRlbkNvbnN1bWVzICYmIHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoaW5nRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkodG91Y2hpbmdFbnRyeSk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCB1cCB0aGUgdG91Y2hpbmdFbnRyeSwgcmVpbnNlcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlkZGVuRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvdWNoaW5nRW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKHRvdWNoaW5nRW50cnkuc3BhbiwgZW50cnkuc3BhbikgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBhcmVhIHRoYXQgdHVybmVkIGludG8gYSBcIm1vcmVcIiBsaW5rIChzbyBubyBvdGhlciBlbnRyaWVzIHRyeSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBvY2N1cHkgdGhlIHNwYWNlKSBidXQgbWFyayBpdCBmb3JjZWQtaGlkZGVuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZGRlbkVudHJ5SWQgPSBidWlsZEVudHJ5S2V5KGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5baGlkZGVuRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gaGlkZGVuRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChoaWRkZW5FbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3aWxsIHRyeSB0byByZXNsaWNlLi4uXG4gICAgICAgIHN1cGVyLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgfVxufVxuXG5jbGFzcyBUYWJsZVJvdyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNlbGxFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSA8dGQ+XG4gICAgICAgIHRoaXMuZnJhbWVFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1mcmFtZVxuICAgICAgICB0aGlzLmZnRWxSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZXZlbnRzXG4gICAgICAgIHRoaXMuc2VnSGFybmVzc1JlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIGluZGV4ZWQgYnkgXCJpbnN0YW5jZUlkOmZpcnN0Q29sXCJcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNlZ0hlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IChpc0ZvcmNlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRm9yY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaXppbmcodHJ1ZSk7IC8vIGlzRXh0ZXJuYWw9dHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGNvbENudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91cnNCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgaGlnaGxpZ2h0U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldEhpZ2hsaWdodFNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgbGV0IG1pcnJvclNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRNaXJyb3JTZWdzKCksIGNvbENudCk7XG4gICAgICAgIGxldCB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH0gPSBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKSwgcHJvcHMuZGF5TWF4RXZlbnRzLCBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIG9wdGlvbnMuZXZlbnRPcmRlclN0cmljdCwgc3RhdGUuc2VnSGVpZ2h0cywgc3RhdGUubWF4Q29udGVudEhlaWdodCwgcHJvcHMuY2VsbHMpO1xuICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAvLyBUT0RPOiBtZXNzeSB3YXkgdG8gY29tcHV0ZSB0aGlzXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIHt9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJlZjogdGhpcy5yb290RWxSZWYsIHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHByb3BzLnJlbmRlckludHJvICYmIHByb3BzLnJlbmRlckludHJvKCksXG4gICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoKGNlbGwsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBub3JtYWxGZ05vZGVzID0gdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLCBwcm9wcy50b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgbGV0IG1pcnJvckZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzQnlDb2xbY29sXSwgbXVsdGlDb2xQbGFjZW1lbnRzKSwgcHJvcHMudG9kYXlSYW5nZSwge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsLCB7IGtleTogY2VsbC5rZXksIGVsUmVmOiB0aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgaW5uZXJFbFJlZjogdGhpcy5mcmFtZUVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpIC8qIEZGIDx0ZD4gcHJvYmxlbSwgYnV0IG9rYXkgdG8gdXNlIGZvciBsZWZ0L3JpZ2h0LiBUT0RPOiByZW5hbWUgcHJvcCAqLywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXJzLCBzaG93V2Vla051bWJlcjogcHJvcHMuc2hvd1dlZWtOdW1iZXJzICYmIGNvbCA9PT0gMCwgZm9yY2VEYXlUb3A6IHByb3BzLnNob3dXZWVrTnVtYmVycyAvKiBldmVuIGRpc3BsYXlpbmcgd2Vla251bSBmb3Igcm93LCBub3QgbmVjZXNzYXJpbHkgZGF5ICovLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGV4dHJhUmVuZGVyUHJvcHM6IGNlbGwuZXh0cmFSZW5kZXJQcm9wcywgZXh0cmFEYXRhQXR0cnM6IGNlbGwuZXh0cmFEYXRhQXR0cnMsIGV4dHJhQ2xhc3NOYW1lczogY2VsbC5leHRyYUNsYXNzTmFtZXMsIGV4dHJhRGF0ZVNwYW46IGNlbGwuZXh0cmFEYXRlU3BhbiwgbW9yZUNudDogbW9yZUNudHNbY29sXSwgbW9yZU1hcmdpblRvcDogbW9yZU1hcmdpblRvcHNbY29sXSwgc2luZ2xlUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLCBmZ0NvbnRlbnRFbFJlZjogdGhpcy5mZ0VsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBmZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBub3JtYWxGZ05vZGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG1pcnJvckZnTm9kZXMpKSksIGJnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoaGlnaGxpZ2h0U2Vnc0J5Q29sW2NvbF0sICdoaWdobGlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoYnVzaW5lc3NIb3Vyc0J5Q29sW2NvbF0sICdub24tYnVzaW5lc3MnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKSkpLCBtaW5IZWlnaHQ6IHByb3BzLmNlbGxNaW5IZWlnaHQgfSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICBsZXQgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoIWlzUHJvcHNFcXVhbChwcmV2UHJvcHMsIGN1cnJlbnRQcm9wcykpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICBnZXRIaWdobGlnaHRTZWdzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudERyYWcuc2VncztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncztcbiAgICB9XG4gICAgZ2V0TWlycm9yU2VncygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZW5kZXJGZ1NlZ3MoY29sLCBzZWdQbGFjZW1lbnRzLCB0b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGV2ZW50U2VsZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgPSB0aGlzLnByb3BzLmNlbGxzLmxlbmd0aCA9PT0gMTsgLy8gY29sQ250ID09PSAxXG4gICAgICAgIGxldCBpc01pcnJvciA9IGlzRHJhZ2dpbmcgfHwgaXNSZXNpemluZyB8fCBpc0RhdGVTZWxlY3Rpbmc7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBzZWdQbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgc2VnIH0gPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgbGV0IHsgaW5zdGFuY2VJZCB9ID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHBsYWNlbWVudC5pc1Zpc2libGUgJiYgIWlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcGxhY2VtZW50LmlzQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pc1J0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAga25vd24gYnVnOiBldmVudHMgdGhhdCBhcmUgZm9yY2UgdG8gYmUgbGlzdC1pdGVtIGJ1dCBzcGFuIG11bHRpcGxlIGRheXMgc3RpbGwgdGFrZSB1cCBzcGFjZSBpbiBsYXRlciBjb2x1bW5zXG4gICAgICAgICAgICAgICAgdG9kbzogaW4gcHJpbnQgdmlldywgZm9yIG11bHRpLWRheSBldmVudHMsIGRvbid0IGRpc3BsYXkgdGl0bGUgd2l0aGluIG5vbi1zdGFydC9lbmQgc2Vnc1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzJyArIChpc0Fic29sdXRlID8gJyBmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJzJyA6ICcnKSwga2V5OiBnZW5lcmF0ZVNlZ0tleShzZWcpLCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGdlbmVyYXRlU2VnVWlkKHNlZykpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJycgOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogaXNBYnNvbHV0ZSA/ICcnIDogcGxhY2VtZW50Lm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogaXNBYnNvbHV0ZSA/IHBsYWNlbWVudC5hYnNvbHV0ZVRvcCA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBkZWZhdWx0RGlzcGxheUV2ZW50RW5kIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IGlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXJGaWxsU2VncyhzZWdzLCBmaWxsVHlwZSkge1xuICAgICAgICBsZXQgeyBpc1J0bCB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyB0b2RheVJhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGxlZnRSaWdodENzcyB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpIDpcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIC4uLm5vZGVzKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6aW5nKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBmcmFtZUVsUmVmcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFwcm9wcy5mb3JQcmludCAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gcG9zaXRpb25pbmcgcmVhZHk/XG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWVFbHMgPSBwcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGZyYW1lRWxSZWZzLmN1cnJlbnRNYXBbY2VsbC5rZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5FbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdQb3NpdGlvbkNhY2hlID0gbmV3IFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmZyYW1lUG9zaXRpb25zIHx8ICFzdGF0ZS5mcmFtZVBvc2l0aW9ucy5zaW1pbGFyVG8obmV3UG9zaXRpb25DYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkU2VnSGVpZ2h0cyA9IHRoaXMuc3RhdGUuc2VnSGVpZ2h0cztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlZ0hlaWdodHMgPSB0aGlzLnF1ZXJ5U2VnSGVpZ2h0cygpO1xuICAgICAgICAgICAgY29uc3QgbGltaXRCeUNvbnRlbnRIZWlnaHQgPSBwcm9wcy5kYXlNYXhFdmVudHMgPT09IHRydWUgfHwgcHJvcHMuZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIC8vIEhBQ0sgdG8gcHJldmVudCBvc2NpbGxhdGlvbnMgb2YgZXZlbnRzIGJlaW5nIHNob3duL2hpZGRlbiBmcm9tIG1heC1ldmVudC1yb3dzXG4gICAgICAgICAgICAgICAgLy8gRXNzZW50aWFsbHksIG9uY2UgeW91IGNvbXB1dGUgYW4gZWxlbWVudCdzIGhlaWdodCwgbmV2ZXIgbnVsbC1vdXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWx3YXlzIGRpc3BsYXkgYWxsIGV2ZW50cywgYXMgdmlzaWJpbGl0eTpoaWRkZW4/XG4gICAgICAgICAgICAgICAgc2VnSGVpZ2h0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRTZWdIZWlnaHRzKSwgbmV3U2VnSGVpZ2h0cyksXG4gICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVlcnlTZWdIZWlnaHRzKCkge1xuICAgICAgICBsZXQgc2VnRWxNYXAgPSB0aGlzLnNlZ0hhcm5lc3NSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIGxldCBzZWdIZWlnaHRzID0ge307XG4gICAgICAgIC8vIGdldCB0aGUgbWF4IGhlaWdodCBhbW9uZ3N0IGluc3RhbmNlIHNlZ3NcbiAgICAgICAgZm9yIChsZXQgc2VnVWlkIGluIHNlZ0VsTWFwKSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5yb3VuZChzZWdFbE1hcFtzZWdVaWRdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICBzZWdIZWlnaHRzW3NlZ1VpZF0gPSBNYXRoLm1heChzZWdIZWlnaHRzW3NlZ1VpZF0gfHwgMCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VnSGVpZ2h0cztcbiAgICB9XG4gICAgY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIGxldCBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5O1xuICAgICAgICBsZXQgY2VsbEVsID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICBsZXQgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuICAgIGdldENlbGxFbHMoKSB7XG4gICAgICAgIGxldCBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGVsTWFwW2NlbGwua2V5XSk7XG4gICAgfVxufVxuVGFibGVSb3cuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2VnSGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2VncywgY29sUGxhY2VtZW50cykge1xuICAgIGlmICghbWlycm9yU2Vncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgdG9wc0J5SW5zdGFuY2VJZCA9IGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpOyAvLyBUT0RPOiBjYWNoZSB0aGlzIGF0IGZpcnN0IHJlbmRlcj9cbiAgICByZXR1cm4gbWlycm9yU2Vncy5tYXAoKHNlZykgPT4gKHtcbiAgICAgICAgc2VnLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGFic29sdXRlVG9wOiB0b3BzQnlJbnN0YW5jZUlkW3NlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cykge1xuICAgIGxldCB0b3BzQnlJbnN0YW5jZUlkID0ge307XG4gICAgZm9yIChsZXQgcGxhY2VtZW50cyBvZiBjb2xQbGFjZW1lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICB0b3BzQnlJbnN0YW5jZUlkW3BsYWNlbWVudC5zZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHBsYWNlbWVudC5hYnNvbHV0ZVRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9wc0J5SW5zdGFuY2VJZDtcbn1cblxuY2xhc3MgVGFibGVSb3dzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgdGhpcy5yb3dSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgcm93Q250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudCk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCByb3dDbnQpO1xuICAgICAgICAvLyBmb3IgRGF5R3JpZCB2aWV3IHdpdGggbWFueSByb3dzLCBmb3JjZSBhIG1pbi1oZWlnaHQgb24gY2VsbHMgc28gZG9lc24ndCBhcHBlYXIgc3F1aXNoZWRcbiAgICAgICAgLy8gY2hvb3NlIDcgYmVjYXVzZSBhIG1vbnRoIHZpZXcgd2lsbCBoYXZlIG1heCA2IHJvd3NcbiAgICAgICAgbGV0IGNlbGxNaW5IZWlnaHQgPSAocm93Q250ID49IDcgJiYgcHJvcHMuY2xpZW50V2lkdGgpID9cbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoIC8gY29udGV4dC5vcHRpb25zLmFzcGVjdFJhdGlvIC8gNiA6XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmNlbGxzLm1hcCgoY2VsbHMsIHJvdykgPT4gKGNyZWF0ZUVsZW1lbnQoVGFibGVSb3csIHsgcmVmOiB0aGlzLnJvd1JlZnMuY3JlYXRlUmVmKHJvdyksIGtleTogY2VsbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBjZWxsc1swXS5kYXRlLnRvSVNPU3RyaW5nKCkgLyogYmVzdD8gb3IgcHV0IGtleSBvbiBjZWxsPyBvciB1c2UgZGlmZiBmb3JtYXR0ZXI/ICovXG4gICAgICAgICAgICAgICAgOiByb3cgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2VsbHMgKGxpa2Ugd2hlbiByZXNvdXJjZSB2aWV3IGlzIGxvYWRpbmcpXG4gICAgICAgICAgICAsIHNob3dEYXlOdW1iZXJzOiByb3dDbnQgPiAxLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogY2VsbHMsIHJlbmRlckludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W3Jvd10sIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbcm93XS5maWx0ZXIoaXNTZWdBbGxEYXkpIC8qIGhhY2sgKi8sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W3Jvd10sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W3Jvd10sIGV2ZW50RHJhZzogZXZlbnREcmFnQnlSb3dbcm93XSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbcm93XSwgZGF5TWF4RXZlbnRzOiBwcm9wcy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBjZWxsTWluSGVpZ2h0OiBjZWxsTWluSGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBmb3IgaWYgc3RhcnRlZCB3aXRoIHplcm8gY2VsbHNcbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KCk7XG4gICAgfVxuICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290RWwpIHtcbiAgICAgICAgICAgIC8vIEhBQ0s6IG5lZWQgYSBkYXlncmlkIHdyYXBwZXIgcGFyZW50IHRvIGRvIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICAvLyBOT1RFOiBhIGRheWdyaWQgcmVzb3VyY2UgdmlldyB3L28gcmVzb3VyY2VzIGNhbiBoYXZlIHplcm8gY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbEVsID0gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpWzBdO1xuICAgICAgICAgICAgY29uc3Qgcm9vdEVsID0gZmlyc3RDZWxsRWwgPyBmaXJzdENlbGxFbC5jbG9zZXN0KCcuZmMtZGF5Z3JpZC1ib2R5JykgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IHRoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RFbCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgICAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY29sbGVjdCgpLm1hcCgocm93T2JqKSA9PiByb3dPYmouZ2V0Q2VsbEVscygpWzBdKSwgLy8gZmlyc3QgY2VsbCBlbCBpbiBlYWNoIHJvdy4gVE9ETzogbm90IG9wdGltYWxcbiAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbFBvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKCksIC8vIGNlbGwgZWxzIGluIGZpcnN0IHJvd1xuICAgICAgICB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgIGZhbHNlKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICBsZXQgeyBjb2xQb3NpdGlvbnMsIHJvd1Bvc2l0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNvbCA9IGNvbFBvc2l0aW9ucy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xuICAgICAgICBsZXQgcm93ID0gcm93UG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiB0aGlzLnByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgcmFuZ2U6IHRoaXMuZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSwgYWxsRGF5OiB0cnVlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJvd1Bvc2l0aW9ucy50b3BzW3Jvd10sXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2VsbEVsKHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFtyb3ddLmdldENlbGxFbHMoKVtjb2xdOyAvLyBUT0RPOiBub3Qgb3B0aW1hbFxuICAgIH1cbiAgICBnZXRDZWxsUmFuZ2Uocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZTtcbiAgICAgICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTZWdBbGxEYXkoc2VnKSB7XG4gICAgcmV0dXJuIHNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXk7XG59XG5cbmNsYXNzIFRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRheU1heEV2ZW50Um93cywgZGF5TWF4RXZlbnRzLCBleHBhbmRSb3dzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGxpbWl0VmlhQmFsYW5jZWQgPSBkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAvLyBpZiByb3dzIGNhbid0IGV4cGFuZCB0byBmaWxsIGZpeGVkIGhlaWdodCwgY2FuJ3QgZG8gYmFsYW5jZWQtaGVpZ2h0IGV2ZW50IGxpbWl0XG4gICAgICAgIC8vIFRPRE86IGJlc3QgcGxhY2UgdG8gbm9ybWFsaXplIHRoZXNlIG9wdGlvbnM/XG4gICAgICAgIGlmIChsaW1pdFZpYUJhbGFuY2VkICYmICFleHBhbmRSb3dzKSB7XG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1kYXlncmlkLWJvZHknLFxuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA/ICdmYy1kYXlncmlkLWJvZHktYmFsYW5jZWQnIDogJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJyxcbiAgICAgICAgICAgIGV4cGFuZFJvd3MgPyAnJyA6ICdmYy1kYXlncmlkLWJvZHktbmF0dXJhbCcsIC8vIHdpbGwgaGVpZ2h0IG9mIG9uZSByb3cgZGVwZW5kIG9uIHRoZSBvdGhlcnM/XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5lbFJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBwcm9wcyBhcmUgaW1wb3J0YW50IHRvIGdpdmUgdGhpcyB3cmFwcGVyIGNvcnJlY3QgZGltZW5zaW9ucyBmb3IgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgd2Ugc2V0IGl0IGhlcmUsIGNhbiB3ZSBhdm9pZCBnaXZpbmcgdG8gaW5uZXIgdGFibGVzP1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtdGFibGVcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsXG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIHByb3BzLmNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGFibGVSb3dzLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IHByb3BzLmNlbGxzLCByZW5kZXJSb3dJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBidXNpbmVzc0hvdXJTZWdzOiBwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBiZ0V2ZW50U2VnczogcHJvcHMuYmdFdmVudFNlZ3MsIGZnRXZlbnRTZWdzOiBwcm9wcy5mZ0V2ZW50U2VncywgZGF0ZVNlbGVjdGlvblNlZ3M6IHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGRheU1heEV2ZW50czogZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IGRheU1heEV2ZW50Um93cywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBpc0hpdENvbWJvQWxsb3dlZDogcHJvcHMuaXNIaXRDb21ib0FsbG93ZWQgfSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFNjcm9sbFJlc2V0KCkge1xuICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZsdXNoU2Nyb2xsUmVzZXQoKTtcbiAgICB9XG4gICAgZmx1c2hTY3JvbGxSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNTY3JvbGxSZXNldCAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jbGllbnRXaWR0aCAvLyBzaXplcyBjb21wdXRlZD9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0RWwgPSBnZXRTY3JvbGxTdWJqZWN0RWwodGhpcy5lbFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLmRhdGVQcm9maWxlKTtcbiAgICAgICAgICAgIGlmIChzdWJqZWN0RWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5FbCA9IHN1YmplY3RFbC5jbG9zZXN0KCcuZmMtZGF5Z3JpZC1ib2R5Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBvcmlnaW5FbC5jbG9zZXN0KCcuZmMtc2Nyb2xsZXInKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBzdWJqZWN0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC1cbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCA/IChzY3JvbGxUb3AgKyAxKSA6IDA7IC8vIG92ZXJjb21lIGJvcmRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxTdWJqZWN0RWwoY29udGFpbmVyRWwsIGRhdGVQcm9maWxlKSB7XG4gICAgbGV0IGVsO1xuICAgIGlmIChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0Lm1hdGNoKC95ZWFyfG1vbnRoLykpIHtcbiAgICAgICAgZWwgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXRJc29Nb250aFN0cihkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSl9LTAxXCJdYCk7XG4gICAgICAgIC8vIGV2ZW4gaWYgdmlldyBpcyBtb250aC1iYXNlZCwgZmlyc3Qtb2YtbW9udGggbWlnaHQgYmUgaGlkZGVuLi4uXG4gICAgfVxuICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXREYXlTdHJpbmcoZGF0ZVByb2ZpbGUuY3VycmVudERhdGUpfVwiXWApO1xuICAgICAgICAvLyBjb3VsZCBzdGlsbCBiZSBoaWRkZW4gaWYgYW4gaW50ZXJpb3ItdmlldyBoaWRkZW4gZGF5XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cblxuY2xhc3MgRGF5VGFibGVTbGljZXIgZXh0ZW5kcyBTbGljZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWU7XG4gICAgfVxuICAgIHNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRhYmxlU2xpY2VyKCk7XG4gICAgICAgIHRoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRhYmxlUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKSwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzLCBjb2xHcm91cE5vZGU6IHByb3BzLmNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiBwcm9wcy5leHBhbmRSb3dzLCBoZWFkZXJBbGlnbkVsUmVmOiBwcm9wcy5oZWFkZXJBbGlnbkVsUmVmLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlVmlldyBleHRlbmRzIFRhYmxlVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsID0gbWVtb2l6ZShidWlsZERheVRhYmxlTW9kZWwpO1xuICAgICAgICB0aGlzLmhlYWRlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnRhYmxlUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIC8vIGNhbid0IG92ZXJyaWRlIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBmcm9tIHBhcmVudFxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsKHByb3BzLmRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIGxldCBoZWFkZXJDb250ZW50ID0gb3B0aW9ucy5kYXlIZWFkZXJzICYmIChjcmVhdGVFbGVtZW50KERheUhlYWRlciwgeyByZWY6IHRoaXMuaGVhZGVyUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlc1JlcERpc3RpbmN0RGF5czogZGF5VGFibGVNb2RlbC5yb3dDbnQgPT09IDEgfSkpO1xuICAgICAgICBsZXQgYm9keUNvbnRlbnQgPSAoY29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIHsgcmVmOiB0aGlzLnRhYmxlUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50U3RvcmU6IHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGRheU1heEV2ZW50czogb3B0aW9ucy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogb3B0aW9ucy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogb3B0aW9ucy53ZWVrTnVtYmVycywgZXhwYW5kUm93czogIXByb3BzLmlzSGVpZ2h0QXV0bywgaGVhZGVyQWxpZ25FbFJlZjogdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRheU1pbldpZHRoXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIG9wdGlvbnMuZGF5TWluV2lkdGgpXG4gICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVRhYmxlTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRheVNlcmllcyA9IG5ldyBEYXlTZXJpZXNNb2RlbChkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpO1xufVxuXG5jbGFzcyBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIGV4dGVuZHMgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZFxuICAgIGJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIGxldCByZW5kZXJSYW5nZSA9IHN1cGVyLmJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2Uoe1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiByZW5kZXJSYW5nZSxcbiAgICAgICAgICAgIHNuYXBUb1dlZWs6IC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiBwcm9wcy5maXhlZFdlZWtDb3VudCxcbiAgICAgICAgICAgIGRhdGVFbnY6IHByb3BzLmRhdGVFbnYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZShwcm9wcykge1xuICAgIGxldCB7IGRhdGVFbnYsIGN1cnJlbnRSYW5nZSB9ID0gcHJvcHM7XG4gICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gY3VycmVudFJhbmdlO1xuICAgIGxldCBlbmRPZldlZWs7XG4gICAgLy8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcbiAgICBpZiAocHJvcHMuc25hcFRvV2Vlaykge1xuICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoc3RhcnQpO1xuICAgICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XG4gICAgICAgIGVuZE9mV2VlayA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZW5kKTtcbiAgICAgICAgaWYgKGVuZE9mV2Vlay52YWx1ZU9mKCkgIT09IGVuZC52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZE9mV2VlaywgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZW5zdXJlIDYgd2Vla3NcbiAgICBpZiAocHJvcHMuZml4ZWRXZWVrQ291bnQpIHtcbiAgICAgICAgLy8gVE9ETzogaW5zdGVhZCBvZiB0aGVzZSBkYXRlLW1hdGggZ3ltbmFzdGljcyAoZm9yIG11bHRpbW9udGggdmlldyksXG4gICAgICAgIC8vIGNvbXB1dGUgZGF0ZXByb2ZpbGVzIG9mIGFsbCBtb250aHMsIHRoZW4gdXNlIHN0YXJ0IG9mIGZpcnN0IGFuZCBlbmQgb2YgbGFzdC5cbiAgICAgICAgbGV0IGxhc3RNb250aFJlbmRlclN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhkYXRlRW52LnN0YXJ0T2ZNb250aChhZGREYXlzKGN1cnJlbnRSYW5nZS5lbmQsIC0xKSkpO1xuICAgICAgICBsZXQgcm93Q250ID0gTWF0aC5jZWlsKC8vIGNvdWxkIGJlIHBhcnRpYWwgd2Vla3MgZHVlIHRvIGhpZGRlbkRheXNcbiAgICAgICAgZGlmZldlZWtzKGxhc3RNb250aFJlbmRlclN0YXJ0LCBlbmQpKTtcbiAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kLCA2IC0gcm93Q250KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGg6OHB4fS5mYy1kYXlncmlkLWRheS1ldmVudHM6YWZ0ZXIsLmZjLWRheWdyaWQtZGF5LWV2ZW50czpiZWZvcmUsLmZjLWRheWdyaWQtZGF5LWZyYW1lOmFmdGVyLC5mYy1kYXlncmlkLWRheS1mcmFtZTpiZWZvcmUsLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczphZnRlciwuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzOmJlZm9yZXtjbGVhcjpib3RoO2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTp0YWJsZX0uZmMgLmZjLWRheWdyaWQtYm9keXtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjF9LmZjIC5mYy1kYXlncmlkLWRheS5mYy1kYXktdG9kYXl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy10b2RheS1iZy1jb2xvcil9LmZjIC5mYy1kYXlncmlkLWRheS1mcmFtZXttaW4taGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWRheS10b3B7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtZGF5LW90aGVyIC5mYy1kYXlncmlkLWRheS10b3B7b3BhY2l0eTouM30uZmMgLmZjLWRheWdyaWQtZGF5LW51bWJlcntwYWRkaW5nOjRweDtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjR9LmZjIC5mYy1kYXlncmlkLW1vbnRoLXN0YXJ0e2ZvbnQtc2l6ZToxLjFlbTtmb250LXdlaWdodDo3MDB9LmZjIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWFyZ2luLXRvcDoxcHh9LmZjIC5mYy1kYXlncmlkLWJvZHktYmFsYW5jZWQgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWluLWhlaWdodDoyZW07cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWJvZHktbmF0dXJhbCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21hcmdpbi1ib3R0b206MWVtfS5mYyAuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNze3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFic3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWRheWdyaWQtYmctaGFybmVzc3tib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MH0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1ub24tYnVzaW5lc3N7ei1pbmRleDoxfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLWJnLWV2ZW50e3otaW5kZXg6Mn0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtZGF5Z3JpZC1ldmVudHttYXJnaW4tdG9wOjFweDt6LWluZGV4OjZ9LmZjIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LW1pcnJvcnt6LWluZGV4Ojd9LmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b217Zm9udC1zaXplOi44NWVtO21hcmdpbjowIDJweH0uZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbTphZnRlciwuZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbTpiZWZvcmV7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjIC5mYy1kYXlncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtjdXJzb3I6cG9pbnRlcjtsaW5lLWhlaWdodDoxO21hcmdpbi10b3A6MXB4O21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjJweDtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo0fS5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbms6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC4xKX0uZmMgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1uZXV0cmFsLXRleHQtY29sb3IpO21pbi13aWR0aDoxLjVlbTtwYWRkaW5nOjJweDtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjt0b3A6MDt6LWluZGV4OjV9LmZjIC5mYy1tb3JlLXBvcG92ZXIgLmZjLXBvcG92ZXItYm9keXttaW4td2lkdGg6MjIwcHg7cGFkZGluZzoxMHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZHttYXJnaW4tbGVmdDoycHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtZW5kLC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LXN0YXJ0e21hcmdpbi1yaWdodDoycHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtbW9yZS1saW5re2Zsb2F0OmxlZnR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7Ym9yZGVyLXJhZGl1czowIDAgM3B4IDA7bGVmdDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLW1vcmUtbGlua3tmbG9hdDpyaWdodH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntib3JkZXItcmFkaXVzOjAgMCAwIDNweDtyaWdodDowfS5mYy1saXF1aWQtaGFjayAuZmMtZGF5Z3JpZC1kYXktZnJhbWV7cG9zaXRpb246c3RhdGljfS5mYy1kYXlncmlkLWV2ZW50e2JvcmRlci1yYWRpdXM6M3B4O2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcH0uZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXdlaWdodDo3MDB9LmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpbWUsLmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpdGxle3BhZGRpbmc6MXB4fS5mYy1kYXlncmlkLWRvdC1ldmVudHthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O3BhZGRpbmc6MnB4IDB9LmZjLWRheWdyaWQtZG90LWV2ZW50IC5mYy1ldmVudC10aXRsZXtmbGV4LWdyb3c6MTtmbGV4LXNocmluazoxO2ZvbnQtd2VpZ2h0OjcwMDttaW4td2lkdGg6MDtvdmVyZmxvdzpoaWRkZW59LmZjLWRheWdyaWQtZG90LWV2ZW50LmZjLWV2ZW50LW1pcnJvciwuZmMtZGF5Z3JpZC1kb3QtZXZlbnQ6aG92ZXJ7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4xKX0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRheWdyaWQtZXZlbnQtZG90e2JvcmRlcjpjYWxjKHZhcigtLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoKS8yKSBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2JvcmRlci1yYWRpdXM6Y2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCkvMik7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MDttYXJnaW46MCA0cHg7d2lkdGg6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXttYXJnaW4tcmlnaHQ6M3B4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50IC5mYy1ldmVudC10aW1le21hcmdpbi1sZWZ0OjNweH1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmV4cG9ydCB7IERheVRhYmxlVmlldyBhcyBEYXlHcmlkVmlldywgRGF5VGFibGUsIERheVRhYmxlU2xpY2VyLCBUYWJsZSwgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciwgVGFibGVSb3dzLCBUYWJsZVZpZXcsIGJ1aWxkRGF5VGFibGVNb2RlbCwgYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlIH07XG4iXSwibmFtZXMiOlsiRGF0ZUNvbXBvbmVudCIsImdldFN0aWNreUhlYWRlckRhdGVzIiwiVmlld0NvbnRhaW5lciIsIlNpbXBsZVNjcm9sbEdyaWQiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJyZW5kZXJTY3JvbGxTaGltIiwiY3JlYXRlRm9ybWF0dGVyIiwiQmFzZUNvbXBvbmVudCIsIlN0YW5kYXJkRXZlbnQiLCJidWlsZFNlZ1RpbWVUZXh0IiwiRXZlbnRDb250YWluZXIiLCJnZXRTZWdBbmNob3JBdHRycyIsIm1lbW9pemUiLCJNb3JlTGlua0NvbnRhaW5lciIsImdldFNlZ01ldGEiLCJnZXRVbmlxdWVEb21JZCIsInNldFJlZiIsIkRheUNlbGxDb250YWluZXIiLCJXZWVrTnVtYmVyQ29udGFpbmVyIiwiYnVpbGROYXZMaW5rQXR0cnMiLCJoYXNDdXN0b21EYXlDZWxsQ29udGVudCIsImFkZE1zIiwiaW50ZXJzZWN0UmFuZ2VzIiwiYWRkRGF5cyIsIlNlZ0hpZXJhcmNoeSIsImJ1aWxkRW50cnlLZXkiLCJpbnRlcnNlY3RTcGFucyIsIlJlZk1hcCIsInNvcnRFdmVudFNlZ3MiLCJpc1Byb3BzRXF1YWwiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJCZ0V2ZW50IiwicmVuZGVyRmlsbCIsIlBvc2l0aW9uQ2FjaGUiLCJOb3dUaW1lciIsImZvcm1hdElzb01vbnRoU3RyIiwiZm9ybWF0RGF5U3RyaW5nIiwiU2xpY2VyIiwiRGF5SGVhZGVyIiwiRGF5U2VyaWVzTW9kZWwiLCJEYXlUYWJsZU1vZGVsIiwiRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJhZGRXZWVrcyIsImRpZmZXZWVrcyIsImluamVjdFN0eWxlcyIsImNyZWF0ZVJlZiIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIlRhYmxlVmlldyIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwiaGVhZGVyRWxSZWYiLCJyZW5kZXJTaW1wbGVMYXlvdXQiLCJoZWFkZXJSb3dDb250ZW50IiwiYm9keUNvbnRlbnQiLCJwcm9wcyIsImNvbnRleHQiLCJzZWN0aW9ucyIsInN0aWNreUhlYWRlckRhdGVzIiwib3B0aW9ucyIsInB1c2giLCJ0eXBlIiwia2V5IiwiaXNTdGlja3kiLCJjaHVuayIsImVsUmVmIiwidGFibGVDbGFzc05hbWUiLCJyb3dDb250ZW50IiwibGlxdWlkIiwiY29udGVudCIsImVsQ2xhc3NlcyIsInZpZXdTcGVjIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29scyIsInJlbmRlckhTY3JvbGxMYXlvdXQiLCJjb2xDbnQiLCJkYXlNaW5XaWR0aCIsIlNjcm9sbEdyaWQiLCJwbHVnaW5Ib29rcyIsInNjcm9sbEdyaWRJbXBsIiwiRXJyb3IiLCJzdGlja3lGb290ZXJTY3JvbGxiYXIiLCJjaHVua3MiLCJjb2xHcm91cHMiLCJzcGFuIiwibWluV2lkdGgiLCJzcGxpdFNlZ3NCeVJvdyIsInNlZ3MiLCJyb3dDbnQiLCJieVJvdyIsImkiLCJzZWciLCJyb3ciLCJzcGxpdFNlZ3NCeUZpcnN0Q29sIiwiYnlDb2wiLCJmaXJzdENvbCIsInNwbGl0SW50ZXJhY3Rpb25CeVJvdyIsInVpIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJpc0V2ZW50IiwiREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCIsImhvdXIiLCJtaW51dGUiLCJvbWl0WmVyb01pbnV0ZSIsIm1lcmlkaWVtIiwiaGFzTGlzdEl0ZW1EaXNwbGF5IiwiZGlzcGxheSIsImV2ZW50UmFuZ2UiLCJkZWYiLCJhbGxEYXkiLCJsYXN0Q29sIiwiaXNTdGFydCIsImlzRW5kIiwiVGFibGVCbG9ja0V2ZW50IiwicmVuZGVyIiwiT2JqZWN0IiwiYXNzaWduIiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJkZWZhdWx0RGlzcGxheUV2ZW50RW5kIiwiZGlzYWJsZVJlc2l6aW5nIiwiVGFibGVMaXN0SXRlbUV2ZW50IiwidGltZUZvcm1hdCIsImV2ZW50VGltZUZvcm1hdCIsInRpbWVUZXh0IiwiZWxUYWciLCJlbEF0dHJzIiwiZGVmYXVsdEdlbmVyYXRvciIsInJlbmRlcklubmVyQ29udGVudCIsImlzUmVzaXppbmciLCJpc0RhdGVTZWxlY3RpbmciLCJyZW5kZXJQcm9wcyIsImNsYXNzTmFtZSIsInN0eWxlIiwiYm9yZGVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJldmVudCIsInRpdGxlIiwiVGFibGVDZWxsTW9yZUxpbmsiLCJjb21waWxlU2VncyIsImFsbFNlZ3MiLCJpbnZpc2libGVTZWdzIiwic2luZ2xlUGxhY2VtZW50cyIsImRhdGVQcm9maWxlIiwidG9kYXlSYW5nZSIsImFsbERheURhdGUiLCJtb3JlQ250IiwiaGlkZGVuU2VncyIsImFsaWdubWVudEVsUmVmIiwiYWxpZ25HcmlkVG9wIiwiZXh0cmFEYXRlU3BhbiIsInBvcG92ZXJDb250ZW50IiwiaXNGb3JjZWRJbnZpc2libGUiLCJldmVudERyYWciLCJldmVudFJlc2l6ZSIsIm1hcCIsImluc3RhbmNlSWQiLCJpbnN0YW5jZSIsInZpc2liaWxpdHkiLCJpc0RyYWdnaW5nIiwiaXNTZWxlY3RlZCIsImV2ZW50U2VsZWN0aW9uIiwicGxhY2VtZW50IiwiaXNWaXNpYmxlIiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCJ3ZWVrIiwiVGFibGVDZWxsIiwicm9vdEVsUmVmIiwic3RhdGUiLCJkYXlOdW1iZXJJZCIsImhhbmRsZVJvb3RFbCIsImVsIiwiZGF0ZUVudiIsImRhdGUiLCJpc01vbnRoU3RhcnQiLCJzaG93RGF5TnVtYmVyIiwic2hvdWxkRGlzcGxheU1vbnRoU3RhcnQiLCJjdXJyZW50UmFuZ2UiLCJleHRyYUNsYXNzTmFtZXMiLCJleHRyYURhdGFBdHRycyIsInJvbGUiLCJyZW5kZXJUb3BJbm5lciIsImV4dHJhUmVuZGVyUHJvcHMiLCJJbm5lckNvbnRlbnQiLCJyZWYiLCJpbm5lckVsUmVmIiwibWluSGVpZ2h0Iiwic2hvd1dlZWtOdW1iZXIiLCJkZWZhdWx0Rm9ybWF0IiwiaXNEaXNhYmxlZCIsImZvcmNlRGF5VG9wIiwiaWQiLCJ1bmRlZmluZWQiLCJmZ0NvbnRlbnRFbFJlZiIsImZnQ29udGVudCIsIm1hcmdpblRvcCIsIm1vcmVNYXJnaW5Ub3AiLCJiZ0NvbnRlbnQiLCJkYXlOdW1iZXJUZXh0Iiwic3RhcnQiLCJjdXJyZW50U3RhcnQiLCJlbmQiLCJjdXJyZW50RW5kIiwiY3VycmVudEVuZEluY2wiLCJjdXJyZW50Rmlyc3RZZWFyIiwiZ2V0WWVhciIsImN1cnJlbnRGaXJzdE1vbnRoIiwiZ2V0TW9udGgiLCJjdXJyZW50TGFzdFllYXIiLCJjdXJyZW50TGFzdE1vbnRoIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJnZXREYXkiLCJnZW5lcmF0ZVNlZ0tleSIsImdlbmVyYXRlU2VnVWlkIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50IiwiZGF5TWF4RXZlbnRzIiwiZGF5TWF4RXZlbnRSb3dzIiwic3RyaWN0T3JkZXIiLCJzZWdIZWlnaHRzIiwibWF4Q29udGVudEhlaWdodCIsImNlbGxzIiwiaGllcmFyY2h5IiwiRGF5R3JpZFNlZ0hpZXJhcmNoeSIsInNlZ0VudHJ5Iiwic2VnVWlkIiwiaW5kZXgiLCJhbGxvd1Jlc2xpY2luZyIsIm1heENvb3JkIiwiaGlkZGVuQ29uc3VtZXMiLCJtYXhTdGFja0NudCIsInNlZ0lucHV0cyIsInVua25vd25IZWlnaHRTZWdzIiwibGVuZ3RoIiwiZXZlbnRIZWlnaHQiLCJoaWRkZW5FbnRyaWVzIiwiYWRkU2VncyIsInNlZ1JlY3RzIiwidG9SZWN0cyIsInNpbmdsZUNvbFBsYWNlbWVudHMiLCJtdWx0aUNvbFBsYWNlbWVudHMiLCJsZWZ0b3Zlck1hcmdpbnMiLCJwbGFjZVJlY3RzIiwibW9yZUNudHMiLCJtb3JlTWFyZ2luVG9wcyIsImlzQWJzb2x1dGUiLCJhYnNvbHV0ZVRvcCIsImNvbCIsInJlc2xpY2VTZWciLCJoaWRkZW5FbnRyeSIsImhpZGRlblNwYW4iLCJhbGxSZWN0cyIsInJlY3RzQnlFYWNoQ29sIiwiZ3JvdXBSZWN0c0J5RWFjaENvbCIsInJlY3RzIiwiY3VycmVudEhlaWdodCIsImN1cnJlbnRNYXJnaW5Ub3AiLCJyZWN0IiwibGV2ZWxDb29yZCIsInRoaWNrbmVzcyIsIm11bHRpUGxhY2VtZW50cyIsImlzRmlyc3RDb2wiLCJzcGFuU3RhcnQiLCJzcGFuRW5kIiwib3JpZ1JhbmdlIiwicmFuZ2UiLCJzbGljZWRSYW5nZSIsImR1cmF0aW9uRWRpdGFibGUiLCJmb3JjZUhpZGRlbiIsImVudHJpZXNCeUxldmVsIiwiZXhjbHVkZUhpZGRlbiIsImVudHJ5IiwibGV2ZWwiLCJmaWx0ZXIiLCJoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uIiwiaW5zZXJ0aW9uIiwidG91Y2hpbmdFbnRyeSIsInRvdWNoaW5nTGV2ZWwiLCJ0b3VjaGluZ0xhdGVyYWwiLCJ0b3VjaGluZ0VudHJ5SWQiLCJoaWRkZW5FbnRyeUlkIiwic3BsaXRFbnRyeSIsIlRhYmxlUm93IiwiY2VsbEVsUmVmcyIsImZyYW1lRWxSZWZzIiwiZmdFbFJlZnMiLCJzZWdIYXJuZXNzUmVmcyIsImZyYW1lUG9zaXRpb25zIiwiaGFuZGxlUmVzaXplIiwiaXNGb3JjZWQiLCJ1cGRhdGVTaXppbmciLCJidXNpbmVzc0hvdXJzQnlDb2wiLCJidXNpbmVzc0hvdXJTZWdzIiwiYmdFdmVudFNlZ3NCeUNvbCIsImJnRXZlbnRTZWdzIiwiaGlnaGxpZ2h0U2Vnc0J5Q29sIiwiZ2V0SGlnaGxpZ2h0U2VncyIsIm1pcnJvclNlZ3NCeUNvbCIsImdldE1pcnJvclNlZ3MiLCJmZ0V2ZW50U2VncyIsImV2ZW50T3JkZXIiLCJldmVudE9yZGVyU3RyaWN0IiwicmVuZGVySW50cm8iLCJjZWxsIiwibm9ybWFsRmdOb2RlcyIsInJlbmRlckZnU2VncyIsIm1pcnJvckZnTm9kZXMiLCJidWlsZE1pcnJvclBsYWNlbWVudHMiLCJzaG93RGF5TnVtYmVycyIsInNob3dXZWVrTnVtYmVycyIsInJlbmRlckZpbGxTZWdzIiwiY2VsbE1pbkhlaWdodCIsImNvbXBvbmVudERpZE1vdW50IiwiYWRkUmVzaXplSGFuZGxlciIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsImN1cnJlbnRQcm9wcyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlUmVzaXplSGFuZGxlciIsImRhdGVTZWxlY3Rpb25TZWdzIiwic2VnUGxhY2VtZW50cyIsImlzTWlycm9yIiwibm9kZXMiLCJsZWZ0IiwicmlnaHQiLCJpc1J0bCIsImxlZnRzIiwicmlnaHRzIiwidG9wIiwiZmlsbFR5cGUiLCJsZWZ0UmlnaHRDc3MiLCJpc0V4dGVybmFsU2l6aW5nQ2hhbmdlIiwiY2xpZW50V2lkdGgiLCJmcmFtZUVscyIsImN1cnJlbnRNYXAiLCJvcmlnaW5FbCIsImN1cnJlbnQiLCJuZXdQb3NpdGlvbkNhY2hlIiwic2ltaWxhclRvIiwic2V0U3RhdGUiLCJvbGRTZWdIZWlnaHRzIiwibmV3U2VnSGVpZ2h0cyIsInF1ZXJ5U2VnSGVpZ2h0cyIsImxpbWl0QnlDb250ZW50SGVpZ2h0Iiwic2FmZVNldFN0YXRlIiwiY29tcHV0ZU1heENvbnRlbnRIZWlnaHQiLCJzZWdFbE1hcCIsImhlaWdodCIsIk1hdGgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm1heCIsImZpcnN0S2V5IiwiY2VsbEVsIiwiZmNDb250YWluZXJFbCIsImJvdHRvbSIsImdldENlbGxFbHMiLCJlbE1hcCIsImFkZFN0YXRlRXF1YWxpdHkiLCJtaXJyb3JTZWdzIiwiY29sUGxhY2VtZW50cyIsInRvcHNCeUluc3RhbmNlSWQiLCJidWlsZEFic29sdXRlVG9wSGFzaCIsInBsYWNlbWVudHMiLCJUYWJsZVJvd3MiLCJzcGxpdEJ1c2luZXNzSG91clNlZ3MiLCJzcGxpdEJnRXZlbnRTZWdzIiwic3BsaXRGZ0V2ZW50U2VncyIsInNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MiLCJzcGxpdEV2ZW50RHJhZyIsInNwbGl0RXZlbnRSZXNpemUiLCJyb3dSZWZzIiwiYnVzaW5lc3NIb3VyU2Vnc0J5Um93IiwiYmdFdmVudFNlZ3NCeVJvdyIsImZnRXZlbnRTZWdzQnlSb3ciLCJkYXRlU2VsZWN0aW9uU2Vnc0J5Um93IiwiZXZlbnREcmFnQnlSb3ciLCJldmVudFJlc2l6ZUJ5Um93IiwiYXNwZWN0UmF0aW8iLCJ1bml0Iiwibm93RGF0ZSIsInRvSVNPU3RyaW5nIiwicmVuZGVyUm93SW50cm8iLCJpc1NlZ0FsbERheSIsImNsaWVudEhlaWdodCIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJyb290RWwiLCJmaXJzdENlbGxFbCIsImNsb3Nlc3QiLCJpc0hpdENvbWJvQWxsb3dlZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsInByZXBhcmVIaXRzIiwicm93UG9zaXRpb25zIiwiY29sbGVjdCIsInJvd09iaiIsImNvbFBvc2l0aW9ucyIsInF1ZXJ5SGl0IiwicG9zaXRpb25MZWZ0IiwicG9zaXRpb25Ub3AiLCJsZWZ0VG9JbmRleCIsInRvcFRvSW5kZXgiLCJkYXRlU3BhbiIsImdldENlbGxSYW5nZSIsImRheUVsIiwiZ2V0Q2VsbEVsIiwidG9wcyIsImJvdHRvbXMiLCJsYXllciIsIlRhYmxlIiwibmVlZHNTY3JvbGxSZXNldCIsImV4cGFuZFJvd3MiLCJsaW1pdFZpYUJhbGFuY2VkIiwiY2xhc3NOYW1lcyIsImpvaW4iLCJ3aWR0aCIsInRhYmxlTWluV2lkdGgiLCJjb2xHcm91cE5vZGUiLCJyZXF1ZXN0U2Nyb2xsUmVzZXQiLCJmbHVzaFNjcm9sbFJlc2V0Iiwic3ViamVjdEVsIiwiZ2V0U2Nyb2xsU3ViamVjdEVsIiwic2Nyb2xsRWwiLCJzY3JvbGxUb3AiLCJjb250YWluZXJFbCIsImN1cnJlbnRSYW5nZVVuaXQiLCJtYXRjaCIsInF1ZXJ5U2VsZWN0b3IiLCJjdXJyZW50RGF0ZSIsIkRheVRhYmxlU2xpY2VyIiwiZm9yY2VEYXlJZkxpc3RJdGVtIiwic2xpY2VSYW5nZSIsImRhdGVSYW5nZSIsImRheVRhYmxlTW9kZWwiLCJEYXlUYWJsZSIsInNsaWNlciIsInRhYmxlUmVmIiwic2xpY2VQcm9wcyIsIm5leHREYXlUaHJlc2hvbGQiLCJoZWFkZXJBbGlnbkVsUmVmIiwiRGF5VGFibGVWaWV3IiwiYnVpbGREYXlUYWJsZU1vZGVsIiwiaGVhZGVyUmVmIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJoZWFkZXJDb250ZW50IiwiZGF5SGVhZGVycyIsImRhdGVzIiwiaGVhZGVyRGF0ZXMiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsImNvbnRlbnRBcmciLCJidXNpbmVzc0hvdXJzIiwiZGF0ZVNlbGVjdGlvbiIsImV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJ0YWJsZUNvbEdyb3VwTm9kZSIsIndlZWtOdW1iZXJzIiwiZGF5U2VyaWVzIiwicmVuZGVyUmFuZ2UiLCJ0ZXN0IiwiVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciIsImJ1aWxkUmVuZGVyUmFuZ2UiLCJpc1JhbmdlQWxsRGF5IiwiYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlIiwic25hcFRvV2VlayIsImZpeGVkV2Vla0NvdW50IiwiZW5kT2ZXZWVrIiwic3RhcnRPZldlZWsiLCJsYXN0TW9udGhSZW5kZXJTdGFydCIsInN0YXJ0T2ZNb250aCIsImNlaWwiLCJjc3NfMjQ4eiIsIkRheUdyaWRWaWV3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/daygrid/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@fullcalendar/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FullCalendar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/core */ \"(ssr)/./node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/core/internal */ \"(ssr)/./node_modules/@fullcalendar/core/internal-common.js\");\n\n\n\n\nconst reactMajorVersion = parseInt(String(react__WEBPACK_IMPORTED_MODULE_0__.version).split(\".\")[0]);\nconst syncRenderingByDefault = reactMajorVersion < 18;\nclass FullCalendar extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(){\n        super(...arguments);\n        this.elRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n        this.isUpdating = false;\n        this.isUnmounting = false;\n        this.state = {\n            customRenderingMap: new Map()\n        };\n        this.requestResize = ()=>{\n            if (!this.isUnmounting) {\n                this.cancelResize();\n                this.resizeId = requestAnimationFrame(()=>{\n                    this.doResize();\n                });\n            }\n        };\n    }\n    render() {\n        const customRenderingNodes = [];\n        for (const customRendering of this.state.customRenderingMap.values()){\n            customRenderingNodes.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomRenderingComponent, {\n                key: customRendering.id,\n                customRendering: customRendering\n            }));\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: this.elRef\n        }, customRenderingNodes);\n    }\n    componentDidMount() {\n        // reset b/c react strict-mode calls componentWillUnmount/componentDidMount\n        this.isUnmounting = false;\n        const customRenderingStore = new _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__.cv();\n        this.handleCustomRendering = customRenderingStore.handle.bind(customRenderingStore);\n        this.calendar = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__.Calendar(this.elRef.current, Object.assign(Object.assign({}, this.props), {\n            handleCustomRendering: this.handleCustomRendering\n        }));\n        this.calendar.render();\n        // attaching with .on() will cause this to fire AFTER internal preact rendering did flushSync\n        this.calendar.on(\"_beforeprint\", ()=>{\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            // our `customRenderingMap` state will be flushed at this point\n            });\n        });\n        let lastRequestTimestamp;\n        customRenderingStore.subscribe((customRenderingMap)=>{\n            const requestTimestamp = Date.now();\n            const isMounting = !lastRequestTimestamp;\n            const runFunc = // don't call flushSync if React version already does sync rendering by default\n            // guards against fatal errors:\n            // https://github.com/fullcalendar/fullcalendar/issues/7448\n            syncRenderingByDefault || //\n            isMounting || this.isUpdating || this.isUnmounting || requestTimestamp - lastRequestTimestamp < 100 // rerendering frequently\n             ? runNow // either sync rendering (first-time or React 16/17) or async (React 18)\n             : react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync; // guaranteed sync rendering\n            runFunc(()=>{\n                this.setState({\n                    customRenderingMap\n                }, ()=>{\n                    lastRequestTimestamp = requestTimestamp;\n                    if (isMounting) {\n                        this.doResize();\n                    } else {\n                        this.requestResize();\n                    }\n                });\n            });\n        });\n    }\n    componentDidUpdate() {\n        this.isUpdating = true;\n        this.calendar.resetOptions(Object.assign(Object.assign({}, this.props), {\n            handleCustomRendering: this.handleCustomRendering\n        }));\n        this.isUpdating = false;\n    }\n    componentWillUnmount() {\n        this.isUnmounting = true;\n        this.cancelResize();\n        this.calendar.destroy();\n    }\n    doResize() {\n        this.calendar.updateSize();\n    }\n    cancelResize() {\n        if (this.resizeId !== undefined) {\n            cancelAnimationFrame(this.resizeId);\n            this.resizeId = undefined;\n        }\n    }\n    getApi() {\n        return this.calendar;\n    }\n}\nFullCalendar.act = runNow; // DEPRECATED. Not leveraged anymore\nclass CustomRenderingComponent extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    render() {\n        const { customRendering } = this.props;\n        const { generatorMeta } = customRendering;\n        const vnode = typeof generatorMeta === \"function\" ? generatorMeta(customRendering.renderProps) : generatorMeta;\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(vnode, customRendering.containerEl);\n    }\n}\n// Util\n// -------------------------------------------------------------------------------------------------\nfunction runNow(f) {\n    f();\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1FO0FBQ2Y7QUFDTDtBQUNxQjtBQUNwRSxNQUFNUSxvQkFBb0JDLFNBQVNDLE9BQU9WLDBDQUFhLEVBQUVZLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUN0RSxNQUFNQyx5QkFBeUJMLG9CQUFvQjtBQUNwQyxNQUFNTSxxQkFBcUJiLDRDQUFTQTtJQUMvQ2MsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNDLEtBQUssaUJBQUdmLGdEQUFTQTtRQUN0QixJQUFJLENBQUNnQixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDVEMsb0JBQW9CLElBQUlDO1FBQzVCO1FBQ0EsSUFBSSxDQUFDQyxhQUFhLEdBQUc7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQ0osWUFBWSxFQUFFO2dCQUNwQixJQUFJLENBQUNLLFlBQVk7Z0JBQ2pCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQyxzQkFBc0I7b0JBQ2xDLElBQUksQ0FBQ0MsUUFBUTtnQkFDakI7WUFDSjtRQUNKO0lBQ0o7SUFDQUMsU0FBUztRQUNMLE1BQU1DLHVCQUF1QixFQUFFO1FBQy9CLEtBQUssTUFBTUMsbUJBQW1CLElBQUksQ0FBQ1YsS0FBSyxDQUFDQyxrQkFBa0IsQ0FBQ1UsTUFBTSxHQUFJO1lBQ2xFRixxQkFBcUJHLElBQUksZUFBQ2hDLGdEQUFtQixDQUFDa0MsMEJBQTBCO2dCQUFFQyxLQUFLTCxnQkFBZ0JNLEVBQUU7Z0JBQUVOLGlCQUFpQkE7WUFBZ0I7UUFDeEk7UUFDQSxxQkFBUTlCLGdEQUFtQixDQUFDLE9BQU87WUFBRXFDLEtBQUssSUFBSSxDQUFDcEIsS0FBSztRQUFDLEdBQUdZO0lBQzVEO0lBQ0FTLG9CQUFvQjtRQUNoQiwyRUFBMkU7UUFDM0UsSUFBSSxDQUFD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InNvdXJjZXMiOlsid2VicGFjazovL3BsYW5lci8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3JlYWN0L2Rpc3QvaW5kZXguanM/ZDdiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBjcmVhdGVSZWYsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwsIGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBDYWxlbmRhciwgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUnO1xuaW1wb3J0IHsgQ3VzdG9tUmVuZGVyaW5nU3RvcmUsIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsJztcbmNvbnN0IHJlYWN0TWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoU3RyaW5nKFJlYWN0LnZlcnNpb24pLnNwbGl0KCcuJylbMF0pO1xuY29uc3Qgc3luY1JlbmRlcmluZ0J5RGVmYXVsdCA9IHJlYWN0TWFqb3JWZXJzaW9uIDwgMTg7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdWxsQ2FsZW5kYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY3VzdG9tUmVuZGVyaW5nTWFwOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBjdXN0b21SZW5kZXJpbmdOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbVJlbmRlcmluZyBvZiB0aGlzLnN0YXRlLmN1c3RvbVJlbmRlcmluZ01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY3VzdG9tUmVuZGVyaW5nTm9kZXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbVJlbmRlcmluZ0NvbXBvbmVudCwgeyBrZXk6IGN1c3RvbVJlbmRlcmluZy5pZCwgY3VzdG9tUmVuZGVyaW5nOiBjdXN0b21SZW5kZXJpbmcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5lbFJlZiB9LCBjdXN0b21SZW5kZXJpbmdOb2RlcykpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgLy8gcmVzZXQgYi9jIHJlYWN0IHN0cmljdC1tb2RlIGNhbGxzIGNvbXBvbmVudFdpbGxVbm1vdW50L2NvbXBvbmVudERpZE1vdW50XG4gICAgICAgIHRoaXMuaXNVbm1vdW50aW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGN1c3RvbVJlbmRlcmluZ1N0b3JlID0gbmV3IEN1c3RvbVJlbmRlcmluZ1N0b3JlKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nID0gY3VzdG9tUmVuZGVyaW5nU3RvcmUuaGFuZGxlLmJpbmQoY3VzdG9tUmVuZGVyaW5nU3RvcmUpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyID0gbmV3IENhbGVuZGFyKHRoaXMuZWxSZWYuY3VycmVudCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSwgeyBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IHRoaXMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIH0pKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5yZW5kZXIoKTtcbiAgICAgICAgLy8gYXR0YWNoaW5nIHdpdGggLm9uKCkgd2lsbCBjYXVzZSB0aGlzIHRvIGZpcmUgQUZURVIgaW50ZXJuYWwgcHJlYWN0IHJlbmRlcmluZyBkaWQgZmx1c2hTeW5jXG4gICAgICAgIHRoaXMuY2FsZW5kYXIub24oJ19iZWZvcmVwcmludCcsICgpID0+IHtcbiAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gb3VyIGBjdXN0b21SZW5kZXJpbmdNYXBgIHN0YXRlIHdpbGwgYmUgZmx1c2hlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0UmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgY3VzdG9tUmVuZGVyaW5nU3RvcmUuc3Vic2NyaWJlKChjdXN0b21SZW5kZXJpbmdNYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgaXNNb3VudGluZyA9ICFsYXN0UmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgIGNvbnN0IHJ1bkZ1bmMgPSAoXG4gICAgICAgICAgICAvLyBkb24ndCBjYWxsIGZsdXNoU3luYyBpZiBSZWFjdCB2ZXJzaW9uIGFscmVhZHkgZG9lcyBzeW5jIHJlbmRlcmluZyBieSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBndWFyZHMgYWdhaW5zdCBmYXRhbCBlcnJvcnM6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNzQ0OFxuICAgICAgICAgICAgc3luY1JlbmRlcmluZ0J5RGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaXNNb3VudGluZyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNVbm1vdW50aW5nIHx8XG4gICAgICAgICAgICAgICAgKHJlcXVlc3RUaW1lc3RhbXAgLSBsYXN0UmVxdWVzdFRpbWVzdGFtcCkgPCAxMDAgLy8gcmVyZW5kZXJpbmcgZnJlcXVlbnRseVxuICAgICAgICAgICAgKSA/IHJ1bk5vdyAvLyBlaXRoZXIgc3luYyByZW5kZXJpbmcgKGZpcnN0LXRpbWUgb3IgUmVhY3QgMTYvMTcpIG9yIGFzeW5jIChSZWFjdCAxOClcbiAgICAgICAgICAgICAgICA6IGZsdXNoU3luYzsgLy8gZ3VhcmFudGVlZCBzeW5jIHJlbmRlcmluZ1xuICAgICAgICAgICAgcnVuRnVuYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGN1c3RvbVJlbmRlcmluZ01hcCB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0VGltZXN0YW1wID0gcmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZXNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5yZXNldE9wdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSwgeyBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IHRoaXMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIH0pKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkb1Jlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhci51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIGNhbmNlbFJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVJZCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFwaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXI7XG4gICAgfVxufVxuRnVsbENhbGVuZGFyLmFjdCA9IHJ1bk5vdzsgLy8gREVQUkVDQVRFRC4gTm90IGxldmVyYWdlZCBhbnltb3JlXG5jbGFzcyBDdXN0b21SZW5kZXJpbmdDb21wb25lbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VzdG9tUmVuZGVyaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRvck1ldGEgfSA9IGN1c3RvbVJlbmRlcmluZztcbiAgICAgICAgY29uc3Qgdm5vZGUgPSB0eXBlb2YgZ2VuZXJhdG9yTWV0YSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBnZW5lcmF0b3JNZXRhKGN1c3RvbVJlbmRlcmluZy5yZW5kZXJQcm9wcykgOlxuICAgICAgICAgICAgZ2VuZXJhdG9yTWV0YTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY3VzdG9tUmVuZGVyaW5nLmNvbnRhaW5lckVsKTtcbiAgICB9XG59XG4vLyBVdGlsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBydW5Ob3coZikge1xuICAgIGYoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJSZWFjdCIsIkNvbXBvbmVudCIsImNyZWF0ZVJlZiIsIlB1cmVDb21wb25lbnQiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJDYWxlbmRhciIsIkN1c3RvbVJlbmRlcmluZ1N0b3JlIiwicmVhY3RNYWpvclZlcnNpb24iLCJwYXJzZUludCIsIlN0cmluZyIsInZlcnNpb24iLCJzcGxpdCIsInN5bmNSZW5kZXJpbmdCeURlZmF1bHQiLCJGdWxsQ2FsZW5kYXIiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsImVsUmVmIiwiaXNVcGRhdGluZyIsImlzVW5tb3VudGluZyIsInN0YXRlIiwiY3VzdG9tUmVuZGVyaW5nTWFwIiwiTWFwIiwicmVxdWVzdFJlc2l6ZSIsImNhbmNlbFJlc2l6ZSIsInJlc2l6ZUlkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZG9SZXNpemUiLCJyZW5kZXIiLCJjdXN0b21SZW5kZXJpbmdOb2RlcyIsImN1c3RvbVJlbmRlcmluZyIsInZhbHVlcyIsInB1c2giLCJjcmVhdGVFbGVtZW50IiwiQ3VzdG9tUmVuZGVyaW5nQ29tcG9uZW50Iiwia2V5IiwiaWQiLCJyZWYiLCJjb21wb25lbnREaWRNb3VudCIsImN1c3RvbVJlbmRlcmluZ1N0b3JlIiwiaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIiwiaGFuZGxlIiwiYmluZCIsImNhbGVuZGFyIiwiY3VycmVudCIsIk9iamVjdCIsImFzc2lnbiIsInByb3BzIiwib24iLCJsYXN0UmVxdWVzdFRpbWVzdGFtcCIsInN1YnNjcmliZSIsInJlcXVlc3RUaW1lc3RhbXAiLCJEYXRlIiwibm93IiwiaXNNb3VudGluZyIsInJ1bkZ1bmMiLCJydW5Ob3ciLCJzZXRTdGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsInJlc2V0T3B0aW9ucyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZGVzdHJveSIsInVwZGF0ZVNpemUiLCJ1bmRlZmluZWQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImdldEFwaSIsImFjdCIsImdlbmVyYXRvck1ldGEiLCJ2bm9kZSIsInJlbmRlclByb3BzIiwiY29udGFpbmVyRWwiLCJmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@fullcalendar/react/dist/index.js\n");

/***/ })

};
;